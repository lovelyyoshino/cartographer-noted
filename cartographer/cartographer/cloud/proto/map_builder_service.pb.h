// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: cartographer/cloud/proto/map_builder_service.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3011000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3011002 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "cartographer/mapping/proto/pose_graph.pb.h"
#include "cartographer/mapping/proto/serialization.pb.h"
#include "cartographer/mapping/proto/submap_visualization.pb.h"
#include "cartographer/mapping/proto/trajectory_builder_options.pb.h"
#include "cartographer/sensor/proto/sensor.pb.h"
#include "cartographer/transform/proto/transform.pb.h"
#include <google/protobuf/empty.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[57]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto;
namespace cartographer {
namespace cloud {
namespace proto {
class AddFixedFramePoseDataRequest;
class AddFixedFramePoseDataRequestDefaultTypeInternal;
extern AddFixedFramePoseDataRequestDefaultTypeInternal _AddFixedFramePoseDataRequest_default_instance_;
class AddImuDataRequest;
class AddImuDataRequestDefaultTypeInternal;
extern AddImuDataRequestDefaultTypeInternal _AddImuDataRequest_default_instance_;
class AddLandmarkDataRequest;
class AddLandmarkDataRequestDefaultTypeInternal;
extern AddLandmarkDataRequestDefaultTypeInternal _AddLandmarkDataRequest_default_instance_;
class AddOdometryDataRequest;
class AddOdometryDataRequestDefaultTypeInternal;
extern AddOdometryDataRequestDefaultTypeInternal _AddOdometryDataRequest_default_instance_;
class AddRangefinderDataRequest;
class AddRangefinderDataRequestDefaultTypeInternal;
extern AddRangefinderDataRequestDefaultTypeInternal _AddRangefinderDataRequest_default_instance_;
class AddSensorDataBatchRequest;
class AddSensorDataBatchRequestDefaultTypeInternal;
extern AddSensorDataBatchRequestDefaultTypeInternal _AddSensorDataBatchRequest_default_instance_;
class AddTrajectoryRequest;
class AddTrajectoryRequestDefaultTypeInternal;
extern AddTrajectoryRequestDefaultTypeInternal _AddTrajectoryRequest_default_instance_;
class AddTrajectoryResponse;
class AddTrajectoryResponseDefaultTypeInternal;
extern AddTrajectoryResponseDefaultTypeInternal _AddTrajectoryResponse_default_instance_;
class DeleteTrajectoryRequest;
class DeleteTrajectoryRequestDefaultTypeInternal;
extern DeleteTrajectoryRequestDefaultTypeInternal _DeleteTrajectoryRequest_default_instance_;
class FinishTrajectoryRequest;
class FinishTrajectoryRequestDefaultTypeInternal;
extern FinishTrajectoryRequestDefaultTypeInternal _FinishTrajectoryRequest_default_instance_;
class GetAllSubmapPosesResponse;
class GetAllSubmapPosesResponseDefaultTypeInternal;
extern GetAllSubmapPosesResponseDefaultTypeInternal _GetAllSubmapPosesResponse_default_instance_;
class GetConstraintsResponse;
class GetConstraintsResponseDefaultTypeInternal;
extern GetConstraintsResponseDefaultTypeInternal _GetConstraintsResponse_default_instance_;
class GetLandmarkPosesResponse;
class GetLandmarkPosesResponseDefaultTypeInternal;
extern GetLandmarkPosesResponseDefaultTypeInternal _GetLandmarkPosesResponse_default_instance_;
class GetLocalToGlobalTransformRequest;
class GetLocalToGlobalTransformRequestDefaultTypeInternal;
extern GetLocalToGlobalTransformRequestDefaultTypeInternal _GetLocalToGlobalTransformRequest_default_instance_;
class GetLocalToGlobalTransformResponse;
class GetLocalToGlobalTransformResponseDefaultTypeInternal;
extern GetLocalToGlobalTransformResponseDefaultTypeInternal _GetLocalToGlobalTransformResponse_default_instance_;
class GetSubmapRequest;
class GetSubmapRequestDefaultTypeInternal;
extern GetSubmapRequestDefaultTypeInternal _GetSubmapRequest_default_instance_;
class GetSubmapResponse;
class GetSubmapResponseDefaultTypeInternal;
extern GetSubmapResponseDefaultTypeInternal _GetSubmapResponse_default_instance_;
class GetTrajectoryNodePosesResponse;
class GetTrajectoryNodePosesResponseDefaultTypeInternal;
extern GetTrajectoryNodePosesResponseDefaultTypeInternal _GetTrajectoryNodePosesResponse_default_instance_;
class GetTrajectoryStatesResponse;
class GetTrajectoryStatesResponseDefaultTypeInternal;
extern GetTrajectoryStatesResponseDefaultTypeInternal _GetTrajectoryStatesResponse_default_instance_;
class GetTrajectoryStatesResponse_TrajectoriesStateEntry_DoNotUse;
class GetTrajectoryStatesResponse_TrajectoriesStateEntry_DoNotUseDefaultTypeInternal;
extern GetTrajectoryStatesResponse_TrajectoriesStateEntry_DoNotUseDefaultTypeInternal _GetTrajectoryStatesResponse_TrajectoriesStateEntry_DoNotUse_default_instance_;
class IsTrajectoryFinishedRequest;
class IsTrajectoryFinishedRequestDefaultTypeInternal;
extern IsTrajectoryFinishedRequestDefaultTypeInternal _IsTrajectoryFinishedRequest_default_instance_;
class IsTrajectoryFinishedResponse;
class IsTrajectoryFinishedResponseDefaultTypeInternal;
extern IsTrajectoryFinishedResponseDefaultTypeInternal _IsTrajectoryFinishedResponse_default_instance_;
class IsTrajectoryFrozenRequest;
class IsTrajectoryFrozenRequestDefaultTypeInternal;
extern IsTrajectoryFrozenRequestDefaultTypeInternal _IsTrajectoryFrozenRequest_default_instance_;
class IsTrajectoryFrozenResponse;
class IsTrajectoryFrozenResponseDefaultTypeInternal;
extern IsTrajectoryFrozenResponseDefaultTypeInternal _IsTrajectoryFrozenResponse_default_instance_;
class LoadStateFromFileRequest;
class LoadStateFromFileRequestDefaultTypeInternal;
extern LoadStateFromFileRequestDefaultTypeInternal _LoadStateFromFileRequest_default_instance_;
class LoadStateFromFileResponse;
class LoadStateFromFileResponseDefaultTypeInternal;
extern LoadStateFromFileResponseDefaultTypeInternal _LoadStateFromFileResponse_default_instance_;
class LoadStateRequest;
class LoadStateRequestDefaultTypeInternal;
extern LoadStateRequestDefaultTypeInternal _LoadStateRequest_default_instance_;
class LoadStateResponse;
class LoadStateResponseDefaultTypeInternal;
extern LoadStateResponseDefaultTypeInternal _LoadStateResponse_default_instance_;
class LocalSlamInsertionResult;
class LocalSlamInsertionResultDefaultTypeInternal;
extern LocalSlamInsertionResultDefaultTypeInternal _LocalSlamInsertionResult_default_instance_;
class OKagv_FinishTrajectoryResponse;
class OKagv_FinishTrajectoryResponseDefaultTypeInternal;
extern OKagv_FinishTrajectoryResponseDefaultTypeInternal _OKagv_FinishTrajectoryResponse_default_instance_;
class OKagv_GetOrderResponse;
class OKagv_GetOrderResponseDefaultTypeInternal;
extern OKagv_GetOrderResponseDefaultTypeInternal _OKagv_GetOrderResponse_default_instance_;
class OKagv_GetTrajectoryStateResponse;
class OKagv_GetTrajectoryStateResponseDefaultTypeInternal;
extern OKagv_GetTrajectoryStateResponseDefaultTypeInternal _OKagv_GetTrajectoryStateResponse_default_instance_;
class OKagv_LoadTrajectoryRequest;
class OKagv_LoadTrajectoryRequestDefaultTypeInternal;
extern OKagv_LoadTrajectoryRequestDefaultTypeInternal _OKagv_LoadTrajectoryRequest_default_instance_;
class OKagv_LoadTrajectoryResponse;
class OKagv_LoadTrajectoryResponseDefaultTypeInternal;
extern OKagv_LoadTrajectoryResponseDefaultTypeInternal _OKagv_LoadTrajectoryResponse_default_instance_;
class OKagv_LocalizeTrajectoryRequest;
class OKagv_LocalizeTrajectoryRequestDefaultTypeInternal;
extern OKagv_LocalizeTrajectoryRequestDefaultTypeInternal _OKagv_LocalizeTrajectoryRequest_default_instance_;
class OKagv_LocalizeTrajectoryResponse;
class OKagv_LocalizeTrajectoryResponseDefaultTypeInternal;
extern OKagv_LocalizeTrajectoryResponseDefaultTypeInternal _OKagv_LocalizeTrajectoryResponse_default_instance_;
class OKagv_SaveTrajectoryRequest;
class OKagv_SaveTrajectoryRequestDefaultTypeInternal;
extern OKagv_SaveTrajectoryRequestDefaultTypeInternal _OKagv_SaveTrajectoryRequest_default_instance_;
class OKagv_StartTrajectoryRequest;
class OKagv_StartTrajectoryRequestDefaultTypeInternal;
extern OKagv_StartTrajectoryRequestDefaultTypeInternal _OKagv_StartTrajectoryRequest_default_instance_;
class OKagv_StartTrajectoryResponse;
class OKagv_StartTrajectoryResponseDefaultTypeInternal;
extern OKagv_StartTrajectoryResponseDefaultTypeInternal _OKagv_StartTrajectoryResponse_default_instance_;
class OKagv_WaitTrajectoryResponse;
class OKagv_WaitTrajectoryResponseDefaultTypeInternal;
extern OKagv_WaitTrajectoryResponseDefaultTypeInternal _OKagv_WaitTrajectoryResponse_default_instance_;
class ReceiveGlobalSlamOptimizationsResponse;
class ReceiveGlobalSlamOptimizationsResponseDefaultTypeInternal;
extern ReceiveGlobalSlamOptimizationsResponseDefaultTypeInternal _ReceiveGlobalSlamOptimizationsResponse_default_instance_;
class ReceiveGlobalSlamOptimizationsResponse_LastOptimizedNodeIdsEntry_DoNotUse;
class ReceiveGlobalSlamOptimizationsResponse_LastOptimizedNodeIdsEntry_DoNotUseDefaultTypeInternal;
extern ReceiveGlobalSlamOptimizationsResponse_LastOptimizedNodeIdsEntry_DoNotUseDefaultTypeInternal _ReceiveGlobalSlamOptimizationsResponse_LastOptimizedNodeIdsEntry_DoNotUse_default_instance_;
class ReceiveGlobalSlamOptimizationsResponse_LastOptimizedSubmapIdsEntry_DoNotUse;
class ReceiveGlobalSlamOptimizationsResponse_LastOptimizedSubmapIdsEntry_DoNotUseDefaultTypeInternal;
extern ReceiveGlobalSlamOptimizationsResponse_LastOptimizedSubmapIdsEntry_DoNotUseDefaultTypeInternal _ReceiveGlobalSlamOptimizationsResponse_LastOptimizedSubmapIdsEntry_DoNotUse_default_instance_;
class ReceiveLocalSlamResultsRequest;
class ReceiveLocalSlamResultsRequestDefaultTypeInternal;
extern ReceiveLocalSlamResultsRequestDefaultTypeInternal _ReceiveLocalSlamResultsRequest_default_instance_;
class ReceiveLocalSlamResultsResponse;
class ReceiveLocalSlamResultsResponseDefaultTypeInternal;
extern ReceiveLocalSlamResultsResponseDefaultTypeInternal _ReceiveLocalSlamResultsResponse_default_instance_;
class SensorData;
class SensorDataDefaultTypeInternal;
extern SensorDataDefaultTypeInternal _SensorData_default_instance_;
class SensorId;
class SensorIdDefaultTypeInternal;
extern SensorIdDefaultTypeInternal _SensorId_default_instance_;
class SensorMetadata;
class SensorMetadataDefaultTypeInternal;
extern SensorMetadataDefaultTypeInternal _SensorMetadata_default_instance_;
class SetLandmarkPoseRequest;
class SetLandmarkPoseRequestDefaultTypeInternal;
extern SetLandmarkPoseRequestDefaultTypeInternal _SetLandmarkPoseRequest_default_instance_;
class SubmapPose;
class SubmapPoseDefaultTypeInternal;
extern SubmapPoseDefaultTypeInternal _SubmapPose_default_instance_;
class TrajectoryNodePose;
class TrajectoryNodePoseDefaultTypeInternal;
extern TrajectoryNodePoseDefaultTypeInternal _TrajectoryNodePose_default_instance_;
class TrajectoryNodePose_ConstantPoseData;
class TrajectoryNodePose_ConstantPoseDataDefaultTypeInternal;
extern TrajectoryNodePose_ConstantPoseDataDefaultTypeInternal _TrajectoryNodePose_ConstantPoseData_default_instance_;
class TrajectoryRemapping;
class TrajectoryRemappingDefaultTypeInternal;
extern TrajectoryRemappingDefaultTypeInternal _TrajectoryRemapping_default_instance_;
class TrajectoryRemapping_SerializedTrajectoriesToTrajectoriesEntry_DoNotUse;
class TrajectoryRemapping_SerializedTrajectoriesToTrajectoriesEntry_DoNotUseDefaultTypeInternal;
extern TrajectoryRemapping_SerializedTrajectoriesToTrajectoriesEntry_DoNotUseDefaultTypeInternal _TrajectoryRemapping_SerializedTrajectoriesToTrajectoriesEntry_DoNotUse_default_instance_;
class WriteStateResponse;
class WriteStateResponseDefaultTypeInternal;
extern WriteStateResponseDefaultTypeInternal _WriteStateResponse_default_instance_;
class WriteStateToFileRequest;
class WriteStateToFileRequestDefaultTypeInternal;
extern WriteStateToFileRequestDefaultTypeInternal _WriteStateToFileRequest_default_instance_;
class WriteStateToFileResponse;
class WriteStateToFileResponseDefaultTypeInternal;
extern WriteStateToFileResponseDefaultTypeInternal _WriteStateToFileResponse_default_instance_;
}  // namespace proto
}  // namespace cloud
}  // namespace cartographer
PROTOBUF_NAMESPACE_OPEN
template<> ::cartographer::cloud::proto::AddFixedFramePoseDataRequest* Arena::CreateMaybeMessage<::cartographer::cloud::proto::AddFixedFramePoseDataRequest>(Arena*);
template<> ::cartographer::cloud::proto::AddImuDataRequest* Arena::CreateMaybeMessage<::cartographer::cloud::proto::AddImuDataRequest>(Arena*);
template<> ::cartographer::cloud::proto::AddLandmarkDataRequest* Arena::CreateMaybeMessage<::cartographer::cloud::proto::AddLandmarkDataRequest>(Arena*);
template<> ::cartographer::cloud::proto::AddOdometryDataRequest* Arena::CreateMaybeMessage<::cartographer::cloud::proto::AddOdometryDataRequest>(Arena*);
template<> ::cartographer::cloud::proto::AddRangefinderDataRequest* Arena::CreateMaybeMessage<::cartographer::cloud::proto::AddRangefinderDataRequest>(Arena*);
template<> ::cartographer::cloud::proto::AddSensorDataBatchRequest* Arena::CreateMaybeMessage<::cartographer::cloud::proto::AddSensorDataBatchRequest>(Arena*);
template<> ::cartographer::cloud::proto::AddTrajectoryRequest* Arena::CreateMaybeMessage<::cartographer::cloud::proto::AddTrajectoryRequest>(Arena*);
template<> ::cartographer::cloud::proto::AddTrajectoryResponse* Arena::CreateMaybeMessage<::cartographer::cloud::proto::AddTrajectoryResponse>(Arena*);
template<> ::cartographer::cloud::proto::DeleteTrajectoryRequest* Arena::CreateMaybeMessage<::cartographer::cloud::proto::DeleteTrajectoryRequest>(Arena*);
template<> ::cartographer::cloud::proto::FinishTrajectoryRequest* Arena::CreateMaybeMessage<::cartographer::cloud::proto::FinishTrajectoryRequest>(Arena*);
template<> ::cartographer::cloud::proto::GetAllSubmapPosesResponse* Arena::CreateMaybeMessage<::cartographer::cloud::proto::GetAllSubmapPosesResponse>(Arena*);
template<> ::cartographer::cloud::proto::GetConstraintsResponse* Arena::CreateMaybeMessage<::cartographer::cloud::proto::GetConstraintsResponse>(Arena*);
template<> ::cartographer::cloud::proto::GetLandmarkPosesResponse* Arena::CreateMaybeMessage<::cartographer::cloud::proto::GetLandmarkPosesResponse>(Arena*);
template<> ::cartographer::cloud::proto::GetLocalToGlobalTransformRequest* Arena::CreateMaybeMessage<::cartographer::cloud::proto::GetLocalToGlobalTransformRequest>(Arena*);
template<> ::cartographer::cloud::proto::GetLocalToGlobalTransformResponse* Arena::CreateMaybeMessage<::cartographer::cloud::proto::GetLocalToGlobalTransformResponse>(Arena*);
template<> ::cartographer::cloud::proto::GetSubmapRequest* Arena::CreateMaybeMessage<::cartographer::cloud::proto::GetSubmapRequest>(Arena*);
template<> ::cartographer::cloud::proto::GetSubmapResponse* Arena::CreateMaybeMessage<::cartographer::cloud::proto::GetSubmapResponse>(Arena*);
template<> ::cartographer::cloud::proto::GetTrajectoryNodePosesResponse* Arena::CreateMaybeMessage<::cartographer::cloud::proto::GetTrajectoryNodePosesResponse>(Arena*);
template<> ::cartographer::cloud::proto::GetTrajectoryStatesResponse* Arena::CreateMaybeMessage<::cartographer::cloud::proto::GetTrajectoryStatesResponse>(Arena*);
template<> ::cartographer::cloud::proto::GetTrajectoryStatesResponse_TrajectoriesStateEntry_DoNotUse* Arena::CreateMaybeMessage<::cartographer::cloud::proto::GetTrajectoryStatesResponse_TrajectoriesStateEntry_DoNotUse>(Arena*);
template<> ::cartographer::cloud::proto::IsTrajectoryFinishedRequest* Arena::CreateMaybeMessage<::cartographer::cloud::proto::IsTrajectoryFinishedRequest>(Arena*);
template<> ::cartographer::cloud::proto::IsTrajectoryFinishedResponse* Arena::CreateMaybeMessage<::cartographer::cloud::proto::IsTrajectoryFinishedResponse>(Arena*);
template<> ::cartographer::cloud::proto::IsTrajectoryFrozenRequest* Arena::CreateMaybeMessage<::cartographer::cloud::proto::IsTrajectoryFrozenRequest>(Arena*);
template<> ::cartographer::cloud::proto::IsTrajectoryFrozenResponse* Arena::CreateMaybeMessage<::cartographer::cloud::proto::IsTrajectoryFrozenResponse>(Arena*);
template<> ::cartographer::cloud::proto::LoadStateFromFileRequest* Arena::CreateMaybeMessage<::cartographer::cloud::proto::LoadStateFromFileRequest>(Arena*);
template<> ::cartographer::cloud::proto::LoadStateFromFileResponse* Arena::CreateMaybeMessage<::cartographer::cloud::proto::LoadStateFromFileResponse>(Arena*);
template<> ::cartographer::cloud::proto::LoadStateRequest* Arena::CreateMaybeMessage<::cartographer::cloud::proto::LoadStateRequest>(Arena*);
template<> ::cartographer::cloud::proto::LoadStateResponse* Arena::CreateMaybeMessage<::cartographer::cloud::proto::LoadStateResponse>(Arena*);
template<> ::cartographer::cloud::proto::LocalSlamInsertionResult* Arena::CreateMaybeMessage<::cartographer::cloud::proto::LocalSlamInsertionResult>(Arena*);
template<> ::cartographer::cloud::proto::OKagv_FinishTrajectoryResponse* Arena::CreateMaybeMessage<::cartographer::cloud::proto::OKagv_FinishTrajectoryResponse>(Arena*);
template<> ::cartographer::cloud::proto::OKagv_GetOrderResponse* Arena::CreateMaybeMessage<::cartographer::cloud::proto::OKagv_GetOrderResponse>(Arena*);
template<> ::cartographer::cloud::proto::OKagv_GetTrajectoryStateResponse* Arena::CreateMaybeMessage<::cartographer::cloud::proto::OKagv_GetTrajectoryStateResponse>(Arena*);
template<> ::cartographer::cloud::proto::OKagv_LoadTrajectoryRequest* Arena::CreateMaybeMessage<::cartographer::cloud::proto::OKagv_LoadTrajectoryRequest>(Arena*);
template<> ::cartographer::cloud::proto::OKagv_LoadTrajectoryResponse* Arena::CreateMaybeMessage<::cartographer::cloud::proto::OKagv_LoadTrajectoryResponse>(Arena*);
template<> ::cartographer::cloud::proto::OKagv_LocalizeTrajectoryRequest* Arena::CreateMaybeMessage<::cartographer::cloud::proto::OKagv_LocalizeTrajectoryRequest>(Arena*);
template<> ::cartographer::cloud::proto::OKagv_LocalizeTrajectoryResponse* Arena::CreateMaybeMessage<::cartographer::cloud::proto::OKagv_LocalizeTrajectoryResponse>(Arena*);
template<> ::cartographer::cloud::proto::OKagv_SaveTrajectoryRequest* Arena::CreateMaybeMessage<::cartographer::cloud::proto::OKagv_SaveTrajectoryRequest>(Arena*);
template<> ::cartographer::cloud::proto::OKagv_StartTrajectoryRequest* Arena::CreateMaybeMessage<::cartographer::cloud::proto::OKagv_StartTrajectoryRequest>(Arena*);
template<> ::cartographer::cloud::proto::OKagv_StartTrajectoryResponse* Arena::CreateMaybeMessage<::cartographer::cloud::proto::OKagv_StartTrajectoryResponse>(Arena*);
template<> ::cartographer::cloud::proto::OKagv_WaitTrajectoryResponse* Arena::CreateMaybeMessage<::cartographer::cloud::proto::OKagv_WaitTrajectoryResponse>(Arena*);
template<> ::cartographer::cloud::proto::ReceiveGlobalSlamOptimizationsResponse* Arena::CreateMaybeMessage<::cartographer::cloud::proto::ReceiveGlobalSlamOptimizationsResponse>(Arena*);
template<> ::cartographer::cloud::proto::ReceiveGlobalSlamOptimizationsResponse_LastOptimizedNodeIdsEntry_DoNotUse* Arena::CreateMaybeMessage<::cartographer::cloud::proto::ReceiveGlobalSlamOptimizationsResponse_LastOptimizedNodeIdsEntry_DoNotUse>(Arena*);
template<> ::cartographer::cloud::proto::ReceiveGlobalSlamOptimizationsResponse_LastOptimizedSubmapIdsEntry_DoNotUse* Arena::CreateMaybeMessage<::cartographer::cloud::proto::ReceiveGlobalSlamOptimizationsResponse_LastOptimizedSubmapIdsEntry_DoNotUse>(Arena*);
template<> ::cartographer::cloud::proto::ReceiveLocalSlamResultsRequest* Arena::CreateMaybeMessage<::cartographer::cloud::proto::ReceiveLocalSlamResultsRequest>(Arena*);
template<> ::cartographer::cloud::proto::ReceiveLocalSlamResultsResponse* Arena::CreateMaybeMessage<::cartographer::cloud::proto::ReceiveLocalSlamResultsResponse>(Arena*);
template<> ::cartographer::cloud::proto::SensorData* Arena::CreateMaybeMessage<::cartographer::cloud::proto::SensorData>(Arena*);
template<> ::cartographer::cloud::proto::SensorId* Arena::CreateMaybeMessage<::cartographer::cloud::proto::SensorId>(Arena*);
template<> ::cartographer::cloud::proto::SensorMetadata* Arena::CreateMaybeMessage<::cartographer::cloud::proto::SensorMetadata>(Arena*);
template<> ::cartographer::cloud::proto::SetLandmarkPoseRequest* Arena::CreateMaybeMessage<::cartographer::cloud::proto::SetLandmarkPoseRequest>(Arena*);
template<> ::cartographer::cloud::proto::SubmapPose* Arena::CreateMaybeMessage<::cartographer::cloud::proto::SubmapPose>(Arena*);
template<> ::cartographer::cloud::proto::TrajectoryNodePose* Arena::CreateMaybeMessage<::cartographer::cloud::proto::TrajectoryNodePose>(Arena*);
template<> ::cartographer::cloud::proto::TrajectoryNodePose_ConstantPoseData* Arena::CreateMaybeMessage<::cartographer::cloud::proto::TrajectoryNodePose_ConstantPoseData>(Arena*);
template<> ::cartographer::cloud::proto::TrajectoryRemapping* Arena::CreateMaybeMessage<::cartographer::cloud::proto::TrajectoryRemapping>(Arena*);
template<> ::cartographer::cloud::proto::TrajectoryRemapping_SerializedTrajectoriesToTrajectoriesEntry_DoNotUse* Arena::CreateMaybeMessage<::cartographer::cloud::proto::TrajectoryRemapping_SerializedTrajectoriesToTrajectoriesEntry_DoNotUse>(Arena*);
template<> ::cartographer::cloud::proto::WriteStateResponse* Arena::CreateMaybeMessage<::cartographer::cloud::proto::WriteStateResponse>(Arena*);
template<> ::cartographer::cloud::proto::WriteStateToFileRequest* Arena::CreateMaybeMessage<::cartographer::cloud::proto::WriteStateToFileRequest>(Arena*);
template<> ::cartographer::cloud::proto::WriteStateToFileResponse* Arena::CreateMaybeMessage<::cartographer::cloud::proto::WriteStateToFileResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace cartographer {
namespace cloud {
namespace proto {

enum SensorType : int {
  RANGE = 0,
  IMU = 1,
  ODOMETRY = 2,
  FIXED_FRAME_POSE = 3,
  LANDMARK = 4,
  LOCAL_SLAM_RESULT = 5,
  SensorType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  SensorType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool SensorType_IsValid(int value);
constexpr SensorType SensorType_MIN = RANGE;
constexpr SensorType SensorType_MAX = LOCAL_SLAM_RESULT;
constexpr int SensorType_ARRAYSIZE = SensorType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SensorType_descriptor();
template<typename T>
inline const std::string& SensorType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SensorType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SensorType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SensorType_descriptor(), enum_t_value);
}
inline bool SensorType_Parse(
    const std::string& name, SensorType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SensorType>(
    SensorType_descriptor(), name, value);
}
enum TrajectoryState : int {
  ACTIVE = 0,
  FINISHED = 1,
  FROZEN = 2,
  DELETED = 3,
  TrajectoryState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  TrajectoryState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool TrajectoryState_IsValid(int value);
constexpr TrajectoryState TrajectoryState_MIN = ACTIVE;
constexpr TrajectoryState TrajectoryState_MAX = DELETED;
constexpr int TrajectoryState_ARRAYSIZE = TrajectoryState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TrajectoryState_descriptor();
template<typename T>
inline const std::string& TrajectoryState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TrajectoryState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TrajectoryState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TrajectoryState_descriptor(), enum_t_value);
}
inline bool TrajectoryState_Parse(
    const std::string& name, TrajectoryState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TrajectoryState>(
    TrajectoryState_descriptor(), name, value);
}
// ===================================================================

class SensorId :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cartographer.cloud.proto.SensorId) */ {
 public:
  SensorId();
  virtual ~SensorId();

  SensorId(const SensorId& from);
  SensorId(SensorId&& from) noexcept
    : SensorId() {
    *this = ::std::move(from);
  }

  inline SensorId& operator=(const SensorId& from) {
    CopyFrom(from);
    return *this;
  }
  inline SensorId& operator=(SensorId&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SensorId& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SensorId* internal_default_instance() {
    return reinterpret_cast<const SensorId*>(
               &_SensorId_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(SensorId& a, SensorId& b) {
    a.Swap(&b);
  }
  inline void Swap(SensorId* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SensorId* New() const final {
    return CreateMaybeMessage<SensorId>(nullptr);
  }

  SensorId* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SensorId>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SensorId& from);
  void MergeFrom(const SensorId& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SensorId* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cartographer.cloud.proto.SensorId";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto);
    return ::descriptor_table_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kTypeFieldNumber = 2,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  void set_id(const std::string& value);
  void set_id(std::string&& value);
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  std::string* mutable_id();
  std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // .cartographer.cloud.proto.SensorType type = 2;
  void clear_type();
  ::cartographer::cloud::proto::SensorType type() const;
  void set_type(::cartographer::cloud::proto::SensorType value);
  private:
  ::cartographer::cloud::proto::SensorType _internal_type() const;
  void _internal_set_type(::cartographer::cloud::proto::SensorType value);
  public:

  // @@protoc_insertion_point(class_scope:cartographer.cloud.proto.SensorId)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  int type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto;
};
// -------------------------------------------------------------------

class AddTrajectoryRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cartographer.cloud.proto.AddTrajectoryRequest) */ {
 public:
  AddTrajectoryRequest();
  virtual ~AddTrajectoryRequest();

  AddTrajectoryRequest(const AddTrajectoryRequest& from);
  AddTrajectoryRequest(AddTrajectoryRequest&& from) noexcept
    : AddTrajectoryRequest() {
    *this = ::std::move(from);
  }

  inline AddTrajectoryRequest& operator=(const AddTrajectoryRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddTrajectoryRequest& operator=(AddTrajectoryRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AddTrajectoryRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AddTrajectoryRequest* internal_default_instance() {
    return reinterpret_cast<const AddTrajectoryRequest*>(
               &_AddTrajectoryRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(AddTrajectoryRequest& a, AddTrajectoryRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AddTrajectoryRequest* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AddTrajectoryRequest* New() const final {
    return CreateMaybeMessage<AddTrajectoryRequest>(nullptr);
  }

  AddTrajectoryRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AddTrajectoryRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AddTrajectoryRequest& from);
  void MergeFrom(const AddTrajectoryRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddTrajectoryRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cartographer.cloud.proto.AddTrajectoryRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto);
    return ::descriptor_table_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kExpectedSensorIdsFieldNumber = 3,
    kClientIdFieldNumber = 4,
    kTrajectoryBuilderOptionsFieldNumber = 2,
  };
  // repeated .cartographer.cloud.proto.SensorId expected_sensor_ids = 3;
  int expected_sensor_ids_size() const;
  private:
  int _internal_expected_sensor_ids_size() const;
  public:
  void clear_expected_sensor_ids();
  ::cartographer::cloud::proto::SensorId* mutable_expected_sensor_ids(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cartographer::cloud::proto::SensorId >*
      mutable_expected_sensor_ids();
  private:
  const ::cartographer::cloud::proto::SensorId& _internal_expected_sensor_ids(int index) const;
  ::cartographer::cloud::proto::SensorId* _internal_add_expected_sensor_ids();
  public:
  const ::cartographer::cloud::proto::SensorId& expected_sensor_ids(int index) const;
  ::cartographer::cloud::proto::SensorId* add_expected_sensor_ids();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cartographer::cloud::proto::SensorId >&
      expected_sensor_ids() const;

  // string client_id = 4;
  void clear_client_id();
  const std::string& client_id() const;
  void set_client_id(const std::string& value);
  void set_client_id(std::string&& value);
  void set_client_id(const char* value);
  void set_client_id(const char* value, size_t size);
  std::string* mutable_client_id();
  std::string* release_client_id();
  void set_allocated_client_id(std::string* client_id);
  private:
  const std::string& _internal_client_id() const;
  void _internal_set_client_id(const std::string& value);
  std::string* _internal_mutable_client_id();
  public:

  // .cartographer.mapping.proto.TrajectoryBuilderOptions trajectory_builder_options = 2;
  bool has_trajectory_builder_options() const;
  private:
  bool _internal_has_trajectory_builder_options() const;
  public:
  void clear_trajectory_builder_options();
  const ::cartographer::mapping::proto::TrajectoryBuilderOptions& trajectory_builder_options() const;
  ::cartographer::mapping::proto::TrajectoryBuilderOptions* release_trajectory_builder_options();
  ::cartographer::mapping::proto::TrajectoryBuilderOptions* mutable_trajectory_builder_options();
  void set_allocated_trajectory_builder_options(::cartographer::mapping::proto::TrajectoryBuilderOptions* trajectory_builder_options);
  private:
  const ::cartographer::mapping::proto::TrajectoryBuilderOptions& _internal_trajectory_builder_options() const;
  ::cartographer::mapping::proto::TrajectoryBuilderOptions* _internal_mutable_trajectory_builder_options();
  public:

  // @@protoc_insertion_point(class_scope:cartographer.cloud.proto.AddTrajectoryRequest)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cartographer::cloud::proto::SensorId > expected_sensor_ids_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr client_id_;
  ::cartographer::mapping::proto::TrajectoryBuilderOptions* trajectory_builder_options_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto;
};
// -------------------------------------------------------------------

class SensorMetadata :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cartographer.cloud.proto.SensorMetadata) */ {
 public:
  SensorMetadata();
  virtual ~SensorMetadata();

  SensorMetadata(const SensorMetadata& from);
  SensorMetadata(SensorMetadata&& from) noexcept
    : SensorMetadata() {
    *this = ::std::move(from);
  }

  inline SensorMetadata& operator=(const SensorMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline SensorMetadata& operator=(SensorMetadata&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SensorMetadata& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SensorMetadata* internal_default_instance() {
    return reinterpret_cast<const SensorMetadata*>(
               &_SensorMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(SensorMetadata& a, SensorMetadata& b) {
    a.Swap(&b);
  }
  inline void Swap(SensorMetadata* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SensorMetadata* New() const final {
    return CreateMaybeMessage<SensorMetadata>(nullptr);
  }

  SensorMetadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SensorMetadata>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SensorMetadata& from);
  void MergeFrom(const SensorMetadata& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SensorMetadata* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cartographer.cloud.proto.SensorMetadata";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto);
    return ::descriptor_table_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSensorIdFieldNumber = 2,
    kClientIdFieldNumber = 3,
    kTrajectoryIdFieldNumber = 1,
  };
  // string sensor_id = 2;
  void clear_sensor_id();
  const std::string& sensor_id() const;
  void set_sensor_id(const std::string& value);
  void set_sensor_id(std::string&& value);
  void set_sensor_id(const char* value);
  void set_sensor_id(const char* value, size_t size);
  std::string* mutable_sensor_id();
  std::string* release_sensor_id();
  void set_allocated_sensor_id(std::string* sensor_id);
  private:
  const std::string& _internal_sensor_id() const;
  void _internal_set_sensor_id(const std::string& value);
  std::string* _internal_mutable_sensor_id();
  public:

  // string client_id = 3;
  void clear_client_id();
  const std::string& client_id() const;
  void set_client_id(const std::string& value);
  void set_client_id(std::string&& value);
  void set_client_id(const char* value);
  void set_client_id(const char* value, size_t size);
  std::string* mutable_client_id();
  std::string* release_client_id();
  void set_allocated_client_id(std::string* client_id);
  private:
  const std::string& _internal_client_id() const;
  void _internal_set_client_id(const std::string& value);
  std::string* _internal_mutable_client_id();
  public:

  // int32 trajectory_id = 1;
  void clear_trajectory_id();
  ::PROTOBUF_NAMESPACE_ID::int32 trajectory_id() const;
  void set_trajectory_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_trajectory_id() const;
  void _internal_set_trajectory_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:cartographer.cloud.proto.SensorMetadata)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sensor_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr client_id_;
  ::PROTOBUF_NAMESPACE_ID::int32 trajectory_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto;
};
// -------------------------------------------------------------------

class SensorData :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cartographer.cloud.proto.SensorData) */ {
 public:
  SensorData();
  virtual ~SensorData();

  SensorData(const SensorData& from);
  SensorData(SensorData&& from) noexcept
    : SensorData() {
    *this = ::std::move(from);
  }

  inline SensorData& operator=(const SensorData& from) {
    CopyFrom(from);
    return *this;
  }
  inline SensorData& operator=(SensorData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SensorData& default_instance();

  enum SensorDataCase {
    kOdometryData = 2,
    kImuData = 3,
    kTimedPointCloudData = 4,
    kFixedFramePoseData = 5,
    kLandmarkData = 6,
    kLocalSlamResultData = 7,
    SENSOR_DATA_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SensorData* internal_default_instance() {
    return reinterpret_cast<const SensorData*>(
               &_SensorData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(SensorData& a, SensorData& b) {
    a.Swap(&b);
  }
  inline void Swap(SensorData* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SensorData* New() const final {
    return CreateMaybeMessage<SensorData>(nullptr);
  }

  SensorData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SensorData>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SensorData& from);
  void MergeFrom(const SensorData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SensorData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cartographer.cloud.proto.SensorData";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto);
    return ::descriptor_table_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSensorMetadataFieldNumber = 1,
    kOdometryDataFieldNumber = 2,
    kImuDataFieldNumber = 3,
    kTimedPointCloudDataFieldNumber = 4,
    kFixedFramePoseDataFieldNumber = 5,
    kLandmarkDataFieldNumber = 6,
    kLocalSlamResultDataFieldNumber = 7,
  };
  // .cartographer.cloud.proto.SensorMetadata sensor_metadata = 1;
  bool has_sensor_metadata() const;
  private:
  bool _internal_has_sensor_metadata() const;
  public:
  void clear_sensor_metadata();
  const ::cartographer::cloud::proto::SensorMetadata& sensor_metadata() const;
  ::cartographer::cloud::proto::SensorMetadata* release_sensor_metadata();
  ::cartographer::cloud::proto::SensorMetadata* mutable_sensor_metadata();
  void set_allocated_sensor_metadata(::cartographer::cloud::proto::SensorMetadata* sensor_metadata);
  private:
  const ::cartographer::cloud::proto::SensorMetadata& _internal_sensor_metadata() const;
  ::cartographer::cloud::proto::SensorMetadata* _internal_mutable_sensor_metadata();
  public:

  // .cartographer.sensor.proto.OdometryData odometry_data = 2;
  bool has_odometry_data() const;
  private:
  bool _internal_has_odometry_data() const;
  public:
  void clear_odometry_data();
  const ::cartographer::sensor::proto::OdometryData& odometry_data() const;
  ::cartographer::sensor::proto::OdometryData* release_odometry_data();
  ::cartographer::sensor::proto::OdometryData* mutable_odometry_data();
  void set_allocated_odometry_data(::cartographer::sensor::proto::OdometryData* odometry_data);
  private:
  const ::cartographer::sensor::proto::OdometryData& _internal_odometry_data() const;
  ::cartographer::sensor::proto::OdometryData* _internal_mutable_odometry_data();
  public:

  // .cartographer.sensor.proto.ImuData imu_data = 3;
  bool has_imu_data() const;
  private:
  bool _internal_has_imu_data() const;
  public:
  void clear_imu_data();
  const ::cartographer::sensor::proto::ImuData& imu_data() const;
  ::cartographer::sensor::proto::ImuData* release_imu_data();
  ::cartographer::sensor::proto::ImuData* mutable_imu_data();
  void set_allocated_imu_data(::cartographer::sensor::proto::ImuData* imu_data);
  private:
  const ::cartographer::sensor::proto::ImuData& _internal_imu_data() const;
  ::cartographer::sensor::proto::ImuData* _internal_mutable_imu_data();
  public:

  // .cartographer.sensor.proto.TimedPointCloudData timed_point_cloud_data = 4;
  bool has_timed_point_cloud_data() const;
  private:
  bool _internal_has_timed_point_cloud_data() const;
  public:
  void clear_timed_point_cloud_data();
  const ::cartographer::sensor::proto::TimedPointCloudData& timed_point_cloud_data() const;
  ::cartographer::sensor::proto::TimedPointCloudData* release_timed_point_cloud_data();
  ::cartographer::sensor::proto::TimedPointCloudData* mutable_timed_point_cloud_data();
  void set_allocated_timed_point_cloud_data(::cartographer::sensor::proto::TimedPointCloudData* timed_point_cloud_data);
  private:
  const ::cartographer::sensor::proto::TimedPointCloudData& _internal_timed_point_cloud_data() const;
  ::cartographer::sensor::proto::TimedPointCloudData* _internal_mutable_timed_point_cloud_data();
  public:

  // .cartographer.sensor.proto.FixedFramePoseData fixed_frame_pose_data = 5;
  bool has_fixed_frame_pose_data() const;
  private:
  bool _internal_has_fixed_frame_pose_data() const;
  public:
  void clear_fixed_frame_pose_data();
  const ::cartographer::sensor::proto::FixedFramePoseData& fixed_frame_pose_data() const;
  ::cartographer::sensor::proto::FixedFramePoseData* release_fixed_frame_pose_data();
  ::cartographer::sensor::proto::FixedFramePoseData* mutable_fixed_frame_pose_data();
  void set_allocated_fixed_frame_pose_data(::cartographer::sensor::proto::FixedFramePoseData* fixed_frame_pose_data);
  private:
  const ::cartographer::sensor::proto::FixedFramePoseData& _internal_fixed_frame_pose_data() const;
  ::cartographer::sensor::proto::FixedFramePoseData* _internal_mutable_fixed_frame_pose_data();
  public:

  // .cartographer.sensor.proto.LandmarkData landmark_data = 6;
  bool has_landmark_data() const;
  private:
  bool _internal_has_landmark_data() const;
  public:
  void clear_landmark_data();
  const ::cartographer::sensor::proto::LandmarkData& landmark_data() const;
  ::cartographer::sensor::proto::LandmarkData* release_landmark_data();
  ::cartographer::sensor::proto::LandmarkData* mutable_landmark_data();
  void set_allocated_landmark_data(::cartographer::sensor::proto::LandmarkData* landmark_data);
  private:
  const ::cartographer::sensor::proto::LandmarkData& _internal_landmark_data() const;
  ::cartographer::sensor::proto::LandmarkData* _internal_mutable_landmark_data();
  public:

  // .cartographer.mapping.proto.LocalSlamResultData local_slam_result_data = 7;
  bool has_local_slam_result_data() const;
  private:
  bool _internal_has_local_slam_result_data() const;
  public:
  void clear_local_slam_result_data();
  const ::cartographer::mapping::proto::LocalSlamResultData& local_slam_result_data() const;
  ::cartographer::mapping::proto::LocalSlamResultData* release_local_slam_result_data();
  ::cartographer::mapping::proto::LocalSlamResultData* mutable_local_slam_result_data();
  void set_allocated_local_slam_result_data(::cartographer::mapping::proto::LocalSlamResultData* local_slam_result_data);
  private:
  const ::cartographer::mapping::proto::LocalSlamResultData& _internal_local_slam_result_data() const;
  ::cartographer::mapping::proto::LocalSlamResultData* _internal_mutable_local_slam_result_data();
  public:

  void clear_sensor_data();
  SensorDataCase sensor_data_case() const;
  // @@protoc_insertion_point(class_scope:cartographer.cloud.proto.SensorData)
 private:
  class _Internal;
  void set_has_odometry_data();
  void set_has_imu_data();
  void set_has_timed_point_cloud_data();
  void set_has_fixed_frame_pose_data();
  void set_has_landmark_data();
  void set_has_local_slam_result_data();

  inline bool has_sensor_data() const;
  inline void clear_has_sensor_data();

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::cartographer::cloud::proto::SensorMetadata* sensor_metadata_;
  union SensorDataUnion {
    SensorDataUnion() {}
    ::cartographer::sensor::proto::OdometryData* odometry_data_;
    ::cartographer::sensor::proto::ImuData* imu_data_;
    ::cartographer::sensor::proto::TimedPointCloudData* timed_point_cloud_data_;
    ::cartographer::sensor::proto::FixedFramePoseData* fixed_frame_pose_data_;
    ::cartographer::sensor::proto::LandmarkData* landmark_data_;
    ::cartographer::mapping::proto::LocalSlamResultData* local_slam_result_data_;
  } sensor_data_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto;
};
// -------------------------------------------------------------------

class AddTrajectoryResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cartographer.cloud.proto.AddTrajectoryResponse) */ {
 public:
  AddTrajectoryResponse();
  virtual ~AddTrajectoryResponse();

  AddTrajectoryResponse(const AddTrajectoryResponse& from);
  AddTrajectoryResponse(AddTrajectoryResponse&& from) noexcept
    : AddTrajectoryResponse() {
    *this = ::std::move(from);
  }

  inline AddTrajectoryResponse& operator=(const AddTrajectoryResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddTrajectoryResponse& operator=(AddTrajectoryResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AddTrajectoryResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AddTrajectoryResponse* internal_default_instance() {
    return reinterpret_cast<const AddTrajectoryResponse*>(
               &_AddTrajectoryResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(AddTrajectoryResponse& a, AddTrajectoryResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(AddTrajectoryResponse* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AddTrajectoryResponse* New() const final {
    return CreateMaybeMessage<AddTrajectoryResponse>(nullptr);
  }

  AddTrajectoryResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AddTrajectoryResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AddTrajectoryResponse& from);
  void MergeFrom(const AddTrajectoryResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddTrajectoryResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cartographer.cloud.proto.AddTrajectoryResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto);
    return ::descriptor_table_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTrajectoryIdFieldNumber = 1,
  };
  // int32 trajectory_id = 1;
  void clear_trajectory_id();
  ::PROTOBUF_NAMESPACE_ID::int32 trajectory_id() const;
  void set_trajectory_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_trajectory_id() const;
  void _internal_set_trajectory_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:cartographer.cloud.proto.AddTrajectoryResponse)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::int32 trajectory_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto;
};
// -------------------------------------------------------------------

class AddSensorDataBatchRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cartographer.cloud.proto.AddSensorDataBatchRequest) */ {
 public:
  AddSensorDataBatchRequest();
  virtual ~AddSensorDataBatchRequest();

  AddSensorDataBatchRequest(const AddSensorDataBatchRequest& from);
  AddSensorDataBatchRequest(AddSensorDataBatchRequest&& from) noexcept
    : AddSensorDataBatchRequest() {
    *this = ::std::move(from);
  }

  inline AddSensorDataBatchRequest& operator=(const AddSensorDataBatchRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddSensorDataBatchRequest& operator=(AddSensorDataBatchRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AddSensorDataBatchRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AddSensorDataBatchRequest* internal_default_instance() {
    return reinterpret_cast<const AddSensorDataBatchRequest*>(
               &_AddSensorDataBatchRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(AddSensorDataBatchRequest& a, AddSensorDataBatchRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AddSensorDataBatchRequest* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AddSensorDataBatchRequest* New() const final {
    return CreateMaybeMessage<AddSensorDataBatchRequest>(nullptr);
  }

  AddSensorDataBatchRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AddSensorDataBatchRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AddSensorDataBatchRequest& from);
  void MergeFrom(const AddSensorDataBatchRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddSensorDataBatchRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cartographer.cloud.proto.AddSensorDataBatchRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto);
    return ::descriptor_table_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSensorDataFieldNumber = 1,
  };
  // repeated .cartographer.cloud.proto.SensorData sensor_data = 1;
  int sensor_data_size() const;
  private:
  int _internal_sensor_data_size() const;
  public:
  void clear_sensor_data();
  ::cartographer::cloud::proto::SensorData* mutable_sensor_data(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cartographer::cloud::proto::SensorData >*
      mutable_sensor_data();
  private:
  const ::cartographer::cloud::proto::SensorData& _internal_sensor_data(int index) const;
  ::cartographer::cloud::proto::SensorData* _internal_add_sensor_data();
  public:
  const ::cartographer::cloud::proto::SensorData& sensor_data(int index) const;
  ::cartographer::cloud::proto::SensorData* add_sensor_data();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cartographer::cloud::proto::SensorData >&
      sensor_data() const;

  // @@protoc_insertion_point(class_scope:cartographer.cloud.proto.AddSensorDataBatchRequest)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cartographer::cloud::proto::SensorData > sensor_data_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto;
};
// -------------------------------------------------------------------

class AddOdometryDataRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cartographer.cloud.proto.AddOdometryDataRequest) */ {
 public:
  AddOdometryDataRequest();
  virtual ~AddOdometryDataRequest();

  AddOdometryDataRequest(const AddOdometryDataRequest& from);
  AddOdometryDataRequest(AddOdometryDataRequest&& from) noexcept
    : AddOdometryDataRequest() {
    *this = ::std::move(from);
  }

  inline AddOdometryDataRequest& operator=(const AddOdometryDataRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddOdometryDataRequest& operator=(AddOdometryDataRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AddOdometryDataRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AddOdometryDataRequest* internal_default_instance() {
    return reinterpret_cast<const AddOdometryDataRequest*>(
               &_AddOdometryDataRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(AddOdometryDataRequest& a, AddOdometryDataRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AddOdometryDataRequest* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AddOdometryDataRequest* New() const final {
    return CreateMaybeMessage<AddOdometryDataRequest>(nullptr);
  }

  AddOdometryDataRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AddOdometryDataRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AddOdometryDataRequest& from);
  void MergeFrom(const AddOdometryDataRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddOdometryDataRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cartographer.cloud.proto.AddOdometryDataRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto);
    return ::descriptor_table_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSensorMetadataFieldNumber = 1,
    kOdometryDataFieldNumber = 2,
  };
  // .cartographer.cloud.proto.SensorMetadata sensor_metadata = 1;
  bool has_sensor_metadata() const;
  private:
  bool _internal_has_sensor_metadata() const;
  public:
  void clear_sensor_metadata();
  const ::cartographer::cloud::proto::SensorMetadata& sensor_metadata() const;
  ::cartographer::cloud::proto::SensorMetadata* release_sensor_metadata();
  ::cartographer::cloud::proto::SensorMetadata* mutable_sensor_metadata();
  void set_allocated_sensor_metadata(::cartographer::cloud::proto::SensorMetadata* sensor_metadata);
  private:
  const ::cartographer::cloud::proto::SensorMetadata& _internal_sensor_metadata() const;
  ::cartographer::cloud::proto::SensorMetadata* _internal_mutable_sensor_metadata();
  public:

  // .cartographer.sensor.proto.OdometryData odometry_data = 2;
  bool has_odometry_data() const;
  private:
  bool _internal_has_odometry_data() const;
  public:
  void clear_odometry_data();
  const ::cartographer::sensor::proto::OdometryData& odometry_data() const;
  ::cartographer::sensor::proto::OdometryData* release_odometry_data();
  ::cartographer::sensor::proto::OdometryData* mutable_odometry_data();
  void set_allocated_odometry_data(::cartographer::sensor::proto::OdometryData* odometry_data);
  private:
  const ::cartographer::sensor::proto::OdometryData& _internal_odometry_data() const;
  ::cartographer::sensor::proto::OdometryData* _internal_mutable_odometry_data();
  public:

  // @@protoc_insertion_point(class_scope:cartographer.cloud.proto.AddOdometryDataRequest)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::cartographer::cloud::proto::SensorMetadata* sensor_metadata_;
  ::cartographer::sensor::proto::OdometryData* odometry_data_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto;
};
// -------------------------------------------------------------------

class AddImuDataRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cartographer.cloud.proto.AddImuDataRequest) */ {
 public:
  AddImuDataRequest();
  virtual ~AddImuDataRequest();

  AddImuDataRequest(const AddImuDataRequest& from);
  AddImuDataRequest(AddImuDataRequest&& from) noexcept
    : AddImuDataRequest() {
    *this = ::std::move(from);
  }

  inline AddImuDataRequest& operator=(const AddImuDataRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddImuDataRequest& operator=(AddImuDataRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AddImuDataRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AddImuDataRequest* internal_default_instance() {
    return reinterpret_cast<const AddImuDataRequest*>(
               &_AddImuDataRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(AddImuDataRequest& a, AddImuDataRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AddImuDataRequest* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AddImuDataRequest* New() const final {
    return CreateMaybeMessage<AddImuDataRequest>(nullptr);
  }

  AddImuDataRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AddImuDataRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AddImuDataRequest& from);
  void MergeFrom(const AddImuDataRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddImuDataRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cartographer.cloud.proto.AddImuDataRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto);
    return ::descriptor_table_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSensorMetadataFieldNumber = 1,
    kImuDataFieldNumber = 2,
  };
  // .cartographer.cloud.proto.SensorMetadata sensor_metadata = 1;
  bool has_sensor_metadata() const;
  private:
  bool _internal_has_sensor_metadata() const;
  public:
  void clear_sensor_metadata();
  const ::cartographer::cloud::proto::SensorMetadata& sensor_metadata() const;
  ::cartographer::cloud::proto::SensorMetadata* release_sensor_metadata();
  ::cartographer::cloud::proto::SensorMetadata* mutable_sensor_metadata();
  void set_allocated_sensor_metadata(::cartographer::cloud::proto::SensorMetadata* sensor_metadata);
  private:
  const ::cartographer::cloud::proto::SensorMetadata& _internal_sensor_metadata() const;
  ::cartographer::cloud::proto::SensorMetadata* _internal_mutable_sensor_metadata();
  public:

  // .cartographer.sensor.proto.ImuData imu_data = 2;
  bool has_imu_data() const;
  private:
  bool _internal_has_imu_data() const;
  public:
  void clear_imu_data();
  const ::cartographer::sensor::proto::ImuData& imu_data() const;
  ::cartographer::sensor::proto::ImuData* release_imu_data();
  ::cartographer::sensor::proto::ImuData* mutable_imu_data();
  void set_allocated_imu_data(::cartographer::sensor::proto::ImuData* imu_data);
  private:
  const ::cartographer::sensor::proto::ImuData& _internal_imu_data() const;
  ::cartographer::sensor::proto::ImuData* _internal_mutable_imu_data();
  public:

  // @@protoc_insertion_point(class_scope:cartographer.cloud.proto.AddImuDataRequest)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::cartographer::cloud::proto::SensorMetadata* sensor_metadata_;
  ::cartographer::sensor::proto::ImuData* imu_data_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto;
};
// -------------------------------------------------------------------

class AddRangefinderDataRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cartographer.cloud.proto.AddRangefinderDataRequest) */ {
 public:
  AddRangefinderDataRequest();
  virtual ~AddRangefinderDataRequest();

  AddRangefinderDataRequest(const AddRangefinderDataRequest& from);
  AddRangefinderDataRequest(AddRangefinderDataRequest&& from) noexcept
    : AddRangefinderDataRequest() {
    *this = ::std::move(from);
  }

  inline AddRangefinderDataRequest& operator=(const AddRangefinderDataRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddRangefinderDataRequest& operator=(AddRangefinderDataRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AddRangefinderDataRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AddRangefinderDataRequest* internal_default_instance() {
    return reinterpret_cast<const AddRangefinderDataRequest*>(
               &_AddRangefinderDataRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(AddRangefinderDataRequest& a, AddRangefinderDataRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AddRangefinderDataRequest* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AddRangefinderDataRequest* New() const final {
    return CreateMaybeMessage<AddRangefinderDataRequest>(nullptr);
  }

  AddRangefinderDataRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AddRangefinderDataRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AddRangefinderDataRequest& from);
  void MergeFrom(const AddRangefinderDataRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddRangefinderDataRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cartographer.cloud.proto.AddRangefinderDataRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto);
    return ::descriptor_table_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSensorMetadataFieldNumber = 1,
    kTimedPointCloudDataFieldNumber = 2,
  };
  // .cartographer.cloud.proto.SensorMetadata sensor_metadata = 1;
  bool has_sensor_metadata() const;
  private:
  bool _internal_has_sensor_metadata() const;
  public:
  void clear_sensor_metadata();
  const ::cartographer::cloud::proto::SensorMetadata& sensor_metadata() const;
  ::cartographer::cloud::proto::SensorMetadata* release_sensor_metadata();
  ::cartographer::cloud::proto::SensorMetadata* mutable_sensor_metadata();
  void set_allocated_sensor_metadata(::cartographer::cloud::proto::SensorMetadata* sensor_metadata);
  private:
  const ::cartographer::cloud::proto::SensorMetadata& _internal_sensor_metadata() const;
  ::cartographer::cloud::proto::SensorMetadata* _internal_mutable_sensor_metadata();
  public:

  // .cartographer.sensor.proto.TimedPointCloudData timed_point_cloud_data = 2;
  bool has_timed_point_cloud_data() const;
  private:
  bool _internal_has_timed_point_cloud_data() const;
  public:
  void clear_timed_point_cloud_data();
  const ::cartographer::sensor::proto::TimedPointCloudData& timed_point_cloud_data() const;
  ::cartographer::sensor::proto::TimedPointCloudData* release_timed_point_cloud_data();
  ::cartographer::sensor::proto::TimedPointCloudData* mutable_timed_point_cloud_data();
  void set_allocated_timed_point_cloud_data(::cartographer::sensor::proto::TimedPointCloudData* timed_point_cloud_data);
  private:
  const ::cartographer::sensor::proto::TimedPointCloudData& _internal_timed_point_cloud_data() const;
  ::cartographer::sensor::proto::TimedPointCloudData* _internal_mutable_timed_point_cloud_data();
  public:

  // @@protoc_insertion_point(class_scope:cartographer.cloud.proto.AddRangefinderDataRequest)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::cartographer::cloud::proto::SensorMetadata* sensor_metadata_;
  ::cartographer::sensor::proto::TimedPointCloudData* timed_point_cloud_data_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto;
};
// -------------------------------------------------------------------

class AddFixedFramePoseDataRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cartographer.cloud.proto.AddFixedFramePoseDataRequest) */ {
 public:
  AddFixedFramePoseDataRequest();
  virtual ~AddFixedFramePoseDataRequest();

  AddFixedFramePoseDataRequest(const AddFixedFramePoseDataRequest& from);
  AddFixedFramePoseDataRequest(AddFixedFramePoseDataRequest&& from) noexcept
    : AddFixedFramePoseDataRequest() {
    *this = ::std::move(from);
  }

  inline AddFixedFramePoseDataRequest& operator=(const AddFixedFramePoseDataRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddFixedFramePoseDataRequest& operator=(AddFixedFramePoseDataRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AddFixedFramePoseDataRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AddFixedFramePoseDataRequest* internal_default_instance() {
    return reinterpret_cast<const AddFixedFramePoseDataRequest*>(
               &_AddFixedFramePoseDataRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(AddFixedFramePoseDataRequest& a, AddFixedFramePoseDataRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AddFixedFramePoseDataRequest* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AddFixedFramePoseDataRequest* New() const final {
    return CreateMaybeMessage<AddFixedFramePoseDataRequest>(nullptr);
  }

  AddFixedFramePoseDataRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AddFixedFramePoseDataRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AddFixedFramePoseDataRequest& from);
  void MergeFrom(const AddFixedFramePoseDataRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddFixedFramePoseDataRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cartographer.cloud.proto.AddFixedFramePoseDataRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto);
    return ::descriptor_table_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSensorMetadataFieldNumber = 1,
    kFixedFramePoseDataFieldNumber = 2,
  };
  // .cartographer.cloud.proto.SensorMetadata sensor_metadata = 1;
  bool has_sensor_metadata() const;
  private:
  bool _internal_has_sensor_metadata() const;
  public:
  void clear_sensor_metadata();
  const ::cartographer::cloud::proto::SensorMetadata& sensor_metadata() const;
  ::cartographer::cloud::proto::SensorMetadata* release_sensor_metadata();
  ::cartographer::cloud::proto::SensorMetadata* mutable_sensor_metadata();
  void set_allocated_sensor_metadata(::cartographer::cloud::proto::SensorMetadata* sensor_metadata);
  private:
  const ::cartographer::cloud::proto::SensorMetadata& _internal_sensor_metadata() const;
  ::cartographer::cloud::proto::SensorMetadata* _internal_mutable_sensor_metadata();
  public:

  // .cartographer.sensor.proto.FixedFramePoseData fixed_frame_pose_data = 2;
  bool has_fixed_frame_pose_data() const;
  private:
  bool _internal_has_fixed_frame_pose_data() const;
  public:
  void clear_fixed_frame_pose_data();
  const ::cartographer::sensor::proto::FixedFramePoseData& fixed_frame_pose_data() const;
  ::cartographer::sensor::proto::FixedFramePoseData* release_fixed_frame_pose_data();
  ::cartographer::sensor::proto::FixedFramePoseData* mutable_fixed_frame_pose_data();
  void set_allocated_fixed_frame_pose_data(::cartographer::sensor::proto::FixedFramePoseData* fixed_frame_pose_data);
  private:
  const ::cartographer::sensor::proto::FixedFramePoseData& _internal_fixed_frame_pose_data() const;
  ::cartographer::sensor::proto::FixedFramePoseData* _internal_mutable_fixed_frame_pose_data();
  public:

  // @@protoc_insertion_point(class_scope:cartographer.cloud.proto.AddFixedFramePoseDataRequest)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::cartographer::cloud::proto::SensorMetadata* sensor_metadata_;
  ::cartographer::sensor::proto::FixedFramePoseData* fixed_frame_pose_data_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto;
};
// -------------------------------------------------------------------

class AddLandmarkDataRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cartographer.cloud.proto.AddLandmarkDataRequest) */ {
 public:
  AddLandmarkDataRequest();
  virtual ~AddLandmarkDataRequest();

  AddLandmarkDataRequest(const AddLandmarkDataRequest& from);
  AddLandmarkDataRequest(AddLandmarkDataRequest&& from) noexcept
    : AddLandmarkDataRequest() {
    *this = ::std::move(from);
  }

  inline AddLandmarkDataRequest& operator=(const AddLandmarkDataRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddLandmarkDataRequest& operator=(AddLandmarkDataRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AddLandmarkDataRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AddLandmarkDataRequest* internal_default_instance() {
    return reinterpret_cast<const AddLandmarkDataRequest*>(
               &_AddLandmarkDataRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(AddLandmarkDataRequest& a, AddLandmarkDataRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AddLandmarkDataRequest* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AddLandmarkDataRequest* New() const final {
    return CreateMaybeMessage<AddLandmarkDataRequest>(nullptr);
  }

  AddLandmarkDataRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AddLandmarkDataRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AddLandmarkDataRequest& from);
  void MergeFrom(const AddLandmarkDataRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddLandmarkDataRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cartographer.cloud.proto.AddLandmarkDataRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto);
    return ::descriptor_table_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSensorMetadataFieldNumber = 1,
    kLandmarkDataFieldNumber = 2,
  };
  // .cartographer.cloud.proto.SensorMetadata sensor_metadata = 1;
  bool has_sensor_metadata() const;
  private:
  bool _internal_has_sensor_metadata() const;
  public:
  void clear_sensor_metadata();
  const ::cartographer::cloud::proto::SensorMetadata& sensor_metadata() const;
  ::cartographer::cloud::proto::SensorMetadata* release_sensor_metadata();
  ::cartographer::cloud::proto::SensorMetadata* mutable_sensor_metadata();
  void set_allocated_sensor_metadata(::cartographer::cloud::proto::SensorMetadata* sensor_metadata);
  private:
  const ::cartographer::cloud::proto::SensorMetadata& _internal_sensor_metadata() const;
  ::cartographer::cloud::proto::SensorMetadata* _internal_mutable_sensor_metadata();
  public:

  // .cartographer.sensor.proto.LandmarkData landmark_data = 2;
  bool has_landmark_data() const;
  private:
  bool _internal_has_landmark_data() const;
  public:
  void clear_landmark_data();
  const ::cartographer::sensor::proto::LandmarkData& landmark_data() const;
  ::cartographer::sensor::proto::LandmarkData* release_landmark_data();
  ::cartographer::sensor::proto::LandmarkData* mutable_landmark_data();
  void set_allocated_landmark_data(::cartographer::sensor::proto::LandmarkData* landmark_data);
  private:
  const ::cartographer::sensor::proto::LandmarkData& _internal_landmark_data() const;
  ::cartographer::sensor::proto::LandmarkData* _internal_mutable_landmark_data();
  public:

  // @@protoc_insertion_point(class_scope:cartographer.cloud.proto.AddLandmarkDataRequest)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::cartographer::cloud::proto::SensorMetadata* sensor_metadata_;
  ::cartographer::sensor::proto::LandmarkData* landmark_data_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto;
};
// -------------------------------------------------------------------

class FinishTrajectoryRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cartographer.cloud.proto.FinishTrajectoryRequest) */ {
 public:
  FinishTrajectoryRequest();
  virtual ~FinishTrajectoryRequest();

  FinishTrajectoryRequest(const FinishTrajectoryRequest& from);
  FinishTrajectoryRequest(FinishTrajectoryRequest&& from) noexcept
    : FinishTrajectoryRequest() {
    *this = ::std::move(from);
  }

  inline FinishTrajectoryRequest& operator=(const FinishTrajectoryRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline FinishTrajectoryRequest& operator=(FinishTrajectoryRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const FinishTrajectoryRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FinishTrajectoryRequest* internal_default_instance() {
    return reinterpret_cast<const FinishTrajectoryRequest*>(
               &_FinishTrajectoryRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(FinishTrajectoryRequest& a, FinishTrajectoryRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(FinishTrajectoryRequest* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FinishTrajectoryRequest* New() const final {
    return CreateMaybeMessage<FinishTrajectoryRequest>(nullptr);
  }

  FinishTrajectoryRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FinishTrajectoryRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const FinishTrajectoryRequest& from);
  void MergeFrom(const FinishTrajectoryRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FinishTrajectoryRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cartographer.cloud.proto.FinishTrajectoryRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto);
    return ::descriptor_table_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientIdFieldNumber = 2,
    kTrajectoryIdFieldNumber = 1,
  };
  // string client_id = 2;
  void clear_client_id();
  const std::string& client_id() const;
  void set_client_id(const std::string& value);
  void set_client_id(std::string&& value);
  void set_client_id(const char* value);
  void set_client_id(const char* value, size_t size);
  std::string* mutable_client_id();
  std::string* release_client_id();
  void set_allocated_client_id(std::string* client_id);
  private:
  const std::string& _internal_client_id() const;
  void _internal_set_client_id(const std::string& value);
  std::string* _internal_mutable_client_id();
  public:

  // int32 trajectory_id = 1;
  void clear_trajectory_id();
  ::PROTOBUF_NAMESPACE_ID::int32 trajectory_id() const;
  void set_trajectory_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_trajectory_id() const;
  void _internal_set_trajectory_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:cartographer.cloud.proto.FinishTrajectoryRequest)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr client_id_;
  ::PROTOBUF_NAMESPACE_ID::int32 trajectory_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto;
};
// -------------------------------------------------------------------

class DeleteTrajectoryRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cartographer.cloud.proto.DeleteTrajectoryRequest) */ {
 public:
  DeleteTrajectoryRequest();
  virtual ~DeleteTrajectoryRequest();

  DeleteTrajectoryRequest(const DeleteTrajectoryRequest& from);
  DeleteTrajectoryRequest(DeleteTrajectoryRequest&& from) noexcept
    : DeleteTrajectoryRequest() {
    *this = ::std::move(from);
  }

  inline DeleteTrajectoryRequest& operator=(const DeleteTrajectoryRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteTrajectoryRequest& operator=(DeleteTrajectoryRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DeleteTrajectoryRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DeleteTrajectoryRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteTrajectoryRequest*>(
               &_DeleteTrajectoryRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(DeleteTrajectoryRequest& a, DeleteTrajectoryRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteTrajectoryRequest* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DeleteTrajectoryRequest* New() const final {
    return CreateMaybeMessage<DeleteTrajectoryRequest>(nullptr);
  }

  DeleteTrajectoryRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DeleteTrajectoryRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DeleteTrajectoryRequest& from);
  void MergeFrom(const DeleteTrajectoryRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteTrajectoryRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cartographer.cloud.proto.DeleteTrajectoryRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto);
    return ::descriptor_table_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientIdFieldNumber = 2,
    kTrajectoryIdFieldNumber = 1,
  };
  // string client_id = 2;
  void clear_client_id();
  const std::string& client_id() const;
  void set_client_id(const std::string& value);
  void set_client_id(std::string&& value);
  void set_client_id(const char* value);
  void set_client_id(const char* value, size_t size);
  std::string* mutable_client_id();
  std::string* release_client_id();
  void set_allocated_client_id(std::string* client_id);
  private:
  const std::string& _internal_client_id() const;
  void _internal_set_client_id(const std::string& value);
  std::string* _internal_mutable_client_id();
  public:

  // int32 trajectory_id = 1;
  void clear_trajectory_id();
  ::PROTOBUF_NAMESPACE_ID::int32 trajectory_id() const;
  void set_trajectory_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_trajectory_id() const;
  void _internal_set_trajectory_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:cartographer.cloud.proto.DeleteTrajectoryRequest)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr client_id_;
  ::PROTOBUF_NAMESPACE_ID::int32 trajectory_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto;
};
// -------------------------------------------------------------------

class ReceiveLocalSlamResultsRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cartographer.cloud.proto.ReceiveLocalSlamResultsRequest) */ {
 public:
  ReceiveLocalSlamResultsRequest();
  virtual ~ReceiveLocalSlamResultsRequest();

  ReceiveLocalSlamResultsRequest(const ReceiveLocalSlamResultsRequest& from);
  ReceiveLocalSlamResultsRequest(ReceiveLocalSlamResultsRequest&& from) noexcept
    : ReceiveLocalSlamResultsRequest() {
    *this = ::std::move(from);
  }

  inline ReceiveLocalSlamResultsRequest& operator=(const ReceiveLocalSlamResultsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReceiveLocalSlamResultsRequest& operator=(ReceiveLocalSlamResultsRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ReceiveLocalSlamResultsRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReceiveLocalSlamResultsRequest* internal_default_instance() {
    return reinterpret_cast<const ReceiveLocalSlamResultsRequest*>(
               &_ReceiveLocalSlamResultsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(ReceiveLocalSlamResultsRequest& a, ReceiveLocalSlamResultsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ReceiveLocalSlamResultsRequest* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ReceiveLocalSlamResultsRequest* New() const final {
    return CreateMaybeMessage<ReceiveLocalSlamResultsRequest>(nullptr);
  }

  ReceiveLocalSlamResultsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ReceiveLocalSlamResultsRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ReceiveLocalSlamResultsRequest& from);
  void MergeFrom(const ReceiveLocalSlamResultsRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReceiveLocalSlamResultsRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cartographer.cloud.proto.ReceiveLocalSlamResultsRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto);
    return ::descriptor_table_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTrajectoryIdFieldNumber = 1,
  };
  // int32 trajectory_id = 1;
  void clear_trajectory_id();
  ::PROTOBUF_NAMESPACE_ID::int32 trajectory_id() const;
  void set_trajectory_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_trajectory_id() const;
  void _internal_set_trajectory_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:cartographer.cloud.proto.ReceiveLocalSlamResultsRequest)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::int32 trajectory_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto;
};
// -------------------------------------------------------------------

class LocalSlamInsertionResult :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cartographer.cloud.proto.LocalSlamInsertionResult) */ {
 public:
  LocalSlamInsertionResult();
  virtual ~LocalSlamInsertionResult();

  LocalSlamInsertionResult(const LocalSlamInsertionResult& from);
  LocalSlamInsertionResult(LocalSlamInsertionResult&& from) noexcept
    : LocalSlamInsertionResult() {
    *this = ::std::move(from);
  }

  inline LocalSlamInsertionResult& operator=(const LocalSlamInsertionResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline LocalSlamInsertionResult& operator=(LocalSlamInsertionResult&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LocalSlamInsertionResult& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LocalSlamInsertionResult* internal_default_instance() {
    return reinterpret_cast<const LocalSlamInsertionResult*>(
               &_LocalSlamInsertionResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(LocalSlamInsertionResult& a, LocalSlamInsertionResult& b) {
    a.Swap(&b);
  }
  inline void Swap(LocalSlamInsertionResult* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LocalSlamInsertionResult* New() const final {
    return CreateMaybeMessage<LocalSlamInsertionResult>(nullptr);
  }

  LocalSlamInsertionResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LocalSlamInsertionResult>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LocalSlamInsertionResult& from);
  void MergeFrom(const LocalSlamInsertionResult& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LocalSlamInsertionResult* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cartographer.cloud.proto.LocalSlamInsertionResult";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto);
    return ::descriptor_table_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNodeIdFieldNumber = 1,
  };
  // .cartographer.mapping.proto.NodeId node_id = 1;
  bool has_node_id() const;
  private:
  bool _internal_has_node_id() const;
  public:
  void clear_node_id();
  const ::cartographer::mapping::proto::NodeId& node_id() const;
  ::cartographer::mapping::proto::NodeId* release_node_id();
  ::cartographer::mapping::proto::NodeId* mutable_node_id();
  void set_allocated_node_id(::cartographer::mapping::proto::NodeId* node_id);
  private:
  const ::cartographer::mapping::proto::NodeId& _internal_node_id() const;
  ::cartographer::mapping::proto::NodeId* _internal_mutable_node_id();
  public:

  // @@protoc_insertion_point(class_scope:cartographer.cloud.proto.LocalSlamInsertionResult)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::cartographer::mapping::proto::NodeId* node_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto;
};
// -------------------------------------------------------------------

class ReceiveLocalSlamResultsResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cartographer.cloud.proto.ReceiveLocalSlamResultsResponse) */ {
 public:
  ReceiveLocalSlamResultsResponse();
  virtual ~ReceiveLocalSlamResultsResponse();

  ReceiveLocalSlamResultsResponse(const ReceiveLocalSlamResultsResponse& from);
  ReceiveLocalSlamResultsResponse(ReceiveLocalSlamResultsResponse&& from) noexcept
    : ReceiveLocalSlamResultsResponse() {
    *this = ::std::move(from);
  }

  inline ReceiveLocalSlamResultsResponse& operator=(const ReceiveLocalSlamResultsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReceiveLocalSlamResultsResponse& operator=(ReceiveLocalSlamResultsResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ReceiveLocalSlamResultsResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReceiveLocalSlamResultsResponse* internal_default_instance() {
    return reinterpret_cast<const ReceiveLocalSlamResultsResponse*>(
               &_ReceiveLocalSlamResultsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(ReceiveLocalSlamResultsResponse& a, ReceiveLocalSlamResultsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ReceiveLocalSlamResultsResponse* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ReceiveLocalSlamResultsResponse* New() const final {
    return CreateMaybeMessage<ReceiveLocalSlamResultsResponse>(nullptr);
  }

  ReceiveLocalSlamResultsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ReceiveLocalSlamResultsResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ReceiveLocalSlamResultsResponse& from);
  void MergeFrom(const ReceiveLocalSlamResultsResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReceiveLocalSlamResultsResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cartographer.cloud.proto.ReceiveLocalSlamResultsResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto);
    return ::descriptor_table_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLocalPoseFieldNumber = 3,
    kRangeDataFieldNumber = 4,
    kInsertionResultFieldNumber = 5,
    kTimestampFieldNumber = 2,
    kTrajectoryIdFieldNumber = 1,
  };
  // .cartographer.transform.proto.Rigid3d local_pose = 3;
  bool has_local_pose() const;
  private:
  bool _internal_has_local_pose() const;
  public:
  void clear_local_pose();
  const ::cartographer::transform::proto::Rigid3d& local_pose() const;
  ::cartographer::transform::proto::Rigid3d* release_local_pose();
  ::cartographer::transform::proto::Rigid3d* mutable_local_pose();
  void set_allocated_local_pose(::cartographer::transform::proto::Rigid3d* local_pose);
  private:
  const ::cartographer::transform::proto::Rigid3d& _internal_local_pose() const;
  ::cartographer::transform::proto::Rigid3d* _internal_mutable_local_pose();
  public:

  // .cartographer.sensor.proto.RangeData range_data = 4;
  bool has_range_data() const;
  private:
  bool _internal_has_range_data() const;
  public:
  void clear_range_data();
  const ::cartographer::sensor::proto::RangeData& range_data() const;
  ::cartographer::sensor::proto::RangeData* release_range_data();
  ::cartographer::sensor::proto::RangeData* mutable_range_data();
  void set_allocated_range_data(::cartographer::sensor::proto::RangeData* range_data);
  private:
  const ::cartographer::sensor::proto::RangeData& _internal_range_data() const;
  ::cartographer::sensor::proto::RangeData* _internal_mutable_range_data();
  public:

  // .cartographer.cloud.proto.LocalSlamInsertionResult insertion_result = 5;
  bool has_insertion_result() const;
  private:
  bool _internal_has_insertion_result() const;
  public:
  void clear_insertion_result();
  const ::cartographer::cloud::proto::LocalSlamInsertionResult& insertion_result() const;
  ::cartographer::cloud::proto::LocalSlamInsertionResult* release_insertion_result();
  ::cartographer::cloud::proto::LocalSlamInsertionResult* mutable_insertion_result();
  void set_allocated_insertion_result(::cartographer::cloud::proto::LocalSlamInsertionResult* insertion_result);
  private:
  const ::cartographer::cloud::proto::LocalSlamInsertionResult& _internal_insertion_result() const;
  ::cartographer::cloud::proto::LocalSlamInsertionResult* _internal_mutable_insertion_result();
  public:

  // int64 timestamp = 2;
  void clear_timestamp();
  ::PROTOBUF_NAMESPACE_ID::int64 timestamp() const;
  void set_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_timestamp() const;
  void _internal_set_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int32 trajectory_id = 1;
  void clear_trajectory_id();
  ::PROTOBUF_NAMESPACE_ID::int32 trajectory_id() const;
  void set_trajectory_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_trajectory_id() const;
  void _internal_set_trajectory_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:cartographer.cloud.proto.ReceiveLocalSlamResultsResponse)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::cartographer::transform::proto::Rigid3d* local_pose_;
  ::cartographer::sensor::proto::RangeData* range_data_;
  ::cartographer::cloud::proto::LocalSlamInsertionResult* insertion_result_;
  ::PROTOBUF_NAMESPACE_ID::int64 timestamp_;
  ::PROTOBUF_NAMESPACE_ID::int32 trajectory_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto;
};
// -------------------------------------------------------------------

class ReceiveGlobalSlamOptimizationsResponse_LastOptimizedNodeIdsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ReceiveGlobalSlamOptimizationsResponse_LastOptimizedNodeIdsEntry_DoNotUse, 
    ::PROTOBUF_NAMESPACE_ID::int32, ::cartographer::mapping::proto::NodeId,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
    0 > {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ReceiveGlobalSlamOptimizationsResponse_LastOptimizedNodeIdsEntry_DoNotUse, 
    ::PROTOBUF_NAMESPACE_ID::int32, ::cartographer::mapping::proto::NodeId,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
    0 > SuperType;
  ReceiveGlobalSlamOptimizationsResponse_LastOptimizedNodeIdsEntry_DoNotUse();
  ReceiveGlobalSlamOptimizationsResponse_LastOptimizedNodeIdsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const ReceiveGlobalSlamOptimizationsResponse_LastOptimizedNodeIdsEntry_DoNotUse& other);
  static const ReceiveGlobalSlamOptimizationsResponse_LastOptimizedNodeIdsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ReceiveGlobalSlamOptimizationsResponse_LastOptimizedNodeIdsEntry_DoNotUse*>(&_ReceiveGlobalSlamOptimizationsResponse_LastOptimizedNodeIdsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto);
    return ::descriptor_table_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto.file_level_metadata[16];
  }

  public:
};

// -------------------------------------------------------------------

class ReceiveGlobalSlamOptimizationsResponse_LastOptimizedSubmapIdsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ReceiveGlobalSlamOptimizationsResponse_LastOptimizedSubmapIdsEntry_DoNotUse, 
    ::PROTOBUF_NAMESPACE_ID::int32, ::cartographer::mapping::proto::SubmapId,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
    0 > {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ReceiveGlobalSlamOptimizationsResponse_LastOptimizedSubmapIdsEntry_DoNotUse, 
    ::PROTOBUF_NAMESPACE_ID::int32, ::cartographer::mapping::proto::SubmapId,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
    0 > SuperType;
  ReceiveGlobalSlamOptimizationsResponse_LastOptimizedSubmapIdsEntry_DoNotUse();
  ReceiveGlobalSlamOptimizationsResponse_LastOptimizedSubmapIdsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const ReceiveGlobalSlamOptimizationsResponse_LastOptimizedSubmapIdsEntry_DoNotUse& other);
  static const ReceiveGlobalSlamOptimizationsResponse_LastOptimizedSubmapIdsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ReceiveGlobalSlamOptimizationsResponse_LastOptimizedSubmapIdsEntry_DoNotUse*>(&_ReceiveGlobalSlamOptimizationsResponse_LastOptimizedSubmapIdsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto);
    return ::descriptor_table_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto.file_level_metadata[17];
  }

  public:
};

// -------------------------------------------------------------------

class ReceiveGlobalSlamOptimizationsResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cartographer.cloud.proto.ReceiveGlobalSlamOptimizationsResponse) */ {
 public:
  ReceiveGlobalSlamOptimizationsResponse();
  virtual ~ReceiveGlobalSlamOptimizationsResponse();

  ReceiveGlobalSlamOptimizationsResponse(const ReceiveGlobalSlamOptimizationsResponse& from);
  ReceiveGlobalSlamOptimizationsResponse(ReceiveGlobalSlamOptimizationsResponse&& from) noexcept
    : ReceiveGlobalSlamOptimizationsResponse() {
    *this = ::std::move(from);
  }

  inline ReceiveGlobalSlamOptimizationsResponse& operator=(const ReceiveGlobalSlamOptimizationsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReceiveGlobalSlamOptimizationsResponse& operator=(ReceiveGlobalSlamOptimizationsResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ReceiveGlobalSlamOptimizationsResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReceiveGlobalSlamOptimizationsResponse* internal_default_instance() {
    return reinterpret_cast<const ReceiveGlobalSlamOptimizationsResponse*>(
               &_ReceiveGlobalSlamOptimizationsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(ReceiveGlobalSlamOptimizationsResponse& a, ReceiveGlobalSlamOptimizationsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ReceiveGlobalSlamOptimizationsResponse* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ReceiveGlobalSlamOptimizationsResponse* New() const final {
    return CreateMaybeMessage<ReceiveGlobalSlamOptimizationsResponse>(nullptr);
  }

  ReceiveGlobalSlamOptimizationsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ReceiveGlobalSlamOptimizationsResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ReceiveGlobalSlamOptimizationsResponse& from);
  void MergeFrom(const ReceiveGlobalSlamOptimizationsResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReceiveGlobalSlamOptimizationsResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cartographer.cloud.proto.ReceiveGlobalSlamOptimizationsResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto);
    return ::descriptor_table_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kLastOptimizedNodeIdsFieldNumber = 1,
    kLastOptimizedSubmapIdsFieldNumber = 2,
  };
  // map<int32, .cartographer.mapping.proto.NodeId> last_optimized_node_ids = 1;
  int last_optimized_node_ids_size() const;
  private:
  int _internal_last_optimized_node_ids_size() const;
  public:
  void clear_last_optimized_node_ids();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::int32, ::cartographer::mapping::proto::NodeId >&
      _internal_last_optimized_node_ids() const;
  ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::int32, ::cartographer::mapping::proto::NodeId >*
      _internal_mutable_last_optimized_node_ids();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::int32, ::cartographer::mapping::proto::NodeId >&
      last_optimized_node_ids() const;
  ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::int32, ::cartographer::mapping::proto::NodeId >*
      mutable_last_optimized_node_ids();

  // map<int32, .cartographer.mapping.proto.SubmapId> last_optimized_submap_ids = 2;
  int last_optimized_submap_ids_size() const;
  private:
  int _internal_last_optimized_submap_ids_size() const;
  public:
  void clear_last_optimized_submap_ids();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::int32, ::cartographer::mapping::proto::SubmapId >&
      _internal_last_optimized_submap_ids() const;
  ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::int32, ::cartographer::mapping::proto::SubmapId >*
      _internal_mutable_last_optimized_submap_ids();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::int32, ::cartographer::mapping::proto::SubmapId >&
      last_optimized_submap_ids() const;
  ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::int32, ::cartographer::mapping::proto::SubmapId >*
      mutable_last_optimized_submap_ids();

  // @@protoc_insertion_point(class_scope:cartographer.cloud.proto.ReceiveGlobalSlamOptimizationsResponse)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      ReceiveGlobalSlamOptimizationsResponse_LastOptimizedNodeIdsEntry_DoNotUse,
      ::PROTOBUF_NAMESPACE_ID::int32, ::cartographer::mapping::proto::NodeId,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
      0 > last_optimized_node_ids_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      ReceiveGlobalSlamOptimizationsResponse_LastOptimizedSubmapIdsEntry_DoNotUse,
      ::PROTOBUF_NAMESPACE_ID::int32, ::cartographer::mapping::proto::SubmapId,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
      0 > last_optimized_submap_ids_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto;
};
// -------------------------------------------------------------------

class GetSubmapRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cartographer.cloud.proto.GetSubmapRequest) */ {
 public:
  GetSubmapRequest();
  virtual ~GetSubmapRequest();

  GetSubmapRequest(const GetSubmapRequest& from);
  GetSubmapRequest(GetSubmapRequest&& from) noexcept
    : GetSubmapRequest() {
    *this = ::std::move(from);
  }

  inline GetSubmapRequest& operator=(const GetSubmapRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetSubmapRequest& operator=(GetSubmapRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GetSubmapRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetSubmapRequest* internal_default_instance() {
    return reinterpret_cast<const GetSubmapRequest*>(
               &_GetSubmapRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(GetSubmapRequest& a, GetSubmapRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetSubmapRequest* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetSubmapRequest* New() const final {
    return CreateMaybeMessage<GetSubmapRequest>(nullptr);
  }

  GetSubmapRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetSubmapRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetSubmapRequest& from);
  void MergeFrom(const GetSubmapRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetSubmapRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cartographer.cloud.proto.GetSubmapRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto);
    return ::descriptor_table_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSubmapIdFieldNumber = 1,
  };
  // .cartographer.mapping.proto.SubmapId submap_id = 1;
  bool has_submap_id() const;
  private:
  bool _internal_has_submap_id() const;
  public:
  void clear_submap_id();
  const ::cartographer::mapping::proto::SubmapId& submap_id() const;
  ::cartographer::mapping::proto::SubmapId* release_submap_id();
  ::cartographer::mapping::proto::SubmapId* mutable_submap_id();
  void set_allocated_submap_id(::cartographer::mapping::proto::SubmapId* submap_id);
  private:
  const ::cartographer::mapping::proto::SubmapId& _internal_submap_id() const;
  ::cartographer::mapping::proto::SubmapId* _internal_mutable_submap_id();
  public:

  // @@protoc_insertion_point(class_scope:cartographer.cloud.proto.GetSubmapRequest)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::cartographer::mapping::proto::SubmapId* submap_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto;
};
// -------------------------------------------------------------------

class LoadStateRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cartographer.cloud.proto.LoadStateRequest) */ {
 public:
  LoadStateRequest();
  virtual ~LoadStateRequest();

  LoadStateRequest(const LoadStateRequest& from);
  LoadStateRequest(LoadStateRequest&& from) noexcept
    : LoadStateRequest() {
    *this = ::std::move(from);
  }

  inline LoadStateRequest& operator=(const LoadStateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoadStateRequest& operator=(LoadStateRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LoadStateRequest& default_instance();

  enum StateChunkCase {
    kSerializedData = 1,
    kSerializationHeader = 2,
    kClientId = 3,
    STATE_CHUNK_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LoadStateRequest* internal_default_instance() {
    return reinterpret_cast<const LoadStateRequest*>(
               &_LoadStateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(LoadStateRequest& a, LoadStateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(LoadStateRequest* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LoadStateRequest* New() const final {
    return CreateMaybeMessage<LoadStateRequest>(nullptr);
  }

  LoadStateRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LoadStateRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LoadStateRequest& from);
  void MergeFrom(const LoadStateRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoadStateRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cartographer.cloud.proto.LoadStateRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto);
    return ::descriptor_table_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLoadFrozenStateFieldNumber = 4,
    kSerializedDataFieldNumber = 1,
    kSerializationHeaderFieldNumber = 2,
    kClientIdFieldNumber = 3,
  };
  // bool load_frozen_state = 4;
  void clear_load_frozen_state();
  bool load_frozen_state() const;
  void set_load_frozen_state(bool value);
  private:
  bool _internal_load_frozen_state() const;
  void _internal_set_load_frozen_state(bool value);
  public:

  // .cartographer.mapping.proto.SerializedData serialized_data = 1;
  bool has_serialized_data() const;
  private:
  bool _internal_has_serialized_data() const;
  public:
  void clear_serialized_data();
  const ::cartographer::mapping::proto::SerializedData& serialized_data() const;
  ::cartographer::mapping::proto::SerializedData* release_serialized_data();
  ::cartographer::mapping::proto::SerializedData* mutable_serialized_data();
  void set_allocated_serialized_data(::cartographer::mapping::proto::SerializedData* serialized_data);
  private:
  const ::cartographer::mapping::proto::SerializedData& _internal_serialized_data() const;
  ::cartographer::mapping::proto::SerializedData* _internal_mutable_serialized_data();
  public:

  // .cartographer.mapping.proto.SerializationHeader serialization_header = 2;
  bool has_serialization_header() const;
  private:
  bool _internal_has_serialization_header() const;
  public:
  void clear_serialization_header();
  const ::cartographer::mapping::proto::SerializationHeader& serialization_header() const;
  ::cartographer::mapping::proto::SerializationHeader* release_serialization_header();
  ::cartographer::mapping::proto::SerializationHeader* mutable_serialization_header();
  void set_allocated_serialization_header(::cartographer::mapping::proto::SerializationHeader* serialization_header);
  private:
  const ::cartographer::mapping::proto::SerializationHeader& _internal_serialization_header() const;
  ::cartographer::mapping::proto::SerializationHeader* _internal_mutable_serialization_header();
  public:

  // string client_id = 3;
  private:
  bool _internal_has_client_id() const;
  public:
  void clear_client_id();
  const std::string& client_id() const;
  void set_client_id(const std::string& value);
  void set_client_id(std::string&& value);
  void set_client_id(const char* value);
  void set_client_id(const char* value, size_t size);
  std::string* mutable_client_id();
  std::string* release_client_id();
  void set_allocated_client_id(std::string* client_id);
  private:
  const std::string& _internal_client_id() const;
  void _internal_set_client_id(const std::string& value);
  std::string* _internal_mutable_client_id();
  public:

  void clear_state_chunk();
  StateChunkCase state_chunk_case() const;
  // @@protoc_insertion_point(class_scope:cartographer.cloud.proto.LoadStateRequest)
 private:
  class _Internal;
  void set_has_serialized_data();
  void set_has_serialization_header();
  void set_has_client_id();

  inline bool has_state_chunk() const;
  inline void clear_has_state_chunk();

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  bool load_frozen_state_;
  union StateChunkUnion {
    StateChunkUnion() {}
    ::cartographer::mapping::proto::SerializedData* serialized_data_;
    ::cartographer::mapping::proto::SerializationHeader* serialization_header_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr client_id_;
  } state_chunk_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto;
};
// -------------------------------------------------------------------

class TrajectoryRemapping_SerializedTrajectoriesToTrajectoriesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<TrajectoryRemapping_SerializedTrajectoriesToTrajectoriesEntry_DoNotUse, 
    ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::int32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
    0 > {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<TrajectoryRemapping_SerializedTrajectoriesToTrajectoriesEntry_DoNotUse, 
    ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::int32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
    0 > SuperType;
  TrajectoryRemapping_SerializedTrajectoriesToTrajectoriesEntry_DoNotUse();
  TrajectoryRemapping_SerializedTrajectoriesToTrajectoriesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const TrajectoryRemapping_SerializedTrajectoriesToTrajectoriesEntry_DoNotUse& other);
  static const TrajectoryRemapping_SerializedTrajectoriesToTrajectoriesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const TrajectoryRemapping_SerializedTrajectoriesToTrajectoriesEntry_DoNotUse*>(&_TrajectoryRemapping_SerializedTrajectoriesToTrajectoriesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto);
    return ::descriptor_table_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto.file_level_metadata[21];
  }

  public:
};

// -------------------------------------------------------------------

class TrajectoryRemapping :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cartographer.cloud.proto.TrajectoryRemapping) */ {
 public:
  TrajectoryRemapping();
  virtual ~TrajectoryRemapping();

  TrajectoryRemapping(const TrajectoryRemapping& from);
  TrajectoryRemapping(TrajectoryRemapping&& from) noexcept
    : TrajectoryRemapping() {
    *this = ::std::move(from);
  }

  inline TrajectoryRemapping& operator=(const TrajectoryRemapping& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrajectoryRemapping& operator=(TrajectoryRemapping&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TrajectoryRemapping& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TrajectoryRemapping* internal_default_instance() {
    return reinterpret_cast<const TrajectoryRemapping*>(
               &_TrajectoryRemapping_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(TrajectoryRemapping& a, TrajectoryRemapping& b) {
    a.Swap(&b);
  }
  inline void Swap(TrajectoryRemapping* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TrajectoryRemapping* New() const final {
    return CreateMaybeMessage<TrajectoryRemapping>(nullptr);
  }

  TrajectoryRemapping* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TrajectoryRemapping>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TrajectoryRemapping& from);
  void MergeFrom(const TrajectoryRemapping& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TrajectoryRemapping* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cartographer.cloud.proto.TrajectoryRemapping";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto);
    return ::descriptor_table_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kSerializedTrajectoriesToTrajectoriesFieldNumber = 1,
  };
  // map<int32, int32> serialized_trajectories_to_trajectories = 1;
  int serialized_trajectories_to_trajectories_size() const;
  private:
  int _internal_serialized_trajectories_to_trajectories_size() const;
  public:
  void clear_serialized_trajectories_to_trajectories();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::int32 >&
      _internal_serialized_trajectories_to_trajectories() const;
  ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::int32 >*
      _internal_mutable_serialized_trajectories_to_trajectories();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::int32 >&
      serialized_trajectories_to_trajectories() const;
  ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::int32 >*
      mutable_serialized_trajectories_to_trajectories();

  // @@protoc_insertion_point(class_scope:cartographer.cloud.proto.TrajectoryRemapping)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      TrajectoryRemapping_SerializedTrajectoriesToTrajectoriesEntry_DoNotUse,
      ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::int32,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
      0 > serialized_trajectories_to_trajectories_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto;
};
// -------------------------------------------------------------------

class LoadStateResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cartographer.cloud.proto.LoadStateResponse) */ {
 public:
  LoadStateResponse();
  virtual ~LoadStateResponse();

  LoadStateResponse(const LoadStateResponse& from);
  LoadStateResponse(LoadStateResponse&& from) noexcept
    : LoadStateResponse() {
    *this = ::std::move(from);
  }

  inline LoadStateResponse& operator=(const LoadStateResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoadStateResponse& operator=(LoadStateResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LoadStateResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LoadStateResponse* internal_default_instance() {
    return reinterpret_cast<const LoadStateResponse*>(
               &_LoadStateResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(LoadStateResponse& a, LoadStateResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(LoadStateResponse* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LoadStateResponse* New() const final {
    return CreateMaybeMessage<LoadStateResponse>(nullptr);
  }

  LoadStateResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LoadStateResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LoadStateResponse& from);
  void MergeFrom(const LoadStateResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoadStateResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cartographer.cloud.proto.LoadStateResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto);
    return ::descriptor_table_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTrajectoryRemappingFieldNumber = 1,
  };
  // .cartographer.cloud.proto.TrajectoryRemapping trajectory_remapping = 1;
  bool has_trajectory_remapping() const;
  private:
  bool _internal_has_trajectory_remapping() const;
  public:
  void clear_trajectory_remapping();
  const ::cartographer::cloud::proto::TrajectoryRemapping& trajectory_remapping() const;
  ::cartographer::cloud::proto::TrajectoryRemapping* release_trajectory_remapping();
  ::cartographer::cloud::proto::TrajectoryRemapping* mutable_trajectory_remapping();
  void set_allocated_trajectory_remapping(::cartographer::cloud::proto::TrajectoryRemapping* trajectory_remapping);
  private:
  const ::cartographer::cloud::proto::TrajectoryRemapping& _internal_trajectory_remapping() const;
  ::cartographer::cloud::proto::TrajectoryRemapping* _internal_mutable_trajectory_remapping();
  public:

  // @@protoc_insertion_point(class_scope:cartographer.cloud.proto.LoadStateResponse)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::cartographer::cloud::proto::TrajectoryRemapping* trajectory_remapping_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto;
};
// -------------------------------------------------------------------

class LoadStateFromFileRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cartographer.cloud.proto.LoadStateFromFileRequest) */ {
 public:
  LoadStateFromFileRequest();
  virtual ~LoadStateFromFileRequest();

  LoadStateFromFileRequest(const LoadStateFromFileRequest& from);
  LoadStateFromFileRequest(LoadStateFromFileRequest&& from) noexcept
    : LoadStateFromFileRequest() {
    *this = ::std::move(from);
  }

  inline LoadStateFromFileRequest& operator=(const LoadStateFromFileRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoadStateFromFileRequest& operator=(LoadStateFromFileRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LoadStateFromFileRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LoadStateFromFileRequest* internal_default_instance() {
    return reinterpret_cast<const LoadStateFromFileRequest*>(
               &_LoadStateFromFileRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(LoadStateFromFileRequest& a, LoadStateFromFileRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(LoadStateFromFileRequest* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LoadStateFromFileRequest* New() const final {
    return CreateMaybeMessage<LoadStateFromFileRequest>(nullptr);
  }

  LoadStateFromFileRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LoadStateFromFileRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LoadStateFromFileRequest& from);
  void MergeFrom(const LoadStateFromFileRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoadStateFromFileRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cartographer.cloud.proto.LoadStateFromFileRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto);
    return ::descriptor_table_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFilePathFieldNumber = 1,
    kClientIdFieldNumber = 2,
    kLoadFrozenStateFieldNumber = 3,
  };
  // string file_path = 1;
  void clear_file_path();
  const std::string& file_path() const;
  void set_file_path(const std::string& value);
  void set_file_path(std::string&& value);
  void set_file_path(const char* value);
  void set_file_path(const char* value, size_t size);
  std::string* mutable_file_path();
  std::string* release_file_path();
  void set_allocated_file_path(std::string* file_path);
  private:
  const std::string& _internal_file_path() const;
  void _internal_set_file_path(const std::string& value);
  std::string* _internal_mutable_file_path();
  public:

  // string client_id = 2;
  void clear_client_id();
  const std::string& client_id() const;
  void set_client_id(const std::string& value);
  void set_client_id(std::string&& value);
  void set_client_id(const char* value);
  void set_client_id(const char* value, size_t size);
  std::string* mutable_client_id();
  std::string* release_client_id();
  void set_allocated_client_id(std::string* client_id);
  private:
  const std::string& _internal_client_id() const;
  void _internal_set_client_id(const std::string& value);
  std::string* _internal_mutable_client_id();
  public:

  // bool load_frozen_state = 3;
  void clear_load_frozen_state();
  bool load_frozen_state() const;
  void set_load_frozen_state(bool value);
  private:
  bool _internal_load_frozen_state() const;
  void _internal_set_load_frozen_state(bool value);
  public:

  // @@protoc_insertion_point(class_scope:cartographer.cloud.proto.LoadStateFromFileRequest)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_path_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr client_id_;
  bool load_frozen_state_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto;
};
// -------------------------------------------------------------------

class LoadStateFromFileResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cartographer.cloud.proto.LoadStateFromFileResponse) */ {
 public:
  LoadStateFromFileResponse();
  virtual ~LoadStateFromFileResponse();

  LoadStateFromFileResponse(const LoadStateFromFileResponse& from);
  LoadStateFromFileResponse(LoadStateFromFileResponse&& from) noexcept
    : LoadStateFromFileResponse() {
    *this = ::std::move(from);
  }

  inline LoadStateFromFileResponse& operator=(const LoadStateFromFileResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoadStateFromFileResponse& operator=(LoadStateFromFileResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LoadStateFromFileResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LoadStateFromFileResponse* internal_default_instance() {
    return reinterpret_cast<const LoadStateFromFileResponse*>(
               &_LoadStateFromFileResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(LoadStateFromFileResponse& a, LoadStateFromFileResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(LoadStateFromFileResponse* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LoadStateFromFileResponse* New() const final {
    return CreateMaybeMessage<LoadStateFromFileResponse>(nullptr);
  }

  LoadStateFromFileResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LoadStateFromFileResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LoadStateFromFileResponse& from);
  void MergeFrom(const LoadStateFromFileResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoadStateFromFileResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cartographer.cloud.proto.LoadStateFromFileResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto);
    return ::descriptor_table_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTrajectoryRemappingFieldNumber = 1,
  };
  // .cartographer.cloud.proto.TrajectoryRemapping trajectory_remapping = 1;
  bool has_trajectory_remapping() const;
  private:
  bool _internal_has_trajectory_remapping() const;
  public:
  void clear_trajectory_remapping();
  const ::cartographer::cloud::proto::TrajectoryRemapping& trajectory_remapping() const;
  ::cartographer::cloud::proto::TrajectoryRemapping* release_trajectory_remapping();
  ::cartographer::cloud::proto::TrajectoryRemapping* mutable_trajectory_remapping();
  void set_allocated_trajectory_remapping(::cartographer::cloud::proto::TrajectoryRemapping* trajectory_remapping);
  private:
  const ::cartographer::cloud::proto::TrajectoryRemapping& _internal_trajectory_remapping() const;
  ::cartographer::cloud::proto::TrajectoryRemapping* _internal_mutable_trajectory_remapping();
  public:

  // @@protoc_insertion_point(class_scope:cartographer.cloud.proto.LoadStateFromFileResponse)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::cartographer::cloud::proto::TrajectoryRemapping* trajectory_remapping_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto;
};
// -------------------------------------------------------------------

class GetSubmapResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cartographer.cloud.proto.GetSubmapResponse) */ {
 public:
  GetSubmapResponse();
  virtual ~GetSubmapResponse();

  GetSubmapResponse(const GetSubmapResponse& from);
  GetSubmapResponse(GetSubmapResponse&& from) noexcept
    : GetSubmapResponse() {
    *this = ::std::move(from);
  }

  inline GetSubmapResponse& operator=(const GetSubmapResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetSubmapResponse& operator=(GetSubmapResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GetSubmapResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetSubmapResponse* internal_default_instance() {
    return reinterpret_cast<const GetSubmapResponse*>(
               &_GetSubmapResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(GetSubmapResponse& a, GetSubmapResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetSubmapResponse* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetSubmapResponse* New() const final {
    return CreateMaybeMessage<GetSubmapResponse>(nullptr);
  }

  GetSubmapResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetSubmapResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetSubmapResponse& from);
  void MergeFrom(const GetSubmapResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetSubmapResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cartographer.cloud.proto.GetSubmapResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto);
    return ::descriptor_table_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorMsgFieldNumber = 2,
    kSubmapQueryResponseFieldNumber = 1,
  };
  // string error_msg = 2;
  void clear_error_msg();
  const std::string& error_msg() const;
  void set_error_msg(const std::string& value);
  void set_error_msg(std::string&& value);
  void set_error_msg(const char* value);
  void set_error_msg(const char* value, size_t size);
  std::string* mutable_error_msg();
  std::string* release_error_msg();
  void set_allocated_error_msg(std::string* error_msg);
  private:
  const std::string& _internal_error_msg() const;
  void _internal_set_error_msg(const std::string& value);
  std::string* _internal_mutable_error_msg();
  public:

  // .cartographer.mapping.proto.SubmapQuery.Response submap_query_response = 1;
  bool has_submap_query_response() const;
  private:
  bool _internal_has_submap_query_response() const;
  public:
  void clear_submap_query_response();
  const ::cartographer::mapping::proto::SubmapQuery_Response& submap_query_response() const;
  ::cartographer::mapping::proto::SubmapQuery_Response* release_submap_query_response();
  ::cartographer::mapping::proto::SubmapQuery_Response* mutable_submap_query_response();
  void set_allocated_submap_query_response(::cartographer::mapping::proto::SubmapQuery_Response* submap_query_response);
  private:
  const ::cartographer::mapping::proto::SubmapQuery_Response& _internal_submap_query_response() const;
  ::cartographer::mapping::proto::SubmapQuery_Response* _internal_mutable_submap_query_response();
  public:

  // @@protoc_insertion_point(class_scope:cartographer.cloud.proto.GetSubmapResponse)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_msg_;
  ::cartographer::mapping::proto::SubmapQuery_Response* submap_query_response_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto;
};
// -------------------------------------------------------------------

class TrajectoryNodePose_ConstantPoseData :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cartographer.cloud.proto.TrajectoryNodePose.ConstantPoseData) */ {
 public:
  TrajectoryNodePose_ConstantPoseData();
  virtual ~TrajectoryNodePose_ConstantPoseData();

  TrajectoryNodePose_ConstantPoseData(const TrajectoryNodePose_ConstantPoseData& from);
  TrajectoryNodePose_ConstantPoseData(TrajectoryNodePose_ConstantPoseData&& from) noexcept
    : TrajectoryNodePose_ConstantPoseData() {
    *this = ::std::move(from);
  }

  inline TrajectoryNodePose_ConstantPoseData& operator=(const TrajectoryNodePose_ConstantPoseData& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrajectoryNodePose_ConstantPoseData& operator=(TrajectoryNodePose_ConstantPoseData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TrajectoryNodePose_ConstantPoseData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TrajectoryNodePose_ConstantPoseData* internal_default_instance() {
    return reinterpret_cast<const TrajectoryNodePose_ConstantPoseData*>(
               &_TrajectoryNodePose_ConstantPoseData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(TrajectoryNodePose_ConstantPoseData& a, TrajectoryNodePose_ConstantPoseData& b) {
    a.Swap(&b);
  }
  inline void Swap(TrajectoryNodePose_ConstantPoseData* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TrajectoryNodePose_ConstantPoseData* New() const final {
    return CreateMaybeMessage<TrajectoryNodePose_ConstantPoseData>(nullptr);
  }

  TrajectoryNodePose_ConstantPoseData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TrajectoryNodePose_ConstantPoseData>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TrajectoryNodePose_ConstantPoseData& from);
  void MergeFrom(const TrajectoryNodePose_ConstantPoseData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TrajectoryNodePose_ConstantPoseData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cartographer.cloud.proto.TrajectoryNodePose.ConstantPoseData";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto);
    return ::descriptor_table_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLocalPoseFieldNumber = 2,
    kTimestampFieldNumber = 1,
  };
  // .cartographer.transform.proto.Rigid3d local_pose = 2;
  bool has_local_pose() const;
  private:
  bool _internal_has_local_pose() const;
  public:
  void clear_local_pose();
  const ::cartographer::transform::proto::Rigid3d& local_pose() const;
  ::cartographer::transform::proto::Rigid3d* release_local_pose();
  ::cartographer::transform::proto::Rigid3d* mutable_local_pose();
  void set_allocated_local_pose(::cartographer::transform::proto::Rigid3d* local_pose);
  private:
  const ::cartographer::transform::proto::Rigid3d& _internal_local_pose() const;
  ::cartographer::transform::proto::Rigid3d* _internal_mutable_local_pose();
  public:

  // int64 timestamp = 1;
  void clear_timestamp();
  ::PROTOBUF_NAMESPACE_ID::int64 timestamp() const;
  void set_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_timestamp() const;
  void _internal_set_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:cartographer.cloud.proto.TrajectoryNodePose.ConstantPoseData)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::cartographer::transform::proto::Rigid3d* local_pose_;
  ::PROTOBUF_NAMESPACE_ID::int64 timestamp_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto;
};
// -------------------------------------------------------------------

class TrajectoryNodePose :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cartographer.cloud.proto.TrajectoryNodePose) */ {
 public:
  TrajectoryNodePose();
  virtual ~TrajectoryNodePose();

  TrajectoryNodePose(const TrajectoryNodePose& from);
  TrajectoryNodePose(TrajectoryNodePose&& from) noexcept
    : TrajectoryNodePose() {
    *this = ::std::move(from);
  }

  inline TrajectoryNodePose& operator=(const TrajectoryNodePose& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrajectoryNodePose& operator=(TrajectoryNodePose&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TrajectoryNodePose& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TrajectoryNodePose* internal_default_instance() {
    return reinterpret_cast<const TrajectoryNodePose*>(
               &_TrajectoryNodePose_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(TrajectoryNodePose& a, TrajectoryNodePose& b) {
    a.Swap(&b);
  }
  inline void Swap(TrajectoryNodePose* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TrajectoryNodePose* New() const final {
    return CreateMaybeMessage<TrajectoryNodePose>(nullptr);
  }

  TrajectoryNodePose* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TrajectoryNodePose>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TrajectoryNodePose& from);
  void MergeFrom(const TrajectoryNodePose& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TrajectoryNodePose* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cartographer.cloud.proto.TrajectoryNodePose";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto);
    return ::descriptor_table_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef TrajectoryNodePose_ConstantPoseData ConstantPoseData;

  // accessors -------------------------------------------------------

  enum : int {
    kNodeIdFieldNumber = 1,
    kGlobalPoseFieldNumber = 2,
    kConstantPoseDataFieldNumber = 3,
  };
  // .cartographer.mapping.proto.NodeId node_id = 1;
  bool has_node_id() const;
  private:
  bool _internal_has_node_id() const;
  public:
  void clear_node_id();
  const ::cartographer::mapping::proto::NodeId& node_id() const;
  ::cartographer::mapping::proto::NodeId* release_node_id();
  ::cartographer::mapping::proto::NodeId* mutable_node_id();
  void set_allocated_node_id(::cartographer::mapping::proto::NodeId* node_id);
  private:
  const ::cartographer::mapping::proto::NodeId& _internal_node_id() const;
  ::cartographer::mapping::proto::NodeId* _internal_mutable_node_id();
  public:

  // .cartographer.transform.proto.Rigid3d global_pose = 2;
  bool has_global_pose() const;
  private:
  bool _internal_has_global_pose() const;
  public:
  void clear_global_pose();
  const ::cartographer::transform::proto::Rigid3d& global_pose() const;
  ::cartographer::transform::proto::Rigid3d* release_global_pose();
  ::cartographer::transform::proto::Rigid3d* mutable_global_pose();
  void set_allocated_global_pose(::cartographer::transform::proto::Rigid3d* global_pose);
  private:
  const ::cartographer::transform::proto::Rigid3d& _internal_global_pose() const;
  ::cartographer::transform::proto::Rigid3d* _internal_mutable_global_pose();
  public:

  // .cartographer.cloud.proto.TrajectoryNodePose.ConstantPoseData constant_pose_data = 3;
  bool has_constant_pose_data() const;
  private:
  bool _internal_has_constant_pose_data() const;
  public:
  void clear_constant_pose_data();
  const ::cartographer::cloud::proto::TrajectoryNodePose_ConstantPoseData& constant_pose_data() const;
  ::cartographer::cloud::proto::TrajectoryNodePose_ConstantPoseData* release_constant_pose_data();
  ::cartographer::cloud::proto::TrajectoryNodePose_ConstantPoseData* mutable_constant_pose_data();
  void set_allocated_constant_pose_data(::cartographer::cloud::proto::TrajectoryNodePose_ConstantPoseData* constant_pose_data);
  private:
  const ::cartographer::cloud::proto::TrajectoryNodePose_ConstantPoseData& _internal_constant_pose_data() const;
  ::cartographer::cloud::proto::TrajectoryNodePose_ConstantPoseData* _internal_mutable_constant_pose_data();
  public:

  // @@protoc_insertion_point(class_scope:cartographer.cloud.proto.TrajectoryNodePose)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::cartographer::mapping::proto::NodeId* node_id_;
  ::cartographer::transform::proto::Rigid3d* global_pose_;
  ::cartographer::cloud::proto::TrajectoryNodePose_ConstantPoseData* constant_pose_data_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto;
};
// -------------------------------------------------------------------

class GetTrajectoryNodePosesResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cartographer.cloud.proto.GetTrajectoryNodePosesResponse) */ {
 public:
  GetTrajectoryNodePosesResponse();
  virtual ~GetTrajectoryNodePosesResponse();

  GetTrajectoryNodePosesResponse(const GetTrajectoryNodePosesResponse& from);
  GetTrajectoryNodePosesResponse(GetTrajectoryNodePosesResponse&& from) noexcept
    : GetTrajectoryNodePosesResponse() {
    *this = ::std::move(from);
  }

  inline GetTrajectoryNodePosesResponse& operator=(const GetTrajectoryNodePosesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetTrajectoryNodePosesResponse& operator=(GetTrajectoryNodePosesResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GetTrajectoryNodePosesResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetTrajectoryNodePosesResponse* internal_default_instance() {
    return reinterpret_cast<const GetTrajectoryNodePosesResponse*>(
               &_GetTrajectoryNodePosesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(GetTrajectoryNodePosesResponse& a, GetTrajectoryNodePosesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetTrajectoryNodePosesResponse* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetTrajectoryNodePosesResponse* New() const final {
    return CreateMaybeMessage<GetTrajectoryNodePosesResponse>(nullptr);
  }

  GetTrajectoryNodePosesResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetTrajectoryNodePosesResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetTrajectoryNodePosesResponse& from);
  void MergeFrom(const GetTrajectoryNodePosesResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetTrajectoryNodePosesResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cartographer.cloud.proto.GetTrajectoryNodePosesResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto);
    return ::descriptor_table_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNodePosesFieldNumber = 1,
  };
  // repeated .cartographer.cloud.proto.TrajectoryNodePose node_poses = 1;
  int node_poses_size() const;
  private:
  int _internal_node_poses_size() const;
  public:
  void clear_node_poses();
  ::cartographer::cloud::proto::TrajectoryNodePose* mutable_node_poses(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cartographer::cloud::proto::TrajectoryNodePose >*
      mutable_node_poses();
  private:
  const ::cartographer::cloud::proto::TrajectoryNodePose& _internal_node_poses(int index) const;
  ::cartographer::cloud::proto::TrajectoryNodePose* _internal_add_node_poses();
  public:
  const ::cartographer::cloud::proto::TrajectoryNodePose& node_poses(int index) const;
  ::cartographer::cloud::proto::TrajectoryNodePose* add_node_poses();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cartographer::cloud::proto::TrajectoryNodePose >&
      node_poses() const;

  // @@protoc_insertion_point(class_scope:cartographer.cloud.proto.GetTrajectoryNodePosesResponse)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cartographer::cloud::proto::TrajectoryNodePose > node_poses_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto;
};
// -------------------------------------------------------------------

class GetTrajectoryStatesResponse_TrajectoriesStateEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<GetTrajectoryStatesResponse_TrajectoriesStateEntry_DoNotUse, 
    ::PROTOBUF_NAMESPACE_ID::int32, ::cartographer::cloud::proto::TrajectoryState,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM,
    0 > {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<GetTrajectoryStatesResponse_TrajectoriesStateEntry_DoNotUse, 
    ::PROTOBUF_NAMESPACE_ID::int32, ::cartographer::cloud::proto::TrajectoryState,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM,
    0 > SuperType;
  GetTrajectoryStatesResponse_TrajectoriesStateEntry_DoNotUse();
  GetTrajectoryStatesResponse_TrajectoriesStateEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const GetTrajectoryStatesResponse_TrajectoriesStateEntry_DoNotUse& other);
  static const GetTrajectoryStatesResponse_TrajectoriesStateEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const GetTrajectoryStatesResponse_TrajectoriesStateEntry_DoNotUse*>(&_GetTrajectoryStatesResponse_TrajectoriesStateEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto);
    return ::descriptor_table_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto.file_level_metadata[30];
  }

  public:
};

// -------------------------------------------------------------------

class GetTrajectoryStatesResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cartographer.cloud.proto.GetTrajectoryStatesResponse) */ {
 public:
  GetTrajectoryStatesResponse();
  virtual ~GetTrajectoryStatesResponse();

  GetTrajectoryStatesResponse(const GetTrajectoryStatesResponse& from);
  GetTrajectoryStatesResponse(GetTrajectoryStatesResponse&& from) noexcept
    : GetTrajectoryStatesResponse() {
    *this = ::std::move(from);
  }

  inline GetTrajectoryStatesResponse& operator=(const GetTrajectoryStatesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetTrajectoryStatesResponse& operator=(GetTrajectoryStatesResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GetTrajectoryStatesResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetTrajectoryStatesResponse* internal_default_instance() {
    return reinterpret_cast<const GetTrajectoryStatesResponse*>(
               &_GetTrajectoryStatesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(GetTrajectoryStatesResponse& a, GetTrajectoryStatesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetTrajectoryStatesResponse* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetTrajectoryStatesResponse* New() const final {
    return CreateMaybeMessage<GetTrajectoryStatesResponse>(nullptr);
  }

  GetTrajectoryStatesResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetTrajectoryStatesResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetTrajectoryStatesResponse& from);
  void MergeFrom(const GetTrajectoryStatesResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetTrajectoryStatesResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cartographer.cloud.proto.GetTrajectoryStatesResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto);
    return ::descriptor_table_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kTrajectoriesStateFieldNumber = 1,
  };
  // map<int32, .cartographer.cloud.proto.TrajectoryState> trajectories_state = 1;
  int trajectories_state_size() const;
  private:
  int _internal_trajectories_state_size() const;
  public:
  void clear_trajectories_state();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::int32, ::cartographer::cloud::proto::TrajectoryState >&
      _internal_trajectories_state() const;
  ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::int32, ::cartographer::cloud::proto::TrajectoryState >*
      _internal_mutable_trajectories_state();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::int32, ::cartographer::cloud::proto::TrajectoryState >&
      trajectories_state() const;
  ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::int32, ::cartographer::cloud::proto::TrajectoryState >*
      mutable_trajectories_state();

  // @@protoc_insertion_point(class_scope:cartographer.cloud.proto.GetTrajectoryStatesResponse)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      GetTrajectoryStatesResponse_TrajectoriesStateEntry_DoNotUse,
      ::PROTOBUF_NAMESPACE_ID::int32, ::cartographer::cloud::proto::TrajectoryState,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM,
      0 > trajectories_state_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto;
};
// -------------------------------------------------------------------

class GetLandmarkPosesResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cartographer.cloud.proto.GetLandmarkPosesResponse) */ {
 public:
  GetLandmarkPosesResponse();
  virtual ~GetLandmarkPosesResponse();

  GetLandmarkPosesResponse(const GetLandmarkPosesResponse& from);
  GetLandmarkPosesResponse(GetLandmarkPosesResponse&& from) noexcept
    : GetLandmarkPosesResponse() {
    *this = ::std::move(from);
  }

  inline GetLandmarkPosesResponse& operator=(const GetLandmarkPosesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetLandmarkPosesResponse& operator=(GetLandmarkPosesResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GetLandmarkPosesResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetLandmarkPosesResponse* internal_default_instance() {
    return reinterpret_cast<const GetLandmarkPosesResponse*>(
               &_GetLandmarkPosesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(GetLandmarkPosesResponse& a, GetLandmarkPosesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetLandmarkPosesResponse* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetLandmarkPosesResponse* New() const final {
    return CreateMaybeMessage<GetLandmarkPosesResponse>(nullptr);
  }

  GetLandmarkPosesResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetLandmarkPosesResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetLandmarkPosesResponse& from);
  void MergeFrom(const GetLandmarkPosesResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetLandmarkPosesResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cartographer.cloud.proto.GetLandmarkPosesResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto);
    return ::descriptor_table_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLandmarkPosesFieldNumber = 1,
  };
  // repeated .cartographer.mapping.proto.PoseGraph.LandmarkPose landmark_poses = 1;
  int landmark_poses_size() const;
  private:
  int _internal_landmark_poses_size() const;
  public:
  void clear_landmark_poses();
  ::cartographer::mapping::proto::PoseGraph_LandmarkPose* mutable_landmark_poses(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cartographer::mapping::proto::PoseGraph_LandmarkPose >*
      mutable_landmark_poses();
  private:
  const ::cartographer::mapping::proto::PoseGraph_LandmarkPose& _internal_landmark_poses(int index) const;
  ::cartographer::mapping::proto::PoseGraph_LandmarkPose* _internal_add_landmark_poses();
  public:
  const ::cartographer::mapping::proto::PoseGraph_LandmarkPose& landmark_poses(int index) const;
  ::cartographer::mapping::proto::PoseGraph_LandmarkPose* add_landmark_poses();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cartographer::mapping::proto::PoseGraph_LandmarkPose >&
      landmark_poses() const;

  // @@protoc_insertion_point(class_scope:cartographer.cloud.proto.GetLandmarkPosesResponse)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cartographer::mapping::proto::PoseGraph_LandmarkPose > landmark_poses_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto;
};
// -------------------------------------------------------------------

class SetLandmarkPoseRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cartographer.cloud.proto.SetLandmarkPoseRequest) */ {
 public:
  SetLandmarkPoseRequest();
  virtual ~SetLandmarkPoseRequest();

  SetLandmarkPoseRequest(const SetLandmarkPoseRequest& from);
  SetLandmarkPoseRequest(SetLandmarkPoseRequest&& from) noexcept
    : SetLandmarkPoseRequest() {
    *this = ::std::move(from);
  }

  inline SetLandmarkPoseRequest& operator=(const SetLandmarkPoseRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetLandmarkPoseRequest& operator=(SetLandmarkPoseRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SetLandmarkPoseRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SetLandmarkPoseRequest* internal_default_instance() {
    return reinterpret_cast<const SetLandmarkPoseRequest*>(
               &_SetLandmarkPoseRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(SetLandmarkPoseRequest& a, SetLandmarkPoseRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SetLandmarkPoseRequest* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SetLandmarkPoseRequest* New() const final {
    return CreateMaybeMessage<SetLandmarkPoseRequest>(nullptr);
  }

  SetLandmarkPoseRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SetLandmarkPoseRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SetLandmarkPoseRequest& from);
  void MergeFrom(const SetLandmarkPoseRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetLandmarkPoseRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cartographer.cloud.proto.SetLandmarkPoseRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto);
    return ::descriptor_table_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLandmarkPoseFieldNumber = 1,
  };
  // .cartographer.mapping.proto.PoseGraph.LandmarkPose landmark_pose = 1;
  bool has_landmark_pose() const;
  private:
  bool _internal_has_landmark_pose() const;
  public:
  void clear_landmark_pose();
  const ::cartographer::mapping::proto::PoseGraph_LandmarkPose& landmark_pose() const;
  ::cartographer::mapping::proto::PoseGraph_LandmarkPose* release_landmark_pose();
  ::cartographer::mapping::proto::PoseGraph_LandmarkPose* mutable_landmark_pose();
  void set_allocated_landmark_pose(::cartographer::mapping::proto::PoseGraph_LandmarkPose* landmark_pose);
  private:
  const ::cartographer::mapping::proto::PoseGraph_LandmarkPose& _internal_landmark_pose() const;
  ::cartographer::mapping::proto::PoseGraph_LandmarkPose* _internal_mutable_landmark_pose();
  public:

  // @@protoc_insertion_point(class_scope:cartographer.cloud.proto.SetLandmarkPoseRequest)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::cartographer::mapping::proto::PoseGraph_LandmarkPose* landmark_pose_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto;
};
// -------------------------------------------------------------------

class SubmapPose :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cartographer.cloud.proto.SubmapPose) */ {
 public:
  SubmapPose();
  virtual ~SubmapPose();

  SubmapPose(const SubmapPose& from);
  SubmapPose(SubmapPose&& from) noexcept
    : SubmapPose() {
    *this = ::std::move(from);
  }

  inline SubmapPose& operator=(const SubmapPose& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubmapPose& operator=(SubmapPose&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SubmapPose& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SubmapPose* internal_default_instance() {
    return reinterpret_cast<const SubmapPose*>(
               &_SubmapPose_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(SubmapPose& a, SubmapPose& b) {
    a.Swap(&b);
  }
  inline void Swap(SubmapPose* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SubmapPose* New() const final {
    return CreateMaybeMessage<SubmapPose>(nullptr);
  }

  SubmapPose* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SubmapPose>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SubmapPose& from);
  void MergeFrom(const SubmapPose& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubmapPose* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cartographer.cloud.proto.SubmapPose";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto);
    return ::descriptor_table_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSubmapIdFieldNumber = 1,
    kGlobalPoseFieldNumber = 3,
    kSubmapVersionFieldNumber = 2,
  };
  // .cartographer.mapping.proto.SubmapId submap_id = 1;
  bool has_submap_id() const;
  private:
  bool _internal_has_submap_id() const;
  public:
  void clear_submap_id();
  const ::cartographer::mapping::proto::SubmapId& submap_id() const;
  ::cartographer::mapping::proto::SubmapId* release_submap_id();
  ::cartographer::mapping::proto::SubmapId* mutable_submap_id();
  void set_allocated_submap_id(::cartographer::mapping::proto::SubmapId* submap_id);
  private:
  const ::cartographer::mapping::proto::SubmapId& _internal_submap_id() const;
  ::cartographer::mapping::proto::SubmapId* _internal_mutable_submap_id();
  public:

  // .cartographer.transform.proto.Rigid3d global_pose = 3;
  bool has_global_pose() const;
  private:
  bool _internal_has_global_pose() const;
  public:
  void clear_global_pose();
  const ::cartographer::transform::proto::Rigid3d& global_pose() const;
  ::cartographer::transform::proto::Rigid3d* release_global_pose();
  ::cartographer::transform::proto::Rigid3d* mutable_global_pose();
  void set_allocated_global_pose(::cartographer::transform::proto::Rigid3d* global_pose);
  private:
  const ::cartographer::transform::proto::Rigid3d& _internal_global_pose() const;
  ::cartographer::transform::proto::Rigid3d* _internal_mutable_global_pose();
  public:

  // int32 submap_version = 2;
  void clear_submap_version();
  ::PROTOBUF_NAMESPACE_ID::int32 submap_version() const;
  void set_submap_version(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_submap_version() const;
  void _internal_set_submap_version(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:cartographer.cloud.proto.SubmapPose)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::cartographer::mapping::proto::SubmapId* submap_id_;
  ::cartographer::transform::proto::Rigid3d* global_pose_;
  ::PROTOBUF_NAMESPACE_ID::int32 submap_version_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto;
};
// -------------------------------------------------------------------

class GetAllSubmapPosesResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cartographer.cloud.proto.GetAllSubmapPosesResponse) */ {
 public:
  GetAllSubmapPosesResponse();
  virtual ~GetAllSubmapPosesResponse();

  GetAllSubmapPosesResponse(const GetAllSubmapPosesResponse& from);
  GetAllSubmapPosesResponse(GetAllSubmapPosesResponse&& from) noexcept
    : GetAllSubmapPosesResponse() {
    *this = ::std::move(from);
  }

  inline GetAllSubmapPosesResponse& operator=(const GetAllSubmapPosesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetAllSubmapPosesResponse& operator=(GetAllSubmapPosesResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GetAllSubmapPosesResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetAllSubmapPosesResponse* internal_default_instance() {
    return reinterpret_cast<const GetAllSubmapPosesResponse*>(
               &_GetAllSubmapPosesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(GetAllSubmapPosesResponse& a, GetAllSubmapPosesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetAllSubmapPosesResponse* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetAllSubmapPosesResponse* New() const final {
    return CreateMaybeMessage<GetAllSubmapPosesResponse>(nullptr);
  }

  GetAllSubmapPosesResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetAllSubmapPosesResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetAllSubmapPosesResponse& from);
  void MergeFrom(const GetAllSubmapPosesResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetAllSubmapPosesResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cartographer.cloud.proto.GetAllSubmapPosesResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto);
    return ::descriptor_table_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSubmapPosesFieldNumber = 1,
  };
  // repeated .cartographer.cloud.proto.SubmapPose submap_poses = 1;
  int submap_poses_size() const;
  private:
  int _internal_submap_poses_size() const;
  public:
  void clear_submap_poses();
  ::cartographer::cloud::proto::SubmapPose* mutable_submap_poses(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cartographer::cloud::proto::SubmapPose >*
      mutable_submap_poses();
  private:
  const ::cartographer::cloud::proto::SubmapPose& _internal_submap_poses(int index) const;
  ::cartographer::cloud::proto::SubmapPose* _internal_add_submap_poses();
  public:
  const ::cartographer::cloud::proto::SubmapPose& submap_poses(int index) const;
  ::cartographer::cloud::proto::SubmapPose* add_submap_poses();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cartographer::cloud::proto::SubmapPose >&
      submap_poses() const;

  // @@protoc_insertion_point(class_scope:cartographer.cloud.proto.GetAllSubmapPosesResponse)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cartographer::cloud::proto::SubmapPose > submap_poses_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto;
};
// -------------------------------------------------------------------

class GetLocalToGlobalTransformRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cartographer.cloud.proto.GetLocalToGlobalTransformRequest) */ {
 public:
  GetLocalToGlobalTransformRequest();
  virtual ~GetLocalToGlobalTransformRequest();

  GetLocalToGlobalTransformRequest(const GetLocalToGlobalTransformRequest& from);
  GetLocalToGlobalTransformRequest(GetLocalToGlobalTransformRequest&& from) noexcept
    : GetLocalToGlobalTransformRequest() {
    *this = ::std::move(from);
  }

  inline GetLocalToGlobalTransformRequest& operator=(const GetLocalToGlobalTransformRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetLocalToGlobalTransformRequest& operator=(GetLocalToGlobalTransformRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GetLocalToGlobalTransformRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetLocalToGlobalTransformRequest* internal_default_instance() {
    return reinterpret_cast<const GetLocalToGlobalTransformRequest*>(
               &_GetLocalToGlobalTransformRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(GetLocalToGlobalTransformRequest& a, GetLocalToGlobalTransformRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetLocalToGlobalTransformRequest* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetLocalToGlobalTransformRequest* New() const final {
    return CreateMaybeMessage<GetLocalToGlobalTransformRequest>(nullptr);
  }

  GetLocalToGlobalTransformRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetLocalToGlobalTransformRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetLocalToGlobalTransformRequest& from);
  void MergeFrom(const GetLocalToGlobalTransformRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetLocalToGlobalTransformRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cartographer.cloud.proto.GetLocalToGlobalTransformRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto);
    return ::descriptor_table_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTrajectoryIdFieldNumber = 1,
  };
  // int32 trajectory_id = 1;
  void clear_trajectory_id();
  ::PROTOBUF_NAMESPACE_ID::int32 trajectory_id() const;
  void set_trajectory_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_trajectory_id() const;
  void _internal_set_trajectory_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:cartographer.cloud.proto.GetLocalToGlobalTransformRequest)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::int32 trajectory_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto;
};
// -------------------------------------------------------------------

class GetLocalToGlobalTransformResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cartographer.cloud.proto.GetLocalToGlobalTransformResponse) */ {
 public:
  GetLocalToGlobalTransformResponse();
  virtual ~GetLocalToGlobalTransformResponse();

  GetLocalToGlobalTransformResponse(const GetLocalToGlobalTransformResponse& from);
  GetLocalToGlobalTransformResponse(GetLocalToGlobalTransformResponse&& from) noexcept
    : GetLocalToGlobalTransformResponse() {
    *this = ::std::move(from);
  }

  inline GetLocalToGlobalTransformResponse& operator=(const GetLocalToGlobalTransformResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetLocalToGlobalTransformResponse& operator=(GetLocalToGlobalTransformResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GetLocalToGlobalTransformResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetLocalToGlobalTransformResponse* internal_default_instance() {
    return reinterpret_cast<const GetLocalToGlobalTransformResponse*>(
               &_GetLocalToGlobalTransformResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(GetLocalToGlobalTransformResponse& a, GetLocalToGlobalTransformResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetLocalToGlobalTransformResponse* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetLocalToGlobalTransformResponse* New() const final {
    return CreateMaybeMessage<GetLocalToGlobalTransformResponse>(nullptr);
  }

  GetLocalToGlobalTransformResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetLocalToGlobalTransformResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetLocalToGlobalTransformResponse& from);
  void MergeFrom(const GetLocalToGlobalTransformResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetLocalToGlobalTransformResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cartographer.cloud.proto.GetLocalToGlobalTransformResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto);
    return ::descriptor_table_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLocalToGlobalFieldNumber = 1,
  };
  // .cartographer.transform.proto.Rigid3d local_to_global = 1;
  bool has_local_to_global() const;
  private:
  bool _internal_has_local_to_global() const;
  public:
  void clear_local_to_global();
  const ::cartographer::transform::proto::Rigid3d& local_to_global() const;
  ::cartographer::transform::proto::Rigid3d* release_local_to_global();
  ::cartographer::transform::proto::Rigid3d* mutable_local_to_global();
  void set_allocated_local_to_global(::cartographer::transform::proto::Rigid3d* local_to_global);
  private:
  const ::cartographer::transform::proto::Rigid3d& _internal_local_to_global() const;
  ::cartographer::transform::proto::Rigid3d* _internal_mutable_local_to_global();
  public:

  // @@protoc_insertion_point(class_scope:cartographer.cloud.proto.GetLocalToGlobalTransformResponse)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::cartographer::transform::proto::Rigid3d* local_to_global_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto;
};
// -------------------------------------------------------------------

class GetConstraintsResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cartographer.cloud.proto.GetConstraintsResponse) */ {
 public:
  GetConstraintsResponse();
  virtual ~GetConstraintsResponse();

  GetConstraintsResponse(const GetConstraintsResponse& from);
  GetConstraintsResponse(GetConstraintsResponse&& from) noexcept
    : GetConstraintsResponse() {
    *this = ::std::move(from);
  }

  inline GetConstraintsResponse& operator=(const GetConstraintsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetConstraintsResponse& operator=(GetConstraintsResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GetConstraintsResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetConstraintsResponse* internal_default_instance() {
    return reinterpret_cast<const GetConstraintsResponse*>(
               &_GetConstraintsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(GetConstraintsResponse& a, GetConstraintsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetConstraintsResponse* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetConstraintsResponse* New() const final {
    return CreateMaybeMessage<GetConstraintsResponse>(nullptr);
  }

  GetConstraintsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetConstraintsResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetConstraintsResponse& from);
  void MergeFrom(const GetConstraintsResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetConstraintsResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cartographer.cloud.proto.GetConstraintsResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto);
    return ::descriptor_table_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConstraintsFieldNumber = 1,
  };
  // repeated .cartographer.mapping.proto.PoseGraph.Constraint constraints = 1;
  int constraints_size() const;
  private:
  int _internal_constraints_size() const;
  public:
  void clear_constraints();
  ::cartographer::mapping::proto::PoseGraph_Constraint* mutable_constraints(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cartographer::mapping::proto::PoseGraph_Constraint >*
      mutable_constraints();
  private:
  const ::cartographer::mapping::proto::PoseGraph_Constraint& _internal_constraints(int index) const;
  ::cartographer::mapping::proto::PoseGraph_Constraint* _internal_add_constraints();
  public:
  const ::cartographer::mapping::proto::PoseGraph_Constraint& constraints(int index) const;
  ::cartographer::mapping::proto::PoseGraph_Constraint* add_constraints();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cartographer::mapping::proto::PoseGraph_Constraint >&
      constraints() const;

  // @@protoc_insertion_point(class_scope:cartographer.cloud.proto.GetConstraintsResponse)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cartographer::mapping::proto::PoseGraph_Constraint > constraints_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto;
};
// -------------------------------------------------------------------

class WriteStateResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cartographer.cloud.proto.WriteStateResponse) */ {
 public:
  WriteStateResponse();
  virtual ~WriteStateResponse();

  WriteStateResponse(const WriteStateResponse& from);
  WriteStateResponse(WriteStateResponse&& from) noexcept
    : WriteStateResponse() {
    *this = ::std::move(from);
  }

  inline WriteStateResponse& operator=(const WriteStateResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline WriteStateResponse& operator=(WriteStateResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const WriteStateResponse& default_instance();

  enum StateChunkCase {
    kHeader = 1,
    kSerializedData = 2,
    STATE_CHUNK_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WriteStateResponse* internal_default_instance() {
    return reinterpret_cast<const WriteStateResponse*>(
               &_WriteStateResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(WriteStateResponse& a, WriteStateResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(WriteStateResponse* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline WriteStateResponse* New() const final {
    return CreateMaybeMessage<WriteStateResponse>(nullptr);
  }

  WriteStateResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<WriteStateResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const WriteStateResponse& from);
  void MergeFrom(const WriteStateResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WriteStateResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cartographer.cloud.proto.WriteStateResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto);
    return ::descriptor_table_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kSerializedDataFieldNumber = 2,
  };
  // .cartographer.mapping.proto.SerializationHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::cartographer::mapping::proto::SerializationHeader& header() const;
  ::cartographer::mapping::proto::SerializationHeader* release_header();
  ::cartographer::mapping::proto::SerializationHeader* mutable_header();
  void set_allocated_header(::cartographer::mapping::proto::SerializationHeader* header);
  private:
  const ::cartographer::mapping::proto::SerializationHeader& _internal_header() const;
  ::cartographer::mapping::proto::SerializationHeader* _internal_mutable_header();
  public:

  // .cartographer.mapping.proto.SerializedData serialized_data = 2;
  bool has_serialized_data() const;
  private:
  bool _internal_has_serialized_data() const;
  public:
  void clear_serialized_data();
  const ::cartographer::mapping::proto::SerializedData& serialized_data() const;
  ::cartographer::mapping::proto::SerializedData* release_serialized_data();
  ::cartographer::mapping::proto::SerializedData* mutable_serialized_data();
  void set_allocated_serialized_data(::cartographer::mapping::proto::SerializedData* serialized_data);
  private:
  const ::cartographer::mapping::proto::SerializedData& _internal_serialized_data() const;
  ::cartographer::mapping::proto::SerializedData* _internal_mutable_serialized_data();
  public:

  void clear_state_chunk();
  StateChunkCase state_chunk_case() const;
  // @@protoc_insertion_point(class_scope:cartographer.cloud.proto.WriteStateResponse)
 private:
  class _Internal;
  void set_has_header();
  void set_has_serialized_data();

  inline bool has_state_chunk() const;
  inline void clear_has_state_chunk();

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  union StateChunkUnion {
    StateChunkUnion() {}
    ::cartographer::mapping::proto::SerializationHeader* header_;
    ::cartographer::mapping::proto::SerializedData* serialized_data_;
  } state_chunk_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto;
};
// -------------------------------------------------------------------

class WriteStateToFileRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cartographer.cloud.proto.WriteStateToFileRequest) */ {
 public:
  WriteStateToFileRequest();
  virtual ~WriteStateToFileRequest();

  WriteStateToFileRequest(const WriteStateToFileRequest& from);
  WriteStateToFileRequest(WriteStateToFileRequest&& from) noexcept
    : WriteStateToFileRequest() {
    *this = ::std::move(from);
  }

  inline WriteStateToFileRequest& operator=(const WriteStateToFileRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline WriteStateToFileRequest& operator=(WriteStateToFileRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const WriteStateToFileRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WriteStateToFileRequest* internal_default_instance() {
    return reinterpret_cast<const WriteStateToFileRequest*>(
               &_WriteStateToFileRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(WriteStateToFileRequest& a, WriteStateToFileRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(WriteStateToFileRequest* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline WriteStateToFileRequest* New() const final {
    return CreateMaybeMessage<WriteStateToFileRequest>(nullptr);
  }

  WriteStateToFileRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<WriteStateToFileRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const WriteStateToFileRequest& from);
  void MergeFrom(const WriteStateToFileRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WriteStateToFileRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cartographer.cloud.proto.WriteStateToFileRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto);
    return ::descriptor_table_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFilenameFieldNumber = 1,
  };
  // string filename = 1;
  void clear_filename();
  const std::string& filename() const;
  void set_filename(const std::string& value);
  void set_filename(std::string&& value);
  void set_filename(const char* value);
  void set_filename(const char* value, size_t size);
  std::string* mutable_filename();
  std::string* release_filename();
  void set_allocated_filename(std::string* filename);
  private:
  const std::string& _internal_filename() const;
  void _internal_set_filename(const std::string& value);
  std::string* _internal_mutable_filename();
  public:

  // @@protoc_insertion_point(class_scope:cartographer.cloud.proto.WriteStateToFileRequest)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filename_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto;
};
// -------------------------------------------------------------------

class WriteStateToFileResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cartographer.cloud.proto.WriteStateToFileResponse) */ {
 public:
  WriteStateToFileResponse();
  virtual ~WriteStateToFileResponse();

  WriteStateToFileResponse(const WriteStateToFileResponse& from);
  WriteStateToFileResponse(WriteStateToFileResponse&& from) noexcept
    : WriteStateToFileResponse() {
    *this = ::std::move(from);
  }

  inline WriteStateToFileResponse& operator=(const WriteStateToFileResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline WriteStateToFileResponse& operator=(WriteStateToFileResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const WriteStateToFileResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WriteStateToFileResponse* internal_default_instance() {
    return reinterpret_cast<const WriteStateToFileResponse*>(
               &_WriteStateToFileResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(WriteStateToFileResponse& a, WriteStateToFileResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(WriteStateToFileResponse* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline WriteStateToFileResponse* New() const final {
    return CreateMaybeMessage<WriteStateToFileResponse>(nullptr);
  }

  WriteStateToFileResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<WriteStateToFileResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const WriteStateToFileResponse& from);
  void MergeFrom(const WriteStateToFileResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WriteStateToFileResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cartographer.cloud.proto.WriteStateToFileResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto);
    return ::descriptor_table_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 3,
    kSuccessFieldNumber = 1,
    kCodeFieldNumber = 2,
  };
  // string message = 3;
  void clear_message();
  const std::string& message() const;
  void set_message(const std::string& value);
  void set_message(std::string&& value);
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  std::string* mutable_message();
  std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // int32 code = 2;
  void clear_code();
  ::PROTOBUF_NAMESPACE_ID::int32 code() const;
  void set_code(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_code() const;
  void _internal_set_code(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:cartographer.cloud.proto.WriteStateToFileResponse)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  bool success_;
  ::PROTOBUF_NAMESPACE_ID::int32 code_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto;
};
// -------------------------------------------------------------------

class IsTrajectoryFinishedRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cartographer.cloud.proto.IsTrajectoryFinishedRequest) */ {
 public:
  IsTrajectoryFinishedRequest();
  virtual ~IsTrajectoryFinishedRequest();

  IsTrajectoryFinishedRequest(const IsTrajectoryFinishedRequest& from);
  IsTrajectoryFinishedRequest(IsTrajectoryFinishedRequest&& from) noexcept
    : IsTrajectoryFinishedRequest() {
    *this = ::std::move(from);
  }

  inline IsTrajectoryFinishedRequest& operator=(const IsTrajectoryFinishedRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline IsTrajectoryFinishedRequest& operator=(IsTrajectoryFinishedRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const IsTrajectoryFinishedRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IsTrajectoryFinishedRequest* internal_default_instance() {
    return reinterpret_cast<const IsTrajectoryFinishedRequest*>(
               &_IsTrajectoryFinishedRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  friend void swap(IsTrajectoryFinishedRequest& a, IsTrajectoryFinishedRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(IsTrajectoryFinishedRequest* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline IsTrajectoryFinishedRequest* New() const final {
    return CreateMaybeMessage<IsTrajectoryFinishedRequest>(nullptr);
  }

  IsTrajectoryFinishedRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<IsTrajectoryFinishedRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const IsTrajectoryFinishedRequest& from);
  void MergeFrom(const IsTrajectoryFinishedRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IsTrajectoryFinishedRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cartographer.cloud.proto.IsTrajectoryFinishedRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto);
    return ::descriptor_table_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTrajectoryIdFieldNumber = 1,
  };
  // int32 trajectory_id = 1;
  void clear_trajectory_id();
  ::PROTOBUF_NAMESPACE_ID::int32 trajectory_id() const;
  void set_trajectory_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_trajectory_id() const;
  void _internal_set_trajectory_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:cartographer.cloud.proto.IsTrajectoryFinishedRequest)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::int32 trajectory_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto;
};
// -------------------------------------------------------------------

class IsTrajectoryFinishedResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cartographer.cloud.proto.IsTrajectoryFinishedResponse) */ {
 public:
  IsTrajectoryFinishedResponse();
  virtual ~IsTrajectoryFinishedResponse();

  IsTrajectoryFinishedResponse(const IsTrajectoryFinishedResponse& from);
  IsTrajectoryFinishedResponse(IsTrajectoryFinishedResponse&& from) noexcept
    : IsTrajectoryFinishedResponse() {
    *this = ::std::move(from);
  }

  inline IsTrajectoryFinishedResponse& operator=(const IsTrajectoryFinishedResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline IsTrajectoryFinishedResponse& operator=(IsTrajectoryFinishedResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const IsTrajectoryFinishedResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IsTrajectoryFinishedResponse* internal_default_instance() {
    return reinterpret_cast<const IsTrajectoryFinishedResponse*>(
               &_IsTrajectoryFinishedResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  friend void swap(IsTrajectoryFinishedResponse& a, IsTrajectoryFinishedResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(IsTrajectoryFinishedResponse* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline IsTrajectoryFinishedResponse* New() const final {
    return CreateMaybeMessage<IsTrajectoryFinishedResponse>(nullptr);
  }

  IsTrajectoryFinishedResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<IsTrajectoryFinishedResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const IsTrajectoryFinishedResponse& from);
  void MergeFrom(const IsTrajectoryFinishedResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IsTrajectoryFinishedResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cartographer.cloud.proto.IsTrajectoryFinishedResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto);
    return ::descriptor_table_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIsFinishedFieldNumber = 1,
  };
  // bool is_finished = 1;
  void clear_is_finished();
  bool is_finished() const;
  void set_is_finished(bool value);
  private:
  bool _internal_is_finished() const;
  void _internal_set_is_finished(bool value);
  public:

  // @@protoc_insertion_point(class_scope:cartographer.cloud.proto.IsTrajectoryFinishedResponse)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  bool is_finished_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto;
};
// -------------------------------------------------------------------

class IsTrajectoryFrozenRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cartographer.cloud.proto.IsTrajectoryFrozenRequest) */ {
 public:
  IsTrajectoryFrozenRequest();
  virtual ~IsTrajectoryFrozenRequest();

  IsTrajectoryFrozenRequest(const IsTrajectoryFrozenRequest& from);
  IsTrajectoryFrozenRequest(IsTrajectoryFrozenRequest&& from) noexcept
    : IsTrajectoryFrozenRequest() {
    *this = ::std::move(from);
  }

  inline IsTrajectoryFrozenRequest& operator=(const IsTrajectoryFrozenRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline IsTrajectoryFrozenRequest& operator=(IsTrajectoryFrozenRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const IsTrajectoryFrozenRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IsTrajectoryFrozenRequest* internal_default_instance() {
    return reinterpret_cast<const IsTrajectoryFrozenRequest*>(
               &_IsTrajectoryFrozenRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  friend void swap(IsTrajectoryFrozenRequest& a, IsTrajectoryFrozenRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(IsTrajectoryFrozenRequest* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline IsTrajectoryFrozenRequest* New() const final {
    return CreateMaybeMessage<IsTrajectoryFrozenRequest>(nullptr);
  }

  IsTrajectoryFrozenRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<IsTrajectoryFrozenRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const IsTrajectoryFrozenRequest& from);
  void MergeFrom(const IsTrajectoryFrozenRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IsTrajectoryFrozenRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cartographer.cloud.proto.IsTrajectoryFrozenRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto);
    return ::descriptor_table_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTrajectoryIdFieldNumber = 1,
  };
  // int32 trajectory_id = 1;
  void clear_trajectory_id();
  ::PROTOBUF_NAMESPACE_ID::int32 trajectory_id() const;
  void set_trajectory_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_trajectory_id() const;
  void _internal_set_trajectory_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:cartographer.cloud.proto.IsTrajectoryFrozenRequest)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::int32 trajectory_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto;
};
// -------------------------------------------------------------------

class IsTrajectoryFrozenResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cartographer.cloud.proto.IsTrajectoryFrozenResponse) */ {
 public:
  IsTrajectoryFrozenResponse();
  virtual ~IsTrajectoryFrozenResponse();

  IsTrajectoryFrozenResponse(const IsTrajectoryFrozenResponse& from);
  IsTrajectoryFrozenResponse(IsTrajectoryFrozenResponse&& from) noexcept
    : IsTrajectoryFrozenResponse() {
    *this = ::std::move(from);
  }

  inline IsTrajectoryFrozenResponse& operator=(const IsTrajectoryFrozenResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline IsTrajectoryFrozenResponse& operator=(IsTrajectoryFrozenResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const IsTrajectoryFrozenResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IsTrajectoryFrozenResponse* internal_default_instance() {
    return reinterpret_cast<const IsTrajectoryFrozenResponse*>(
               &_IsTrajectoryFrozenResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  friend void swap(IsTrajectoryFrozenResponse& a, IsTrajectoryFrozenResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(IsTrajectoryFrozenResponse* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline IsTrajectoryFrozenResponse* New() const final {
    return CreateMaybeMessage<IsTrajectoryFrozenResponse>(nullptr);
  }

  IsTrajectoryFrozenResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<IsTrajectoryFrozenResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const IsTrajectoryFrozenResponse& from);
  void MergeFrom(const IsTrajectoryFrozenResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IsTrajectoryFrozenResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cartographer.cloud.proto.IsTrajectoryFrozenResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto);
    return ::descriptor_table_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIsFrozenFieldNumber = 1,
  };
  // bool is_frozen = 1;
  void clear_is_frozen();
  bool is_frozen() const;
  void set_is_frozen(bool value);
  private:
  bool _internal_is_frozen() const;
  void _internal_set_is_frozen(bool value);
  public:

  // @@protoc_insertion_point(class_scope:cartographer.cloud.proto.IsTrajectoryFrozenResponse)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  bool is_frozen_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto;
};
// -------------------------------------------------------------------

class OKagv_StartTrajectoryResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cartographer.cloud.proto.OKagv_StartTrajectoryResponse) */ {
 public:
  OKagv_StartTrajectoryResponse();
  virtual ~OKagv_StartTrajectoryResponse();

  OKagv_StartTrajectoryResponse(const OKagv_StartTrajectoryResponse& from);
  OKagv_StartTrajectoryResponse(OKagv_StartTrajectoryResponse&& from) noexcept
    : OKagv_StartTrajectoryResponse() {
    *this = ::std::move(from);
  }

  inline OKagv_StartTrajectoryResponse& operator=(const OKagv_StartTrajectoryResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline OKagv_StartTrajectoryResponse& operator=(OKagv_StartTrajectoryResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const OKagv_StartTrajectoryResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OKagv_StartTrajectoryResponse* internal_default_instance() {
    return reinterpret_cast<const OKagv_StartTrajectoryResponse*>(
               &_OKagv_StartTrajectoryResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    46;

  friend void swap(OKagv_StartTrajectoryResponse& a, OKagv_StartTrajectoryResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(OKagv_StartTrajectoryResponse* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline OKagv_StartTrajectoryResponse* New() const final {
    return CreateMaybeMessage<OKagv_StartTrajectoryResponse>(nullptr);
  }

  OKagv_StartTrajectoryResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<OKagv_StartTrajectoryResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const OKagv_StartTrajectoryResponse& from);
  void MergeFrom(const OKagv_StartTrajectoryResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OKagv_StartTrajectoryResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cartographer.cloud.proto.OKagv_StartTrajectoryResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto);
    return ::descriptor_table_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 3,
    kStateFieldNumber = 1,
    kCodeFieldNumber = 2,
  };
  // string message = 3;
  void clear_message();
  const std::string& message() const;
  void set_message(const std::string& value);
  void set_message(std::string&& value);
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  std::string* mutable_message();
  std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // bool state = 1;
  void clear_state();
  bool state() const;
  void set_state(bool value);
  private:
  bool _internal_state() const;
  void _internal_set_state(bool value);
  public:

  // int32 code = 2;
  void clear_code();
  ::PROTOBUF_NAMESPACE_ID::int32 code() const;
  void set_code(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_code() const;
  void _internal_set_code(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:cartographer.cloud.proto.OKagv_StartTrajectoryResponse)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  bool state_;
  ::PROTOBUF_NAMESPACE_ID::int32 code_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto;
};
// -------------------------------------------------------------------

class OKagv_FinishTrajectoryResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cartographer.cloud.proto.OKagv_FinishTrajectoryResponse) */ {
 public:
  OKagv_FinishTrajectoryResponse();
  virtual ~OKagv_FinishTrajectoryResponse();

  OKagv_FinishTrajectoryResponse(const OKagv_FinishTrajectoryResponse& from);
  OKagv_FinishTrajectoryResponse(OKagv_FinishTrajectoryResponse&& from) noexcept
    : OKagv_FinishTrajectoryResponse() {
    *this = ::std::move(from);
  }

  inline OKagv_FinishTrajectoryResponse& operator=(const OKagv_FinishTrajectoryResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline OKagv_FinishTrajectoryResponse& operator=(OKagv_FinishTrajectoryResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const OKagv_FinishTrajectoryResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OKagv_FinishTrajectoryResponse* internal_default_instance() {
    return reinterpret_cast<const OKagv_FinishTrajectoryResponse*>(
               &_OKagv_FinishTrajectoryResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    47;

  friend void swap(OKagv_FinishTrajectoryResponse& a, OKagv_FinishTrajectoryResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(OKagv_FinishTrajectoryResponse* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline OKagv_FinishTrajectoryResponse* New() const final {
    return CreateMaybeMessage<OKagv_FinishTrajectoryResponse>(nullptr);
  }

  OKagv_FinishTrajectoryResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<OKagv_FinishTrajectoryResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const OKagv_FinishTrajectoryResponse& from);
  void MergeFrom(const OKagv_FinishTrajectoryResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OKagv_FinishTrajectoryResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cartographer.cloud.proto.OKagv_FinishTrajectoryResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto);
    return ::descriptor_table_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStateFieldNumber = 1,
  };
  // bool state = 1;
  void clear_state();
  bool state() const;
  void set_state(bool value);
  private:
  bool _internal_state() const;
  void _internal_set_state(bool value);
  public:

  // @@protoc_insertion_point(class_scope:cartographer.cloud.proto.OKagv_FinishTrajectoryResponse)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  bool state_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto;
};
// -------------------------------------------------------------------

class OKagv_WaitTrajectoryResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cartographer.cloud.proto.OKagv_WaitTrajectoryResponse) */ {
 public:
  OKagv_WaitTrajectoryResponse();
  virtual ~OKagv_WaitTrajectoryResponse();

  OKagv_WaitTrajectoryResponse(const OKagv_WaitTrajectoryResponse& from);
  OKagv_WaitTrajectoryResponse(OKagv_WaitTrajectoryResponse&& from) noexcept
    : OKagv_WaitTrajectoryResponse() {
    *this = ::std::move(from);
  }

  inline OKagv_WaitTrajectoryResponse& operator=(const OKagv_WaitTrajectoryResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline OKagv_WaitTrajectoryResponse& operator=(OKagv_WaitTrajectoryResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const OKagv_WaitTrajectoryResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OKagv_WaitTrajectoryResponse* internal_default_instance() {
    return reinterpret_cast<const OKagv_WaitTrajectoryResponse*>(
               &_OKagv_WaitTrajectoryResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    48;

  friend void swap(OKagv_WaitTrajectoryResponse& a, OKagv_WaitTrajectoryResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(OKagv_WaitTrajectoryResponse* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline OKagv_WaitTrajectoryResponse* New() const final {
    return CreateMaybeMessage<OKagv_WaitTrajectoryResponse>(nullptr);
  }

  OKagv_WaitTrajectoryResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<OKagv_WaitTrajectoryResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const OKagv_WaitTrajectoryResponse& from);
  void MergeFrom(const OKagv_WaitTrajectoryResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OKagv_WaitTrajectoryResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cartographer.cloud.proto.OKagv_WaitTrajectoryResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto);
    return ::descriptor_table_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStateFieldNumber = 1,
  };
  // bool state = 1;
  void clear_state();
  bool state() const;
  void set_state(bool value);
  private:
  bool _internal_state() const;
  void _internal_set_state(bool value);
  public:

  // @@protoc_insertion_point(class_scope:cartographer.cloud.proto.OKagv_WaitTrajectoryResponse)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  bool state_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto;
};
// -------------------------------------------------------------------

class OKagv_GetOrderResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cartographer.cloud.proto.OKagv_GetOrderResponse) */ {
 public:
  OKagv_GetOrderResponse();
  virtual ~OKagv_GetOrderResponse();

  OKagv_GetOrderResponse(const OKagv_GetOrderResponse& from);
  OKagv_GetOrderResponse(OKagv_GetOrderResponse&& from) noexcept
    : OKagv_GetOrderResponse() {
    *this = ::std::move(from);
  }

  inline OKagv_GetOrderResponse& operator=(const OKagv_GetOrderResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline OKagv_GetOrderResponse& operator=(OKagv_GetOrderResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const OKagv_GetOrderResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OKagv_GetOrderResponse* internal_default_instance() {
    return reinterpret_cast<const OKagv_GetOrderResponse*>(
               &_OKagv_GetOrderResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    49;

  friend void swap(OKagv_GetOrderResponse& a, OKagv_GetOrderResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(OKagv_GetOrderResponse* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline OKagv_GetOrderResponse* New() const final {
    return CreateMaybeMessage<OKagv_GetOrderResponse>(nullptr);
  }

  OKagv_GetOrderResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<OKagv_GetOrderResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const OKagv_GetOrderResponse& from);
  void MergeFrom(const OKagv_GetOrderResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OKagv_GetOrderResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cartographer.cloud.proto.OKagv_GetOrderResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto);
    return ::descriptor_table_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrderTypeFieldNumber = 1,
  };
  // int32 order_type = 1;
  void clear_order_type();
  ::PROTOBUF_NAMESPACE_ID::int32 order_type() const;
  void set_order_type(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_order_type() const;
  void _internal_set_order_type(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:cartographer.cloud.proto.OKagv_GetOrderResponse)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::int32 order_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto;
};
// -------------------------------------------------------------------

class OKagv_LoadTrajectoryRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cartographer.cloud.proto.OKagv_LoadTrajectoryRequest) */ {
 public:
  OKagv_LoadTrajectoryRequest();
  virtual ~OKagv_LoadTrajectoryRequest();

  OKagv_LoadTrajectoryRequest(const OKagv_LoadTrajectoryRequest& from);
  OKagv_LoadTrajectoryRequest(OKagv_LoadTrajectoryRequest&& from) noexcept
    : OKagv_LoadTrajectoryRequest() {
    *this = ::std::move(from);
  }

  inline OKagv_LoadTrajectoryRequest& operator=(const OKagv_LoadTrajectoryRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline OKagv_LoadTrajectoryRequest& operator=(OKagv_LoadTrajectoryRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const OKagv_LoadTrajectoryRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OKagv_LoadTrajectoryRequest* internal_default_instance() {
    return reinterpret_cast<const OKagv_LoadTrajectoryRequest*>(
               &_OKagv_LoadTrajectoryRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    50;

  friend void swap(OKagv_LoadTrajectoryRequest& a, OKagv_LoadTrajectoryRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(OKagv_LoadTrajectoryRequest* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline OKagv_LoadTrajectoryRequest* New() const final {
    return CreateMaybeMessage<OKagv_LoadTrajectoryRequest>(nullptr);
  }

  OKagv_LoadTrajectoryRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<OKagv_LoadTrajectoryRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const OKagv_LoadTrajectoryRequest& from);
  void MergeFrom(const OKagv_LoadTrajectoryRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OKagv_LoadTrajectoryRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cartographer.cloud.proto.OKagv_LoadTrajectoryRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto);
    return ::descriptor_table_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFilenameFieldNumber = 1,
  };
  // string filename = 1;
  void clear_filename();
  const std::string& filename() const;
  void set_filename(const std::string& value);
  void set_filename(std::string&& value);
  void set_filename(const char* value);
  void set_filename(const char* value, size_t size);
  std::string* mutable_filename();
  std::string* release_filename();
  void set_allocated_filename(std::string* filename);
  private:
  const std::string& _internal_filename() const;
  void _internal_set_filename(const std::string& value);
  std::string* _internal_mutable_filename();
  public:

  // @@protoc_insertion_point(class_scope:cartographer.cloud.proto.OKagv_LoadTrajectoryRequest)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filename_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto;
};
// -------------------------------------------------------------------

class OKagv_LoadTrajectoryResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cartographer.cloud.proto.OKagv_LoadTrajectoryResponse) */ {
 public:
  OKagv_LoadTrajectoryResponse();
  virtual ~OKagv_LoadTrajectoryResponse();

  OKagv_LoadTrajectoryResponse(const OKagv_LoadTrajectoryResponse& from);
  OKagv_LoadTrajectoryResponse(OKagv_LoadTrajectoryResponse&& from) noexcept
    : OKagv_LoadTrajectoryResponse() {
    *this = ::std::move(from);
  }

  inline OKagv_LoadTrajectoryResponse& operator=(const OKagv_LoadTrajectoryResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline OKagv_LoadTrajectoryResponse& operator=(OKagv_LoadTrajectoryResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const OKagv_LoadTrajectoryResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OKagv_LoadTrajectoryResponse* internal_default_instance() {
    return reinterpret_cast<const OKagv_LoadTrajectoryResponse*>(
               &_OKagv_LoadTrajectoryResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    51;

  friend void swap(OKagv_LoadTrajectoryResponse& a, OKagv_LoadTrajectoryResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(OKagv_LoadTrajectoryResponse* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline OKagv_LoadTrajectoryResponse* New() const final {
    return CreateMaybeMessage<OKagv_LoadTrajectoryResponse>(nullptr);
  }

  OKagv_LoadTrajectoryResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<OKagv_LoadTrajectoryResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const OKagv_LoadTrajectoryResponse& from);
  void MergeFrom(const OKagv_LoadTrajectoryResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OKagv_LoadTrajectoryResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cartographer.cloud.proto.OKagv_LoadTrajectoryResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto);
    return ::descriptor_table_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStateFieldNumber = 1,
  };
  // bool state = 1;
  void clear_state();
  bool state() const;
  void set_state(bool value);
  private:
  bool _internal_state() const;
  void _internal_set_state(bool value);
  public:

  // @@protoc_insertion_point(class_scope:cartographer.cloud.proto.OKagv_LoadTrajectoryResponse)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  bool state_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto;
};
// -------------------------------------------------------------------

class OKagv_LocalizeTrajectoryRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cartographer.cloud.proto.OKagv_LocalizeTrajectoryRequest) */ {
 public:
  OKagv_LocalizeTrajectoryRequest();
  virtual ~OKagv_LocalizeTrajectoryRequest();

  OKagv_LocalizeTrajectoryRequest(const OKagv_LocalizeTrajectoryRequest& from);
  OKagv_LocalizeTrajectoryRequest(OKagv_LocalizeTrajectoryRequest&& from) noexcept
    : OKagv_LocalizeTrajectoryRequest() {
    *this = ::std::move(from);
  }

  inline OKagv_LocalizeTrajectoryRequest& operator=(const OKagv_LocalizeTrajectoryRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline OKagv_LocalizeTrajectoryRequest& operator=(OKagv_LocalizeTrajectoryRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const OKagv_LocalizeTrajectoryRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OKagv_LocalizeTrajectoryRequest* internal_default_instance() {
    return reinterpret_cast<const OKagv_LocalizeTrajectoryRequest*>(
               &_OKagv_LocalizeTrajectoryRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    52;

  friend void swap(OKagv_LocalizeTrajectoryRequest& a, OKagv_LocalizeTrajectoryRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(OKagv_LocalizeTrajectoryRequest* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline OKagv_LocalizeTrajectoryRequest* New() const final {
    return CreateMaybeMessage<OKagv_LocalizeTrajectoryRequest>(nullptr);
  }

  OKagv_LocalizeTrajectoryRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<OKagv_LocalizeTrajectoryRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const OKagv_LocalizeTrajectoryRequest& from);
  void MergeFrom(const OKagv_LocalizeTrajectoryRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OKagv_LocalizeTrajectoryRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cartographer.cloud.proto.OKagv_LocalizeTrajectoryRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto);
    return ::descriptor_table_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInitialPoseFieldNumber = 2,
    kUseInitialPoseFieldNumber = 1,
  };
  // .cartographer.transform.proto.Rigid3d initial_pose = 2;
  bool has_initial_pose() const;
  private:
  bool _internal_has_initial_pose() const;
  public:
  void clear_initial_pose();
  const ::cartographer::transform::proto::Rigid3d& initial_pose() const;
  ::cartographer::transform::proto::Rigid3d* release_initial_pose();
  ::cartographer::transform::proto::Rigid3d* mutable_initial_pose();
  void set_allocated_initial_pose(::cartographer::transform::proto::Rigid3d* initial_pose);
  private:
  const ::cartographer::transform::proto::Rigid3d& _internal_initial_pose() const;
  ::cartographer::transform::proto::Rigid3d* _internal_mutable_initial_pose();
  public:

  // bool use_initial_pose = 1;
  void clear_use_initial_pose();
  bool use_initial_pose() const;
  void set_use_initial_pose(bool value);
  private:
  bool _internal_use_initial_pose() const;
  void _internal_set_use_initial_pose(bool value);
  public:

  // @@protoc_insertion_point(class_scope:cartographer.cloud.proto.OKagv_LocalizeTrajectoryRequest)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::cartographer::transform::proto::Rigid3d* initial_pose_;
  bool use_initial_pose_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto;
};
// -------------------------------------------------------------------

class OKagv_LocalizeTrajectoryResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cartographer.cloud.proto.OKagv_LocalizeTrajectoryResponse) */ {
 public:
  OKagv_LocalizeTrajectoryResponse();
  virtual ~OKagv_LocalizeTrajectoryResponse();

  OKagv_LocalizeTrajectoryResponse(const OKagv_LocalizeTrajectoryResponse& from);
  OKagv_LocalizeTrajectoryResponse(OKagv_LocalizeTrajectoryResponse&& from) noexcept
    : OKagv_LocalizeTrajectoryResponse() {
    *this = ::std::move(from);
  }

  inline OKagv_LocalizeTrajectoryResponse& operator=(const OKagv_LocalizeTrajectoryResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline OKagv_LocalizeTrajectoryResponse& operator=(OKagv_LocalizeTrajectoryResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const OKagv_LocalizeTrajectoryResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OKagv_LocalizeTrajectoryResponse* internal_default_instance() {
    return reinterpret_cast<const OKagv_LocalizeTrajectoryResponse*>(
               &_OKagv_LocalizeTrajectoryResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    53;

  friend void swap(OKagv_LocalizeTrajectoryResponse& a, OKagv_LocalizeTrajectoryResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(OKagv_LocalizeTrajectoryResponse* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline OKagv_LocalizeTrajectoryResponse* New() const final {
    return CreateMaybeMessage<OKagv_LocalizeTrajectoryResponse>(nullptr);
  }

  OKagv_LocalizeTrajectoryResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<OKagv_LocalizeTrajectoryResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const OKagv_LocalizeTrajectoryResponse& from);
  void MergeFrom(const OKagv_LocalizeTrajectoryResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OKagv_LocalizeTrajectoryResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cartographer.cloud.proto.OKagv_LocalizeTrajectoryResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto);
    return ::descriptor_table_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStateFieldNumber = 1,
    kConfidenceScoreFieldNumber = 2,
  };
  // bool state = 1;
  void clear_state();
  bool state() const;
  void set_state(bool value);
  private:
  bool _internal_state() const;
  void _internal_set_state(bool value);
  public:

  // int32 confidence_score = 2;
  void clear_confidence_score();
  ::PROTOBUF_NAMESPACE_ID::int32 confidence_score() const;
  void set_confidence_score(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_confidence_score() const;
  void _internal_set_confidence_score(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:cartographer.cloud.proto.OKagv_LocalizeTrajectoryResponse)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  bool state_;
  ::PROTOBUF_NAMESPACE_ID::int32 confidence_score_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto;
};
// -------------------------------------------------------------------

class OKagv_StartTrajectoryRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cartographer.cloud.proto.OKagv_StartTrajectoryRequest) */ {
 public:
  OKagv_StartTrajectoryRequest();
  virtual ~OKagv_StartTrajectoryRequest();

  OKagv_StartTrajectoryRequest(const OKagv_StartTrajectoryRequest& from);
  OKagv_StartTrajectoryRequest(OKagv_StartTrajectoryRequest&& from) noexcept
    : OKagv_StartTrajectoryRequest() {
    *this = ::std::move(from);
  }

  inline OKagv_StartTrajectoryRequest& operator=(const OKagv_StartTrajectoryRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline OKagv_StartTrajectoryRequest& operator=(OKagv_StartTrajectoryRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const OKagv_StartTrajectoryRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OKagv_StartTrajectoryRequest* internal_default_instance() {
    return reinterpret_cast<const OKagv_StartTrajectoryRequest*>(
               &_OKagv_StartTrajectoryRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    54;

  friend void swap(OKagv_StartTrajectoryRequest& a, OKagv_StartTrajectoryRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(OKagv_StartTrajectoryRequest* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline OKagv_StartTrajectoryRequest* New() const final {
    return CreateMaybeMessage<OKagv_StartTrajectoryRequest>(nullptr);
  }

  OKagv_StartTrajectoryRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<OKagv_StartTrajectoryRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const OKagv_StartTrajectoryRequest& from);
  void MergeFrom(const OKagv_StartTrajectoryRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OKagv_StartTrajectoryRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cartographer.cloud.proto.OKagv_StartTrajectoryRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto);
    return ::descriptor_table_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTrajectoryTypeFieldNumber = 1,
    kTrajectoryIdFieldNumber = 2,
    kRelativeToTrajectoryIdFieldNumber = 5,
    kInitialPoseFieldNumber = 4,
    kUseInitialPoseFieldNumber = 3,
  };
  // string trajectory_type = 1;
  void clear_trajectory_type();
  const std::string& trajectory_type() const;
  void set_trajectory_type(const std::string& value);
  void set_trajectory_type(std::string&& value);
  void set_trajectory_type(const char* value);
  void set_trajectory_type(const char* value, size_t size);
  std::string* mutable_trajectory_type();
  std::string* release_trajectory_type();
  void set_allocated_trajectory_type(std::string* trajectory_type);
  private:
  const std::string& _internal_trajectory_type() const;
  void _internal_set_trajectory_type(const std::string& value);
  std::string* _internal_mutable_trajectory_type();
  public:

  // string trajectory_id = 2;
  void clear_trajectory_id();
  const std::string& trajectory_id() const;
  void set_trajectory_id(const std::string& value);
  void set_trajectory_id(std::string&& value);
  void set_trajectory_id(const char* value);
  void set_trajectory_id(const char* value, size_t size);
  std::string* mutable_trajectory_id();
  std::string* release_trajectory_id();
  void set_allocated_trajectory_id(std::string* trajectory_id);
  private:
  const std::string& _internal_trajectory_id() const;
  void _internal_set_trajectory_id(const std::string& value);
  std::string* _internal_mutable_trajectory_id();
  public:

  // string relative_to_trajectory_id = 5;
  void clear_relative_to_trajectory_id();
  const std::string& relative_to_trajectory_id() const;
  void set_relative_to_trajectory_id(const std::string& value);
  void set_relative_to_trajectory_id(std::string&& value);
  void set_relative_to_trajectory_id(const char* value);
  void set_relative_to_trajectory_id(const char* value, size_t size);
  std::string* mutable_relative_to_trajectory_id();
  std::string* release_relative_to_trajectory_id();
  void set_allocated_relative_to_trajectory_id(std::string* relative_to_trajectory_id);
  private:
  const std::string& _internal_relative_to_trajectory_id() const;
  void _internal_set_relative_to_trajectory_id(const std::string& value);
  std::string* _internal_mutable_relative_to_trajectory_id();
  public:

  // .cartographer.transform.proto.Rigid3d initial_pose = 4;
  bool has_initial_pose() const;
  private:
  bool _internal_has_initial_pose() const;
  public:
  void clear_initial_pose();
  const ::cartographer::transform::proto::Rigid3d& initial_pose() const;
  ::cartographer::transform::proto::Rigid3d* release_initial_pose();
  ::cartographer::transform::proto::Rigid3d* mutable_initial_pose();
  void set_allocated_initial_pose(::cartographer::transform::proto::Rigid3d* initial_pose);
  private:
  const ::cartographer::transform::proto::Rigid3d& _internal_initial_pose() const;
  ::cartographer::transform::proto::Rigid3d* _internal_mutable_initial_pose();
  public:

  // bool use_initial_pose = 3;
  void clear_use_initial_pose();
  bool use_initial_pose() const;
  void set_use_initial_pose(bool value);
  private:
  bool _internal_use_initial_pose() const;
  void _internal_set_use_initial_pose(bool value);
  public:

  // @@protoc_insertion_point(class_scope:cartographer.cloud.proto.OKagv_StartTrajectoryRequest)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr trajectory_type_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr trajectory_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr relative_to_trajectory_id_;
  ::cartographer::transform::proto::Rigid3d* initial_pose_;
  bool use_initial_pose_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto;
};
// -------------------------------------------------------------------

class OKagv_SaveTrajectoryRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cartographer.cloud.proto.OKagv_SaveTrajectoryRequest) */ {
 public:
  OKagv_SaveTrajectoryRequest();
  virtual ~OKagv_SaveTrajectoryRequest();

  OKagv_SaveTrajectoryRequest(const OKagv_SaveTrajectoryRequest& from);
  OKagv_SaveTrajectoryRequest(OKagv_SaveTrajectoryRequest&& from) noexcept
    : OKagv_SaveTrajectoryRequest() {
    *this = ::std::move(from);
  }

  inline OKagv_SaveTrajectoryRequest& operator=(const OKagv_SaveTrajectoryRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline OKagv_SaveTrajectoryRequest& operator=(OKagv_SaveTrajectoryRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const OKagv_SaveTrajectoryRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OKagv_SaveTrajectoryRequest* internal_default_instance() {
    return reinterpret_cast<const OKagv_SaveTrajectoryRequest*>(
               &_OKagv_SaveTrajectoryRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    55;

  friend void swap(OKagv_SaveTrajectoryRequest& a, OKagv_SaveTrajectoryRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(OKagv_SaveTrajectoryRequest* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline OKagv_SaveTrajectoryRequest* New() const final {
    return CreateMaybeMessage<OKagv_SaveTrajectoryRequest>(nullptr);
  }

  OKagv_SaveTrajectoryRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<OKagv_SaveTrajectoryRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const OKagv_SaveTrajectoryRequest& from);
  void MergeFrom(const OKagv_SaveTrajectoryRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OKagv_SaveTrajectoryRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cartographer.cloud.proto.OKagv_SaveTrajectoryRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto);
    return ::descriptor_table_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFilenameFieldNumber = 1,
    kIncludeUnfinishedSubmapsFieldNumber = 2,
  };
  // string filename = 1;
  void clear_filename();
  const std::string& filename() const;
  void set_filename(const std::string& value);
  void set_filename(std::string&& value);
  void set_filename(const char* value);
  void set_filename(const char* value, size_t size);
  std::string* mutable_filename();
  std::string* release_filename();
  void set_allocated_filename(std::string* filename);
  private:
  const std::string& _internal_filename() const;
  void _internal_set_filename(const std::string& value);
  std::string* _internal_mutable_filename();
  public:

  // bool include_unfinished_submaps = 2;
  void clear_include_unfinished_submaps();
  bool include_unfinished_submaps() const;
  void set_include_unfinished_submaps(bool value);
  private:
  bool _internal_include_unfinished_submaps() const;
  void _internal_set_include_unfinished_submaps(bool value);
  public:

  // @@protoc_insertion_point(class_scope:cartographer.cloud.proto.OKagv_SaveTrajectoryRequest)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filename_;
  bool include_unfinished_submaps_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto;
};
// -------------------------------------------------------------------

class OKagv_GetTrajectoryStateResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cartographer.cloud.proto.OKagv_GetTrajectoryStateResponse) */ {
 public:
  OKagv_GetTrajectoryStateResponse();
  virtual ~OKagv_GetTrajectoryStateResponse();

  OKagv_GetTrajectoryStateResponse(const OKagv_GetTrajectoryStateResponse& from);
  OKagv_GetTrajectoryStateResponse(OKagv_GetTrajectoryStateResponse&& from) noexcept
    : OKagv_GetTrajectoryStateResponse() {
    *this = ::std::move(from);
  }

  inline OKagv_GetTrajectoryStateResponse& operator=(const OKagv_GetTrajectoryStateResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline OKagv_GetTrajectoryStateResponse& operator=(OKagv_GetTrajectoryStateResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const OKagv_GetTrajectoryStateResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OKagv_GetTrajectoryStateResponse* internal_default_instance() {
    return reinterpret_cast<const OKagv_GetTrajectoryStateResponse*>(
               &_OKagv_GetTrajectoryStateResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    56;

  friend void swap(OKagv_GetTrajectoryStateResponse& a, OKagv_GetTrajectoryStateResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(OKagv_GetTrajectoryStateResponse* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline OKagv_GetTrajectoryStateResponse* New() const final {
    return CreateMaybeMessage<OKagv_GetTrajectoryStateResponse>(nullptr);
  }

  OKagv_GetTrajectoryStateResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<OKagv_GetTrajectoryStateResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const OKagv_GetTrajectoryStateResponse& from);
  void MergeFrom(const OKagv_GetTrajectoryStateResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OKagv_GetTrajectoryStateResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cartographer.cloud.proto.OKagv_GetTrajectoryStateResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto);
    return ::descriptor_table_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 2,
    kCodeFieldNumber = 1,
  };
  // string message = 2;
  void clear_message();
  const std::string& message() const;
  void set_message(const std::string& value);
  void set_message(std::string&& value);
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  std::string* mutable_message();
  std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // int32 code = 1;
  void clear_code();
  ::PROTOBUF_NAMESPACE_ID::int32 code() const;
  void set_code(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_code() const;
  void _internal_set_code(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:cartographer.cloud.proto.OKagv_GetTrajectoryStateResponse)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  ::PROTOBUF_NAMESPACE_ID::int32 code_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// SensorId

// string id = 1;
inline void SensorId::clear_id() {
  id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& SensorId::id() const {
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.SensorId.id)
  return _internal_id();
}
inline void SensorId::set_id(const std::string& value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:cartographer.cloud.proto.SensorId.id)
}
inline std::string* SensorId::mutable_id() {
  // @@protoc_insertion_point(field_mutable:cartographer.cloud.proto.SensorId.id)
  return _internal_mutable_id();
}
inline const std::string& SensorId::_internal_id() const {
  return id_.GetNoArena();
}
inline void SensorId::_internal_set_id(const std::string& value) {
  
  id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void SensorId::set_id(std::string&& value) {
  
  id_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cartographer.cloud.proto.SensorId.id)
}
inline void SensorId::set_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cartographer.cloud.proto.SensorId.id)
}
inline void SensorId::set_id(const char* value, size_t size) {
  
  id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cartographer.cloud.proto.SensorId.id)
}
inline std::string* SensorId::_internal_mutable_id() {
  
  return id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* SensorId::release_id() {
  // @@protoc_insertion_point(field_release:cartographer.cloud.proto.SensorId.id)
  
  return id_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void SensorId::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:cartographer.cloud.proto.SensorId.id)
}

// .cartographer.cloud.proto.SensorType type = 2;
inline void SensorId::clear_type() {
  type_ = 0;
}
inline ::cartographer::cloud::proto::SensorType SensorId::_internal_type() const {
  return static_cast< ::cartographer::cloud::proto::SensorType >(type_);
}
inline ::cartographer::cloud::proto::SensorType SensorId::type() const {
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.SensorId.type)
  return _internal_type();
}
inline void SensorId::_internal_set_type(::cartographer::cloud::proto::SensorType value) {
  
  type_ = value;
}
inline void SensorId::set_type(::cartographer::cloud::proto::SensorType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:cartographer.cloud.proto.SensorId.type)
}

// -------------------------------------------------------------------

// AddTrajectoryRequest

// repeated .cartographer.cloud.proto.SensorId expected_sensor_ids = 3;
inline int AddTrajectoryRequest::_internal_expected_sensor_ids_size() const {
  return expected_sensor_ids_.size();
}
inline int AddTrajectoryRequest::expected_sensor_ids_size() const {
  return _internal_expected_sensor_ids_size();
}
inline void AddTrajectoryRequest::clear_expected_sensor_ids() {
  expected_sensor_ids_.Clear();
}
inline ::cartographer::cloud::proto::SensorId* AddTrajectoryRequest::mutable_expected_sensor_ids(int index) {
  // @@protoc_insertion_point(field_mutable:cartographer.cloud.proto.AddTrajectoryRequest.expected_sensor_ids)
  return expected_sensor_ids_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cartographer::cloud::proto::SensorId >*
AddTrajectoryRequest::mutable_expected_sensor_ids() {
  // @@protoc_insertion_point(field_mutable_list:cartographer.cloud.proto.AddTrajectoryRequest.expected_sensor_ids)
  return &expected_sensor_ids_;
}
inline const ::cartographer::cloud::proto::SensorId& AddTrajectoryRequest::_internal_expected_sensor_ids(int index) const {
  return expected_sensor_ids_.Get(index);
}
inline const ::cartographer::cloud::proto::SensorId& AddTrajectoryRequest::expected_sensor_ids(int index) const {
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.AddTrajectoryRequest.expected_sensor_ids)
  return _internal_expected_sensor_ids(index);
}
inline ::cartographer::cloud::proto::SensorId* AddTrajectoryRequest::_internal_add_expected_sensor_ids() {
  return expected_sensor_ids_.Add();
}
inline ::cartographer::cloud::proto::SensorId* AddTrajectoryRequest::add_expected_sensor_ids() {
  // @@protoc_insertion_point(field_add:cartographer.cloud.proto.AddTrajectoryRequest.expected_sensor_ids)
  return _internal_add_expected_sensor_ids();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cartographer::cloud::proto::SensorId >&
AddTrajectoryRequest::expected_sensor_ids() const {
  // @@protoc_insertion_point(field_list:cartographer.cloud.proto.AddTrajectoryRequest.expected_sensor_ids)
  return expected_sensor_ids_;
}

// .cartographer.mapping.proto.TrajectoryBuilderOptions trajectory_builder_options = 2;
inline bool AddTrajectoryRequest::_internal_has_trajectory_builder_options() const {
  return this != internal_default_instance() && trajectory_builder_options_ != nullptr;
}
inline bool AddTrajectoryRequest::has_trajectory_builder_options() const {
  return _internal_has_trajectory_builder_options();
}
inline const ::cartographer::mapping::proto::TrajectoryBuilderOptions& AddTrajectoryRequest::_internal_trajectory_builder_options() const {
  const ::cartographer::mapping::proto::TrajectoryBuilderOptions* p = trajectory_builder_options_;
  return p != nullptr ? *p : *reinterpret_cast<const ::cartographer::mapping::proto::TrajectoryBuilderOptions*>(
      &::cartographer::mapping::proto::_TrajectoryBuilderOptions_default_instance_);
}
inline const ::cartographer::mapping::proto::TrajectoryBuilderOptions& AddTrajectoryRequest::trajectory_builder_options() const {
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.AddTrajectoryRequest.trajectory_builder_options)
  return _internal_trajectory_builder_options();
}
inline ::cartographer::mapping::proto::TrajectoryBuilderOptions* AddTrajectoryRequest::release_trajectory_builder_options() {
  // @@protoc_insertion_point(field_release:cartographer.cloud.proto.AddTrajectoryRequest.trajectory_builder_options)
  
  ::cartographer::mapping::proto::TrajectoryBuilderOptions* temp = trajectory_builder_options_;
  trajectory_builder_options_ = nullptr;
  return temp;
}
inline ::cartographer::mapping::proto::TrajectoryBuilderOptions* AddTrajectoryRequest::_internal_mutable_trajectory_builder_options() {
  
  if (trajectory_builder_options_ == nullptr) {
    auto* p = CreateMaybeMessage<::cartographer::mapping::proto::TrajectoryBuilderOptions>(GetArenaNoVirtual());
    trajectory_builder_options_ = p;
  }
  return trajectory_builder_options_;
}
inline ::cartographer::mapping::proto::TrajectoryBuilderOptions* AddTrajectoryRequest::mutable_trajectory_builder_options() {
  // @@protoc_insertion_point(field_mutable:cartographer.cloud.proto.AddTrajectoryRequest.trajectory_builder_options)
  return _internal_mutable_trajectory_builder_options();
}
inline void AddTrajectoryRequest::set_allocated_trajectory_builder_options(::cartographer::mapping::proto::TrajectoryBuilderOptions* trajectory_builder_options) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(trajectory_builder_options_);
  }
  if (trajectory_builder_options) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      trajectory_builder_options = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, trajectory_builder_options, submessage_arena);
    }
    
  } else {
    
  }
  trajectory_builder_options_ = trajectory_builder_options;
  // @@protoc_insertion_point(field_set_allocated:cartographer.cloud.proto.AddTrajectoryRequest.trajectory_builder_options)
}

// string client_id = 4;
inline void AddTrajectoryRequest::clear_client_id() {
  client_id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& AddTrajectoryRequest::client_id() const {
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.AddTrajectoryRequest.client_id)
  return _internal_client_id();
}
inline void AddTrajectoryRequest::set_client_id(const std::string& value) {
  _internal_set_client_id(value);
  // @@protoc_insertion_point(field_set:cartographer.cloud.proto.AddTrajectoryRequest.client_id)
}
inline std::string* AddTrajectoryRequest::mutable_client_id() {
  // @@protoc_insertion_point(field_mutable:cartographer.cloud.proto.AddTrajectoryRequest.client_id)
  return _internal_mutable_client_id();
}
inline const std::string& AddTrajectoryRequest::_internal_client_id() const {
  return client_id_.GetNoArena();
}
inline void AddTrajectoryRequest::_internal_set_client_id(const std::string& value) {
  
  client_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void AddTrajectoryRequest::set_client_id(std::string&& value) {
  
  client_id_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cartographer.cloud.proto.AddTrajectoryRequest.client_id)
}
inline void AddTrajectoryRequest::set_client_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  client_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cartographer.cloud.proto.AddTrajectoryRequest.client_id)
}
inline void AddTrajectoryRequest::set_client_id(const char* value, size_t size) {
  
  client_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cartographer.cloud.proto.AddTrajectoryRequest.client_id)
}
inline std::string* AddTrajectoryRequest::_internal_mutable_client_id() {
  
  return client_id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* AddTrajectoryRequest::release_client_id() {
  // @@protoc_insertion_point(field_release:cartographer.cloud.proto.AddTrajectoryRequest.client_id)
  
  return client_id_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void AddTrajectoryRequest::set_allocated_client_id(std::string* client_id) {
  if (client_id != nullptr) {
    
  } else {
    
  }
  client_id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), client_id);
  // @@protoc_insertion_point(field_set_allocated:cartographer.cloud.proto.AddTrajectoryRequest.client_id)
}

// -------------------------------------------------------------------

// SensorMetadata

// int32 trajectory_id = 1;
inline void SensorMetadata::clear_trajectory_id() {
  trajectory_id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SensorMetadata::_internal_trajectory_id() const {
  return trajectory_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SensorMetadata::trajectory_id() const {
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.SensorMetadata.trajectory_id)
  return _internal_trajectory_id();
}
inline void SensorMetadata::_internal_set_trajectory_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  trajectory_id_ = value;
}
inline void SensorMetadata::set_trajectory_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_trajectory_id(value);
  // @@protoc_insertion_point(field_set:cartographer.cloud.proto.SensorMetadata.trajectory_id)
}

// string sensor_id = 2;
inline void SensorMetadata::clear_sensor_id() {
  sensor_id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& SensorMetadata::sensor_id() const {
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.SensorMetadata.sensor_id)
  return _internal_sensor_id();
}
inline void SensorMetadata::set_sensor_id(const std::string& value) {
  _internal_set_sensor_id(value);
  // @@protoc_insertion_point(field_set:cartographer.cloud.proto.SensorMetadata.sensor_id)
}
inline std::string* SensorMetadata::mutable_sensor_id() {
  // @@protoc_insertion_point(field_mutable:cartographer.cloud.proto.SensorMetadata.sensor_id)
  return _internal_mutable_sensor_id();
}
inline const std::string& SensorMetadata::_internal_sensor_id() const {
  return sensor_id_.GetNoArena();
}
inline void SensorMetadata::_internal_set_sensor_id(const std::string& value) {
  
  sensor_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void SensorMetadata::set_sensor_id(std::string&& value) {
  
  sensor_id_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cartographer.cloud.proto.SensorMetadata.sensor_id)
}
inline void SensorMetadata::set_sensor_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  sensor_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cartographer.cloud.proto.SensorMetadata.sensor_id)
}
inline void SensorMetadata::set_sensor_id(const char* value, size_t size) {
  
  sensor_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cartographer.cloud.proto.SensorMetadata.sensor_id)
}
inline std::string* SensorMetadata::_internal_mutable_sensor_id() {
  
  return sensor_id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* SensorMetadata::release_sensor_id() {
  // @@protoc_insertion_point(field_release:cartographer.cloud.proto.SensorMetadata.sensor_id)
  
  return sensor_id_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void SensorMetadata::set_allocated_sensor_id(std::string* sensor_id) {
  if (sensor_id != nullptr) {
    
  } else {
    
  }
  sensor_id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sensor_id);
  // @@protoc_insertion_point(field_set_allocated:cartographer.cloud.proto.SensorMetadata.sensor_id)
}

// string client_id = 3;
inline void SensorMetadata::clear_client_id() {
  client_id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& SensorMetadata::client_id() const {
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.SensorMetadata.client_id)
  return _internal_client_id();
}
inline void SensorMetadata::set_client_id(const std::string& value) {
  _internal_set_client_id(value);
  // @@protoc_insertion_point(field_set:cartographer.cloud.proto.SensorMetadata.client_id)
}
inline std::string* SensorMetadata::mutable_client_id() {
  // @@protoc_insertion_point(field_mutable:cartographer.cloud.proto.SensorMetadata.client_id)
  return _internal_mutable_client_id();
}
inline const std::string& SensorMetadata::_internal_client_id() const {
  return client_id_.GetNoArena();
}
inline void SensorMetadata::_internal_set_client_id(const std::string& value) {
  
  client_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void SensorMetadata::set_client_id(std::string&& value) {
  
  client_id_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cartographer.cloud.proto.SensorMetadata.client_id)
}
inline void SensorMetadata::set_client_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  client_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cartographer.cloud.proto.SensorMetadata.client_id)
}
inline void SensorMetadata::set_client_id(const char* value, size_t size) {
  
  client_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cartographer.cloud.proto.SensorMetadata.client_id)
}
inline std::string* SensorMetadata::_internal_mutable_client_id() {
  
  return client_id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* SensorMetadata::release_client_id() {
  // @@protoc_insertion_point(field_release:cartographer.cloud.proto.SensorMetadata.client_id)
  
  return client_id_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void SensorMetadata::set_allocated_client_id(std::string* client_id) {
  if (client_id != nullptr) {
    
  } else {
    
  }
  client_id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), client_id);
  // @@protoc_insertion_point(field_set_allocated:cartographer.cloud.proto.SensorMetadata.client_id)
}

// -------------------------------------------------------------------

// SensorData

// .cartographer.cloud.proto.SensorMetadata sensor_metadata = 1;
inline bool SensorData::_internal_has_sensor_metadata() const {
  return this != internal_default_instance() && sensor_metadata_ != nullptr;
}
inline bool SensorData::has_sensor_metadata() const {
  return _internal_has_sensor_metadata();
}
inline void SensorData::clear_sensor_metadata() {
  if (GetArenaNoVirtual() == nullptr && sensor_metadata_ != nullptr) {
    delete sensor_metadata_;
  }
  sensor_metadata_ = nullptr;
}
inline const ::cartographer::cloud::proto::SensorMetadata& SensorData::_internal_sensor_metadata() const {
  const ::cartographer::cloud::proto::SensorMetadata* p = sensor_metadata_;
  return p != nullptr ? *p : *reinterpret_cast<const ::cartographer::cloud::proto::SensorMetadata*>(
      &::cartographer::cloud::proto::_SensorMetadata_default_instance_);
}
inline const ::cartographer::cloud::proto::SensorMetadata& SensorData::sensor_metadata() const {
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.SensorData.sensor_metadata)
  return _internal_sensor_metadata();
}
inline ::cartographer::cloud::proto::SensorMetadata* SensorData::release_sensor_metadata() {
  // @@protoc_insertion_point(field_release:cartographer.cloud.proto.SensorData.sensor_metadata)
  
  ::cartographer::cloud::proto::SensorMetadata* temp = sensor_metadata_;
  sensor_metadata_ = nullptr;
  return temp;
}
inline ::cartographer::cloud::proto::SensorMetadata* SensorData::_internal_mutable_sensor_metadata() {
  
  if (sensor_metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::cartographer::cloud::proto::SensorMetadata>(GetArenaNoVirtual());
    sensor_metadata_ = p;
  }
  return sensor_metadata_;
}
inline ::cartographer::cloud::proto::SensorMetadata* SensorData::mutable_sensor_metadata() {
  // @@protoc_insertion_point(field_mutable:cartographer.cloud.proto.SensorData.sensor_metadata)
  return _internal_mutable_sensor_metadata();
}
inline void SensorData::set_allocated_sensor_metadata(::cartographer::cloud::proto::SensorMetadata* sensor_metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete sensor_metadata_;
  }
  if (sensor_metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      sensor_metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sensor_metadata, submessage_arena);
    }
    
  } else {
    
  }
  sensor_metadata_ = sensor_metadata;
  // @@protoc_insertion_point(field_set_allocated:cartographer.cloud.proto.SensorData.sensor_metadata)
}

// .cartographer.sensor.proto.OdometryData odometry_data = 2;
inline bool SensorData::_internal_has_odometry_data() const {
  return sensor_data_case() == kOdometryData;
}
inline bool SensorData::has_odometry_data() const {
  return _internal_has_odometry_data();
}
inline void SensorData::set_has_odometry_data() {
  _oneof_case_[0] = kOdometryData;
}
inline ::cartographer::sensor::proto::OdometryData* SensorData::release_odometry_data() {
  // @@protoc_insertion_point(field_release:cartographer.cloud.proto.SensorData.odometry_data)
  if (_internal_has_odometry_data()) {
    clear_has_sensor_data();
      ::cartographer::sensor::proto::OdometryData* temp = sensor_data_.odometry_data_;
    sensor_data_.odometry_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cartographer::sensor::proto::OdometryData& SensorData::_internal_odometry_data() const {
  return _internal_has_odometry_data()
      ? *sensor_data_.odometry_data_
      : *reinterpret_cast< ::cartographer::sensor::proto::OdometryData*>(&::cartographer::sensor::proto::_OdometryData_default_instance_);
}
inline const ::cartographer::sensor::proto::OdometryData& SensorData::odometry_data() const {
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.SensorData.odometry_data)
  return _internal_odometry_data();
}
inline ::cartographer::sensor::proto::OdometryData* SensorData::_internal_mutable_odometry_data() {
  if (!_internal_has_odometry_data()) {
    clear_sensor_data();
    set_has_odometry_data();
    sensor_data_.odometry_data_ = CreateMaybeMessage< ::cartographer::sensor::proto::OdometryData >(
        GetArenaNoVirtual());
  }
  return sensor_data_.odometry_data_;
}
inline ::cartographer::sensor::proto::OdometryData* SensorData::mutable_odometry_data() {
  // @@protoc_insertion_point(field_mutable:cartographer.cloud.proto.SensorData.odometry_data)
  return _internal_mutable_odometry_data();
}

// .cartographer.sensor.proto.ImuData imu_data = 3;
inline bool SensorData::_internal_has_imu_data() const {
  return sensor_data_case() == kImuData;
}
inline bool SensorData::has_imu_data() const {
  return _internal_has_imu_data();
}
inline void SensorData::set_has_imu_data() {
  _oneof_case_[0] = kImuData;
}
inline ::cartographer::sensor::proto::ImuData* SensorData::release_imu_data() {
  // @@protoc_insertion_point(field_release:cartographer.cloud.proto.SensorData.imu_data)
  if (_internal_has_imu_data()) {
    clear_has_sensor_data();
      ::cartographer::sensor::proto::ImuData* temp = sensor_data_.imu_data_;
    sensor_data_.imu_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cartographer::sensor::proto::ImuData& SensorData::_internal_imu_data() const {
  return _internal_has_imu_data()
      ? *sensor_data_.imu_data_
      : *reinterpret_cast< ::cartographer::sensor::proto::ImuData*>(&::cartographer::sensor::proto::_ImuData_default_instance_);
}
inline const ::cartographer::sensor::proto::ImuData& SensorData::imu_data() const {
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.SensorData.imu_data)
  return _internal_imu_data();
}
inline ::cartographer::sensor::proto::ImuData* SensorData::_internal_mutable_imu_data() {
  if (!_internal_has_imu_data()) {
    clear_sensor_data();
    set_has_imu_data();
    sensor_data_.imu_data_ = CreateMaybeMessage< ::cartographer::sensor::proto::ImuData >(
        GetArenaNoVirtual());
  }
  return sensor_data_.imu_data_;
}
inline ::cartographer::sensor::proto::ImuData* SensorData::mutable_imu_data() {
  // @@protoc_insertion_point(field_mutable:cartographer.cloud.proto.SensorData.imu_data)
  return _internal_mutable_imu_data();
}

// .cartographer.sensor.proto.TimedPointCloudData timed_point_cloud_data = 4;
inline bool SensorData::_internal_has_timed_point_cloud_data() const {
  return sensor_data_case() == kTimedPointCloudData;
}
inline bool SensorData::has_timed_point_cloud_data() const {
  return _internal_has_timed_point_cloud_data();
}
inline void SensorData::set_has_timed_point_cloud_data() {
  _oneof_case_[0] = kTimedPointCloudData;
}
inline ::cartographer::sensor::proto::TimedPointCloudData* SensorData::release_timed_point_cloud_data() {
  // @@protoc_insertion_point(field_release:cartographer.cloud.proto.SensorData.timed_point_cloud_data)
  if (_internal_has_timed_point_cloud_data()) {
    clear_has_sensor_data();
      ::cartographer::sensor::proto::TimedPointCloudData* temp = sensor_data_.timed_point_cloud_data_;
    sensor_data_.timed_point_cloud_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cartographer::sensor::proto::TimedPointCloudData& SensorData::_internal_timed_point_cloud_data() const {
  return _internal_has_timed_point_cloud_data()
      ? *sensor_data_.timed_point_cloud_data_
      : *reinterpret_cast< ::cartographer::sensor::proto::TimedPointCloudData*>(&::cartographer::sensor::proto::_TimedPointCloudData_default_instance_);
}
inline const ::cartographer::sensor::proto::TimedPointCloudData& SensorData::timed_point_cloud_data() const {
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.SensorData.timed_point_cloud_data)
  return _internal_timed_point_cloud_data();
}
inline ::cartographer::sensor::proto::TimedPointCloudData* SensorData::_internal_mutable_timed_point_cloud_data() {
  if (!_internal_has_timed_point_cloud_data()) {
    clear_sensor_data();
    set_has_timed_point_cloud_data();
    sensor_data_.timed_point_cloud_data_ = CreateMaybeMessage< ::cartographer::sensor::proto::TimedPointCloudData >(
        GetArenaNoVirtual());
  }
  return sensor_data_.timed_point_cloud_data_;
}
inline ::cartographer::sensor::proto::TimedPointCloudData* SensorData::mutable_timed_point_cloud_data() {
  // @@protoc_insertion_point(field_mutable:cartographer.cloud.proto.SensorData.timed_point_cloud_data)
  return _internal_mutable_timed_point_cloud_data();
}

// .cartographer.sensor.proto.FixedFramePoseData fixed_frame_pose_data = 5;
inline bool SensorData::_internal_has_fixed_frame_pose_data() const {
  return sensor_data_case() == kFixedFramePoseData;
}
inline bool SensorData::has_fixed_frame_pose_data() const {
  return _internal_has_fixed_frame_pose_data();
}
inline void SensorData::set_has_fixed_frame_pose_data() {
  _oneof_case_[0] = kFixedFramePoseData;
}
inline ::cartographer::sensor::proto::FixedFramePoseData* SensorData::release_fixed_frame_pose_data() {
  // @@protoc_insertion_point(field_release:cartographer.cloud.proto.SensorData.fixed_frame_pose_data)
  if (_internal_has_fixed_frame_pose_data()) {
    clear_has_sensor_data();
      ::cartographer::sensor::proto::FixedFramePoseData* temp = sensor_data_.fixed_frame_pose_data_;
    sensor_data_.fixed_frame_pose_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cartographer::sensor::proto::FixedFramePoseData& SensorData::_internal_fixed_frame_pose_data() const {
  return _internal_has_fixed_frame_pose_data()
      ? *sensor_data_.fixed_frame_pose_data_
      : *reinterpret_cast< ::cartographer::sensor::proto::FixedFramePoseData*>(&::cartographer::sensor::proto::_FixedFramePoseData_default_instance_);
}
inline const ::cartographer::sensor::proto::FixedFramePoseData& SensorData::fixed_frame_pose_data() const {
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.SensorData.fixed_frame_pose_data)
  return _internal_fixed_frame_pose_data();
}
inline ::cartographer::sensor::proto::FixedFramePoseData* SensorData::_internal_mutable_fixed_frame_pose_data() {
  if (!_internal_has_fixed_frame_pose_data()) {
    clear_sensor_data();
    set_has_fixed_frame_pose_data();
    sensor_data_.fixed_frame_pose_data_ = CreateMaybeMessage< ::cartographer::sensor::proto::FixedFramePoseData >(
        GetArenaNoVirtual());
  }
  return sensor_data_.fixed_frame_pose_data_;
}
inline ::cartographer::sensor::proto::FixedFramePoseData* SensorData::mutable_fixed_frame_pose_data() {
  // @@protoc_insertion_point(field_mutable:cartographer.cloud.proto.SensorData.fixed_frame_pose_data)
  return _internal_mutable_fixed_frame_pose_data();
}

// .cartographer.sensor.proto.LandmarkData landmark_data = 6;
inline bool SensorData::_internal_has_landmark_data() const {
  return sensor_data_case() == kLandmarkData;
}
inline bool SensorData::has_landmark_data() const {
  return _internal_has_landmark_data();
}
inline void SensorData::set_has_landmark_data() {
  _oneof_case_[0] = kLandmarkData;
}
inline ::cartographer::sensor::proto::LandmarkData* SensorData::release_landmark_data() {
  // @@protoc_insertion_point(field_release:cartographer.cloud.proto.SensorData.landmark_data)
  if (_internal_has_landmark_data()) {
    clear_has_sensor_data();
      ::cartographer::sensor::proto::LandmarkData* temp = sensor_data_.landmark_data_;
    sensor_data_.landmark_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cartographer::sensor::proto::LandmarkData& SensorData::_internal_landmark_data() const {
  return _internal_has_landmark_data()
      ? *sensor_data_.landmark_data_
      : *reinterpret_cast< ::cartographer::sensor::proto::LandmarkData*>(&::cartographer::sensor::proto::_LandmarkData_default_instance_);
}
inline const ::cartographer::sensor::proto::LandmarkData& SensorData::landmark_data() const {
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.SensorData.landmark_data)
  return _internal_landmark_data();
}
inline ::cartographer::sensor::proto::LandmarkData* SensorData::_internal_mutable_landmark_data() {
  if (!_internal_has_landmark_data()) {
    clear_sensor_data();
    set_has_landmark_data();
    sensor_data_.landmark_data_ = CreateMaybeMessage< ::cartographer::sensor::proto::LandmarkData >(
        GetArenaNoVirtual());
  }
  return sensor_data_.landmark_data_;
}
inline ::cartographer::sensor::proto::LandmarkData* SensorData::mutable_landmark_data() {
  // @@protoc_insertion_point(field_mutable:cartographer.cloud.proto.SensorData.landmark_data)
  return _internal_mutable_landmark_data();
}

// .cartographer.mapping.proto.LocalSlamResultData local_slam_result_data = 7;
inline bool SensorData::_internal_has_local_slam_result_data() const {
  return sensor_data_case() == kLocalSlamResultData;
}
inline bool SensorData::has_local_slam_result_data() const {
  return _internal_has_local_slam_result_data();
}
inline void SensorData::set_has_local_slam_result_data() {
  _oneof_case_[0] = kLocalSlamResultData;
}
inline ::cartographer::mapping::proto::LocalSlamResultData* SensorData::release_local_slam_result_data() {
  // @@protoc_insertion_point(field_release:cartographer.cloud.proto.SensorData.local_slam_result_data)
  if (_internal_has_local_slam_result_data()) {
    clear_has_sensor_data();
      ::cartographer::mapping::proto::LocalSlamResultData* temp = sensor_data_.local_slam_result_data_;
    sensor_data_.local_slam_result_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cartographer::mapping::proto::LocalSlamResultData& SensorData::_internal_local_slam_result_data() const {
  return _internal_has_local_slam_result_data()
      ? *sensor_data_.local_slam_result_data_
      : *reinterpret_cast< ::cartographer::mapping::proto::LocalSlamResultData*>(&::cartographer::mapping::proto::_LocalSlamResultData_default_instance_);
}
inline const ::cartographer::mapping::proto::LocalSlamResultData& SensorData::local_slam_result_data() const {
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.SensorData.local_slam_result_data)
  return _internal_local_slam_result_data();
}
inline ::cartographer::mapping::proto::LocalSlamResultData* SensorData::_internal_mutable_local_slam_result_data() {
  if (!_internal_has_local_slam_result_data()) {
    clear_sensor_data();
    set_has_local_slam_result_data();
    sensor_data_.local_slam_result_data_ = CreateMaybeMessage< ::cartographer::mapping::proto::LocalSlamResultData >(
        GetArenaNoVirtual());
  }
  return sensor_data_.local_slam_result_data_;
}
inline ::cartographer::mapping::proto::LocalSlamResultData* SensorData::mutable_local_slam_result_data() {
  // @@protoc_insertion_point(field_mutable:cartographer.cloud.proto.SensorData.local_slam_result_data)
  return _internal_mutable_local_slam_result_data();
}

inline bool SensorData::has_sensor_data() const {
  return sensor_data_case() != SENSOR_DATA_NOT_SET;
}
inline void SensorData::clear_has_sensor_data() {
  _oneof_case_[0] = SENSOR_DATA_NOT_SET;
}
inline SensorData::SensorDataCase SensorData::sensor_data_case() const {
  return SensorData::SensorDataCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// AddTrajectoryResponse

// int32 trajectory_id = 1;
inline void AddTrajectoryResponse::clear_trajectory_id() {
  trajectory_id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AddTrajectoryResponse::_internal_trajectory_id() const {
  return trajectory_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AddTrajectoryResponse::trajectory_id() const {
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.AddTrajectoryResponse.trajectory_id)
  return _internal_trajectory_id();
}
inline void AddTrajectoryResponse::_internal_set_trajectory_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  trajectory_id_ = value;
}
inline void AddTrajectoryResponse::set_trajectory_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_trajectory_id(value);
  // @@protoc_insertion_point(field_set:cartographer.cloud.proto.AddTrajectoryResponse.trajectory_id)
}

// -------------------------------------------------------------------

// AddSensorDataBatchRequest

// repeated .cartographer.cloud.proto.SensorData sensor_data = 1;
inline int AddSensorDataBatchRequest::_internal_sensor_data_size() const {
  return sensor_data_.size();
}
inline int AddSensorDataBatchRequest::sensor_data_size() const {
  return _internal_sensor_data_size();
}
inline void AddSensorDataBatchRequest::clear_sensor_data() {
  sensor_data_.Clear();
}
inline ::cartographer::cloud::proto::SensorData* AddSensorDataBatchRequest::mutable_sensor_data(int index) {
  // @@protoc_insertion_point(field_mutable:cartographer.cloud.proto.AddSensorDataBatchRequest.sensor_data)
  return sensor_data_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cartographer::cloud::proto::SensorData >*
AddSensorDataBatchRequest::mutable_sensor_data() {
  // @@protoc_insertion_point(field_mutable_list:cartographer.cloud.proto.AddSensorDataBatchRequest.sensor_data)
  return &sensor_data_;
}
inline const ::cartographer::cloud::proto::SensorData& AddSensorDataBatchRequest::_internal_sensor_data(int index) const {
  return sensor_data_.Get(index);
}
inline const ::cartographer::cloud::proto::SensorData& AddSensorDataBatchRequest::sensor_data(int index) const {
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.AddSensorDataBatchRequest.sensor_data)
  return _internal_sensor_data(index);
}
inline ::cartographer::cloud::proto::SensorData* AddSensorDataBatchRequest::_internal_add_sensor_data() {
  return sensor_data_.Add();
}
inline ::cartographer::cloud::proto::SensorData* AddSensorDataBatchRequest::add_sensor_data() {
  // @@protoc_insertion_point(field_add:cartographer.cloud.proto.AddSensorDataBatchRequest.sensor_data)
  return _internal_add_sensor_data();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cartographer::cloud::proto::SensorData >&
AddSensorDataBatchRequest::sensor_data() const {
  // @@protoc_insertion_point(field_list:cartographer.cloud.proto.AddSensorDataBatchRequest.sensor_data)
  return sensor_data_;
}

// -------------------------------------------------------------------

// AddOdometryDataRequest

// .cartographer.cloud.proto.SensorMetadata sensor_metadata = 1;
inline bool AddOdometryDataRequest::_internal_has_sensor_metadata() const {
  return this != internal_default_instance() && sensor_metadata_ != nullptr;
}
inline bool AddOdometryDataRequest::has_sensor_metadata() const {
  return _internal_has_sensor_metadata();
}
inline void AddOdometryDataRequest::clear_sensor_metadata() {
  if (GetArenaNoVirtual() == nullptr && sensor_metadata_ != nullptr) {
    delete sensor_metadata_;
  }
  sensor_metadata_ = nullptr;
}
inline const ::cartographer::cloud::proto::SensorMetadata& AddOdometryDataRequest::_internal_sensor_metadata() const {
  const ::cartographer::cloud::proto::SensorMetadata* p = sensor_metadata_;
  return p != nullptr ? *p : *reinterpret_cast<const ::cartographer::cloud::proto::SensorMetadata*>(
      &::cartographer::cloud::proto::_SensorMetadata_default_instance_);
}
inline const ::cartographer::cloud::proto::SensorMetadata& AddOdometryDataRequest::sensor_metadata() const {
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.AddOdometryDataRequest.sensor_metadata)
  return _internal_sensor_metadata();
}
inline ::cartographer::cloud::proto::SensorMetadata* AddOdometryDataRequest::release_sensor_metadata() {
  // @@protoc_insertion_point(field_release:cartographer.cloud.proto.AddOdometryDataRequest.sensor_metadata)
  
  ::cartographer::cloud::proto::SensorMetadata* temp = sensor_metadata_;
  sensor_metadata_ = nullptr;
  return temp;
}
inline ::cartographer::cloud::proto::SensorMetadata* AddOdometryDataRequest::_internal_mutable_sensor_metadata() {
  
  if (sensor_metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::cartographer::cloud::proto::SensorMetadata>(GetArenaNoVirtual());
    sensor_metadata_ = p;
  }
  return sensor_metadata_;
}
inline ::cartographer::cloud::proto::SensorMetadata* AddOdometryDataRequest::mutable_sensor_metadata() {
  // @@protoc_insertion_point(field_mutable:cartographer.cloud.proto.AddOdometryDataRequest.sensor_metadata)
  return _internal_mutable_sensor_metadata();
}
inline void AddOdometryDataRequest::set_allocated_sensor_metadata(::cartographer::cloud::proto::SensorMetadata* sensor_metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete sensor_metadata_;
  }
  if (sensor_metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      sensor_metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sensor_metadata, submessage_arena);
    }
    
  } else {
    
  }
  sensor_metadata_ = sensor_metadata;
  // @@protoc_insertion_point(field_set_allocated:cartographer.cloud.proto.AddOdometryDataRequest.sensor_metadata)
}

// .cartographer.sensor.proto.OdometryData odometry_data = 2;
inline bool AddOdometryDataRequest::_internal_has_odometry_data() const {
  return this != internal_default_instance() && odometry_data_ != nullptr;
}
inline bool AddOdometryDataRequest::has_odometry_data() const {
  return _internal_has_odometry_data();
}
inline const ::cartographer::sensor::proto::OdometryData& AddOdometryDataRequest::_internal_odometry_data() const {
  const ::cartographer::sensor::proto::OdometryData* p = odometry_data_;
  return p != nullptr ? *p : *reinterpret_cast<const ::cartographer::sensor::proto::OdometryData*>(
      &::cartographer::sensor::proto::_OdometryData_default_instance_);
}
inline const ::cartographer::sensor::proto::OdometryData& AddOdometryDataRequest::odometry_data() const {
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.AddOdometryDataRequest.odometry_data)
  return _internal_odometry_data();
}
inline ::cartographer::sensor::proto::OdometryData* AddOdometryDataRequest::release_odometry_data() {
  // @@protoc_insertion_point(field_release:cartographer.cloud.proto.AddOdometryDataRequest.odometry_data)
  
  ::cartographer::sensor::proto::OdometryData* temp = odometry_data_;
  odometry_data_ = nullptr;
  return temp;
}
inline ::cartographer::sensor::proto::OdometryData* AddOdometryDataRequest::_internal_mutable_odometry_data() {
  
  if (odometry_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::cartographer::sensor::proto::OdometryData>(GetArenaNoVirtual());
    odometry_data_ = p;
  }
  return odometry_data_;
}
inline ::cartographer::sensor::proto::OdometryData* AddOdometryDataRequest::mutable_odometry_data() {
  // @@protoc_insertion_point(field_mutable:cartographer.cloud.proto.AddOdometryDataRequest.odometry_data)
  return _internal_mutable_odometry_data();
}
inline void AddOdometryDataRequest::set_allocated_odometry_data(::cartographer::sensor::proto::OdometryData* odometry_data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(odometry_data_);
  }
  if (odometry_data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      odometry_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, odometry_data, submessage_arena);
    }
    
  } else {
    
  }
  odometry_data_ = odometry_data;
  // @@protoc_insertion_point(field_set_allocated:cartographer.cloud.proto.AddOdometryDataRequest.odometry_data)
}

// -------------------------------------------------------------------

// AddImuDataRequest

// .cartographer.cloud.proto.SensorMetadata sensor_metadata = 1;
inline bool AddImuDataRequest::_internal_has_sensor_metadata() const {
  return this != internal_default_instance() && sensor_metadata_ != nullptr;
}
inline bool AddImuDataRequest::has_sensor_metadata() const {
  return _internal_has_sensor_metadata();
}
inline void AddImuDataRequest::clear_sensor_metadata() {
  if (GetArenaNoVirtual() == nullptr && sensor_metadata_ != nullptr) {
    delete sensor_metadata_;
  }
  sensor_metadata_ = nullptr;
}
inline const ::cartographer::cloud::proto::SensorMetadata& AddImuDataRequest::_internal_sensor_metadata() const {
  const ::cartographer::cloud::proto::SensorMetadata* p = sensor_metadata_;
  return p != nullptr ? *p : *reinterpret_cast<const ::cartographer::cloud::proto::SensorMetadata*>(
      &::cartographer::cloud::proto::_SensorMetadata_default_instance_);
}
inline const ::cartographer::cloud::proto::SensorMetadata& AddImuDataRequest::sensor_metadata() const {
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.AddImuDataRequest.sensor_metadata)
  return _internal_sensor_metadata();
}
inline ::cartographer::cloud::proto::SensorMetadata* AddImuDataRequest::release_sensor_metadata() {
  // @@protoc_insertion_point(field_release:cartographer.cloud.proto.AddImuDataRequest.sensor_metadata)
  
  ::cartographer::cloud::proto::SensorMetadata* temp = sensor_metadata_;
  sensor_metadata_ = nullptr;
  return temp;
}
inline ::cartographer::cloud::proto::SensorMetadata* AddImuDataRequest::_internal_mutable_sensor_metadata() {
  
  if (sensor_metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::cartographer::cloud::proto::SensorMetadata>(GetArenaNoVirtual());
    sensor_metadata_ = p;
  }
  return sensor_metadata_;
}
inline ::cartographer::cloud::proto::SensorMetadata* AddImuDataRequest::mutable_sensor_metadata() {
  // @@protoc_insertion_point(field_mutable:cartographer.cloud.proto.AddImuDataRequest.sensor_metadata)
  return _internal_mutable_sensor_metadata();
}
inline void AddImuDataRequest::set_allocated_sensor_metadata(::cartographer::cloud::proto::SensorMetadata* sensor_metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete sensor_metadata_;
  }
  if (sensor_metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      sensor_metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sensor_metadata, submessage_arena);
    }
    
  } else {
    
  }
  sensor_metadata_ = sensor_metadata;
  // @@protoc_insertion_point(field_set_allocated:cartographer.cloud.proto.AddImuDataRequest.sensor_metadata)
}

// .cartographer.sensor.proto.ImuData imu_data = 2;
inline bool AddImuDataRequest::_internal_has_imu_data() const {
  return this != internal_default_instance() && imu_data_ != nullptr;
}
inline bool AddImuDataRequest::has_imu_data() const {
  return _internal_has_imu_data();
}
inline const ::cartographer::sensor::proto::ImuData& AddImuDataRequest::_internal_imu_data() const {
  const ::cartographer::sensor::proto::ImuData* p = imu_data_;
  return p != nullptr ? *p : *reinterpret_cast<const ::cartographer::sensor::proto::ImuData*>(
      &::cartographer::sensor::proto::_ImuData_default_instance_);
}
inline const ::cartographer::sensor::proto::ImuData& AddImuDataRequest::imu_data() const {
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.AddImuDataRequest.imu_data)
  return _internal_imu_data();
}
inline ::cartographer::sensor::proto::ImuData* AddImuDataRequest::release_imu_data() {
  // @@protoc_insertion_point(field_release:cartographer.cloud.proto.AddImuDataRequest.imu_data)
  
  ::cartographer::sensor::proto::ImuData* temp = imu_data_;
  imu_data_ = nullptr;
  return temp;
}
inline ::cartographer::sensor::proto::ImuData* AddImuDataRequest::_internal_mutable_imu_data() {
  
  if (imu_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::cartographer::sensor::proto::ImuData>(GetArenaNoVirtual());
    imu_data_ = p;
  }
  return imu_data_;
}
inline ::cartographer::sensor::proto::ImuData* AddImuDataRequest::mutable_imu_data() {
  // @@protoc_insertion_point(field_mutable:cartographer.cloud.proto.AddImuDataRequest.imu_data)
  return _internal_mutable_imu_data();
}
inline void AddImuDataRequest::set_allocated_imu_data(::cartographer::sensor::proto::ImuData* imu_data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(imu_data_);
  }
  if (imu_data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      imu_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, imu_data, submessage_arena);
    }
    
  } else {
    
  }
  imu_data_ = imu_data;
  // @@protoc_insertion_point(field_set_allocated:cartographer.cloud.proto.AddImuDataRequest.imu_data)
}

// -------------------------------------------------------------------

// AddRangefinderDataRequest

// .cartographer.cloud.proto.SensorMetadata sensor_metadata = 1;
inline bool AddRangefinderDataRequest::_internal_has_sensor_metadata() const {
  return this != internal_default_instance() && sensor_metadata_ != nullptr;
}
inline bool AddRangefinderDataRequest::has_sensor_metadata() const {
  return _internal_has_sensor_metadata();
}
inline void AddRangefinderDataRequest::clear_sensor_metadata() {
  if (GetArenaNoVirtual() == nullptr && sensor_metadata_ != nullptr) {
    delete sensor_metadata_;
  }
  sensor_metadata_ = nullptr;
}
inline const ::cartographer::cloud::proto::SensorMetadata& AddRangefinderDataRequest::_internal_sensor_metadata() const {
  const ::cartographer::cloud::proto::SensorMetadata* p = sensor_metadata_;
  return p != nullptr ? *p : *reinterpret_cast<const ::cartographer::cloud::proto::SensorMetadata*>(
      &::cartographer::cloud::proto::_SensorMetadata_default_instance_);
}
inline const ::cartographer::cloud::proto::SensorMetadata& AddRangefinderDataRequest::sensor_metadata() const {
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.AddRangefinderDataRequest.sensor_metadata)
  return _internal_sensor_metadata();
}
inline ::cartographer::cloud::proto::SensorMetadata* AddRangefinderDataRequest::release_sensor_metadata() {
  // @@protoc_insertion_point(field_release:cartographer.cloud.proto.AddRangefinderDataRequest.sensor_metadata)
  
  ::cartographer::cloud::proto::SensorMetadata* temp = sensor_metadata_;
  sensor_metadata_ = nullptr;
  return temp;
}
inline ::cartographer::cloud::proto::SensorMetadata* AddRangefinderDataRequest::_internal_mutable_sensor_metadata() {
  
  if (sensor_metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::cartographer::cloud::proto::SensorMetadata>(GetArenaNoVirtual());
    sensor_metadata_ = p;
  }
  return sensor_metadata_;
}
inline ::cartographer::cloud::proto::SensorMetadata* AddRangefinderDataRequest::mutable_sensor_metadata() {
  // @@protoc_insertion_point(field_mutable:cartographer.cloud.proto.AddRangefinderDataRequest.sensor_metadata)
  return _internal_mutable_sensor_metadata();
}
inline void AddRangefinderDataRequest::set_allocated_sensor_metadata(::cartographer::cloud::proto::SensorMetadata* sensor_metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete sensor_metadata_;
  }
  if (sensor_metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      sensor_metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sensor_metadata, submessage_arena);
    }
    
  } else {
    
  }
  sensor_metadata_ = sensor_metadata;
  // @@protoc_insertion_point(field_set_allocated:cartographer.cloud.proto.AddRangefinderDataRequest.sensor_metadata)
}

// .cartographer.sensor.proto.TimedPointCloudData timed_point_cloud_data = 2;
inline bool AddRangefinderDataRequest::_internal_has_timed_point_cloud_data() const {
  return this != internal_default_instance() && timed_point_cloud_data_ != nullptr;
}
inline bool AddRangefinderDataRequest::has_timed_point_cloud_data() const {
  return _internal_has_timed_point_cloud_data();
}
inline const ::cartographer::sensor::proto::TimedPointCloudData& AddRangefinderDataRequest::_internal_timed_point_cloud_data() const {
  const ::cartographer::sensor::proto::TimedPointCloudData* p = timed_point_cloud_data_;
  return p != nullptr ? *p : *reinterpret_cast<const ::cartographer::sensor::proto::TimedPointCloudData*>(
      &::cartographer::sensor::proto::_TimedPointCloudData_default_instance_);
}
inline const ::cartographer::sensor::proto::TimedPointCloudData& AddRangefinderDataRequest::timed_point_cloud_data() const {
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.AddRangefinderDataRequest.timed_point_cloud_data)
  return _internal_timed_point_cloud_data();
}
inline ::cartographer::sensor::proto::TimedPointCloudData* AddRangefinderDataRequest::release_timed_point_cloud_data() {
  // @@protoc_insertion_point(field_release:cartographer.cloud.proto.AddRangefinderDataRequest.timed_point_cloud_data)
  
  ::cartographer::sensor::proto::TimedPointCloudData* temp = timed_point_cloud_data_;
  timed_point_cloud_data_ = nullptr;
  return temp;
}
inline ::cartographer::sensor::proto::TimedPointCloudData* AddRangefinderDataRequest::_internal_mutable_timed_point_cloud_data() {
  
  if (timed_point_cloud_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::cartographer::sensor::proto::TimedPointCloudData>(GetArenaNoVirtual());
    timed_point_cloud_data_ = p;
  }
  return timed_point_cloud_data_;
}
inline ::cartographer::sensor::proto::TimedPointCloudData* AddRangefinderDataRequest::mutable_timed_point_cloud_data() {
  // @@protoc_insertion_point(field_mutable:cartographer.cloud.proto.AddRangefinderDataRequest.timed_point_cloud_data)
  return _internal_mutable_timed_point_cloud_data();
}
inline void AddRangefinderDataRequest::set_allocated_timed_point_cloud_data(::cartographer::sensor::proto::TimedPointCloudData* timed_point_cloud_data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(timed_point_cloud_data_);
  }
  if (timed_point_cloud_data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      timed_point_cloud_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timed_point_cloud_data, submessage_arena);
    }
    
  } else {
    
  }
  timed_point_cloud_data_ = timed_point_cloud_data;
  // @@protoc_insertion_point(field_set_allocated:cartographer.cloud.proto.AddRangefinderDataRequest.timed_point_cloud_data)
}

// -------------------------------------------------------------------

// AddFixedFramePoseDataRequest

// .cartographer.cloud.proto.SensorMetadata sensor_metadata = 1;
inline bool AddFixedFramePoseDataRequest::_internal_has_sensor_metadata() const {
  return this != internal_default_instance() && sensor_metadata_ != nullptr;
}
inline bool AddFixedFramePoseDataRequest::has_sensor_metadata() const {
  return _internal_has_sensor_metadata();
}
inline void AddFixedFramePoseDataRequest::clear_sensor_metadata() {
  if (GetArenaNoVirtual() == nullptr && sensor_metadata_ != nullptr) {
    delete sensor_metadata_;
  }
  sensor_metadata_ = nullptr;
}
inline const ::cartographer::cloud::proto::SensorMetadata& AddFixedFramePoseDataRequest::_internal_sensor_metadata() const {
  const ::cartographer::cloud::proto::SensorMetadata* p = sensor_metadata_;
  return p != nullptr ? *p : *reinterpret_cast<const ::cartographer::cloud::proto::SensorMetadata*>(
      &::cartographer::cloud::proto::_SensorMetadata_default_instance_);
}
inline const ::cartographer::cloud::proto::SensorMetadata& AddFixedFramePoseDataRequest::sensor_metadata() const {
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.AddFixedFramePoseDataRequest.sensor_metadata)
  return _internal_sensor_metadata();
}
inline ::cartographer::cloud::proto::SensorMetadata* AddFixedFramePoseDataRequest::release_sensor_metadata() {
  // @@protoc_insertion_point(field_release:cartographer.cloud.proto.AddFixedFramePoseDataRequest.sensor_metadata)
  
  ::cartographer::cloud::proto::SensorMetadata* temp = sensor_metadata_;
  sensor_metadata_ = nullptr;
  return temp;
}
inline ::cartographer::cloud::proto::SensorMetadata* AddFixedFramePoseDataRequest::_internal_mutable_sensor_metadata() {
  
  if (sensor_metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::cartographer::cloud::proto::SensorMetadata>(GetArenaNoVirtual());
    sensor_metadata_ = p;
  }
  return sensor_metadata_;
}
inline ::cartographer::cloud::proto::SensorMetadata* AddFixedFramePoseDataRequest::mutable_sensor_metadata() {
  // @@protoc_insertion_point(field_mutable:cartographer.cloud.proto.AddFixedFramePoseDataRequest.sensor_metadata)
  return _internal_mutable_sensor_metadata();
}
inline void AddFixedFramePoseDataRequest::set_allocated_sensor_metadata(::cartographer::cloud::proto::SensorMetadata* sensor_metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete sensor_metadata_;
  }
  if (sensor_metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      sensor_metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sensor_metadata, submessage_arena);
    }
    
  } else {
    
  }
  sensor_metadata_ = sensor_metadata;
  // @@protoc_insertion_point(field_set_allocated:cartographer.cloud.proto.AddFixedFramePoseDataRequest.sensor_metadata)
}

// .cartographer.sensor.proto.FixedFramePoseData fixed_frame_pose_data = 2;
inline bool AddFixedFramePoseDataRequest::_internal_has_fixed_frame_pose_data() const {
  return this != internal_default_instance() && fixed_frame_pose_data_ != nullptr;
}
inline bool AddFixedFramePoseDataRequest::has_fixed_frame_pose_data() const {
  return _internal_has_fixed_frame_pose_data();
}
inline const ::cartographer::sensor::proto::FixedFramePoseData& AddFixedFramePoseDataRequest::_internal_fixed_frame_pose_data() const {
  const ::cartographer::sensor::proto::FixedFramePoseData* p = fixed_frame_pose_data_;
  return p != nullptr ? *p : *reinterpret_cast<const ::cartographer::sensor::proto::FixedFramePoseData*>(
      &::cartographer::sensor::proto::_FixedFramePoseData_default_instance_);
}
inline const ::cartographer::sensor::proto::FixedFramePoseData& AddFixedFramePoseDataRequest::fixed_frame_pose_data() const {
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.AddFixedFramePoseDataRequest.fixed_frame_pose_data)
  return _internal_fixed_frame_pose_data();
}
inline ::cartographer::sensor::proto::FixedFramePoseData* AddFixedFramePoseDataRequest::release_fixed_frame_pose_data() {
  // @@protoc_insertion_point(field_release:cartographer.cloud.proto.AddFixedFramePoseDataRequest.fixed_frame_pose_data)
  
  ::cartographer::sensor::proto::FixedFramePoseData* temp = fixed_frame_pose_data_;
  fixed_frame_pose_data_ = nullptr;
  return temp;
}
inline ::cartographer::sensor::proto::FixedFramePoseData* AddFixedFramePoseDataRequest::_internal_mutable_fixed_frame_pose_data() {
  
  if (fixed_frame_pose_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::cartographer::sensor::proto::FixedFramePoseData>(GetArenaNoVirtual());
    fixed_frame_pose_data_ = p;
  }
  return fixed_frame_pose_data_;
}
inline ::cartographer::sensor::proto::FixedFramePoseData* AddFixedFramePoseDataRequest::mutable_fixed_frame_pose_data() {
  // @@protoc_insertion_point(field_mutable:cartographer.cloud.proto.AddFixedFramePoseDataRequest.fixed_frame_pose_data)
  return _internal_mutable_fixed_frame_pose_data();
}
inline void AddFixedFramePoseDataRequest::set_allocated_fixed_frame_pose_data(::cartographer::sensor::proto::FixedFramePoseData* fixed_frame_pose_data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(fixed_frame_pose_data_);
  }
  if (fixed_frame_pose_data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      fixed_frame_pose_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fixed_frame_pose_data, submessage_arena);
    }
    
  } else {
    
  }
  fixed_frame_pose_data_ = fixed_frame_pose_data;
  // @@protoc_insertion_point(field_set_allocated:cartographer.cloud.proto.AddFixedFramePoseDataRequest.fixed_frame_pose_data)
}

// -------------------------------------------------------------------

// AddLandmarkDataRequest

// .cartographer.cloud.proto.SensorMetadata sensor_metadata = 1;
inline bool AddLandmarkDataRequest::_internal_has_sensor_metadata() const {
  return this != internal_default_instance() && sensor_metadata_ != nullptr;
}
inline bool AddLandmarkDataRequest::has_sensor_metadata() const {
  return _internal_has_sensor_metadata();
}
inline void AddLandmarkDataRequest::clear_sensor_metadata() {
  if (GetArenaNoVirtual() == nullptr && sensor_metadata_ != nullptr) {
    delete sensor_metadata_;
  }
  sensor_metadata_ = nullptr;
}
inline const ::cartographer::cloud::proto::SensorMetadata& AddLandmarkDataRequest::_internal_sensor_metadata() const {
  const ::cartographer::cloud::proto::SensorMetadata* p = sensor_metadata_;
  return p != nullptr ? *p : *reinterpret_cast<const ::cartographer::cloud::proto::SensorMetadata*>(
      &::cartographer::cloud::proto::_SensorMetadata_default_instance_);
}
inline const ::cartographer::cloud::proto::SensorMetadata& AddLandmarkDataRequest::sensor_metadata() const {
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.AddLandmarkDataRequest.sensor_metadata)
  return _internal_sensor_metadata();
}
inline ::cartographer::cloud::proto::SensorMetadata* AddLandmarkDataRequest::release_sensor_metadata() {
  // @@protoc_insertion_point(field_release:cartographer.cloud.proto.AddLandmarkDataRequest.sensor_metadata)
  
  ::cartographer::cloud::proto::SensorMetadata* temp = sensor_metadata_;
  sensor_metadata_ = nullptr;
  return temp;
}
inline ::cartographer::cloud::proto::SensorMetadata* AddLandmarkDataRequest::_internal_mutable_sensor_metadata() {
  
  if (sensor_metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::cartographer::cloud::proto::SensorMetadata>(GetArenaNoVirtual());
    sensor_metadata_ = p;
  }
  return sensor_metadata_;
}
inline ::cartographer::cloud::proto::SensorMetadata* AddLandmarkDataRequest::mutable_sensor_metadata() {
  // @@protoc_insertion_point(field_mutable:cartographer.cloud.proto.AddLandmarkDataRequest.sensor_metadata)
  return _internal_mutable_sensor_metadata();
}
inline void AddLandmarkDataRequest::set_allocated_sensor_metadata(::cartographer::cloud::proto::SensorMetadata* sensor_metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete sensor_metadata_;
  }
  if (sensor_metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      sensor_metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sensor_metadata, submessage_arena);
    }
    
  } else {
    
  }
  sensor_metadata_ = sensor_metadata;
  // @@protoc_insertion_point(field_set_allocated:cartographer.cloud.proto.AddLandmarkDataRequest.sensor_metadata)
}

// .cartographer.sensor.proto.LandmarkData landmark_data = 2;
inline bool AddLandmarkDataRequest::_internal_has_landmark_data() const {
  return this != internal_default_instance() && landmark_data_ != nullptr;
}
inline bool AddLandmarkDataRequest::has_landmark_data() const {
  return _internal_has_landmark_data();
}
inline const ::cartographer::sensor::proto::LandmarkData& AddLandmarkDataRequest::_internal_landmark_data() const {
  const ::cartographer::sensor::proto::LandmarkData* p = landmark_data_;
  return p != nullptr ? *p : *reinterpret_cast<const ::cartographer::sensor::proto::LandmarkData*>(
      &::cartographer::sensor::proto::_LandmarkData_default_instance_);
}
inline const ::cartographer::sensor::proto::LandmarkData& AddLandmarkDataRequest::landmark_data() const {
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.AddLandmarkDataRequest.landmark_data)
  return _internal_landmark_data();
}
inline ::cartographer::sensor::proto::LandmarkData* AddLandmarkDataRequest::release_landmark_data() {
  // @@protoc_insertion_point(field_release:cartographer.cloud.proto.AddLandmarkDataRequest.landmark_data)
  
  ::cartographer::sensor::proto::LandmarkData* temp = landmark_data_;
  landmark_data_ = nullptr;
  return temp;
}
inline ::cartographer::sensor::proto::LandmarkData* AddLandmarkDataRequest::_internal_mutable_landmark_data() {
  
  if (landmark_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::cartographer::sensor::proto::LandmarkData>(GetArenaNoVirtual());
    landmark_data_ = p;
  }
  return landmark_data_;
}
inline ::cartographer::sensor::proto::LandmarkData* AddLandmarkDataRequest::mutable_landmark_data() {
  // @@protoc_insertion_point(field_mutable:cartographer.cloud.proto.AddLandmarkDataRequest.landmark_data)
  return _internal_mutable_landmark_data();
}
inline void AddLandmarkDataRequest::set_allocated_landmark_data(::cartographer::sensor::proto::LandmarkData* landmark_data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(landmark_data_);
  }
  if (landmark_data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      landmark_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, landmark_data, submessage_arena);
    }
    
  } else {
    
  }
  landmark_data_ = landmark_data;
  // @@protoc_insertion_point(field_set_allocated:cartographer.cloud.proto.AddLandmarkDataRequest.landmark_data)
}

// -------------------------------------------------------------------

// FinishTrajectoryRequest

// int32 trajectory_id = 1;
inline void FinishTrajectoryRequest::clear_trajectory_id() {
  trajectory_id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 FinishTrajectoryRequest::_internal_trajectory_id() const {
  return trajectory_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 FinishTrajectoryRequest::trajectory_id() const {
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.FinishTrajectoryRequest.trajectory_id)
  return _internal_trajectory_id();
}
inline void FinishTrajectoryRequest::_internal_set_trajectory_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  trajectory_id_ = value;
}
inline void FinishTrajectoryRequest::set_trajectory_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_trajectory_id(value);
  // @@protoc_insertion_point(field_set:cartographer.cloud.proto.FinishTrajectoryRequest.trajectory_id)
}

// string client_id = 2;
inline void FinishTrajectoryRequest::clear_client_id() {
  client_id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& FinishTrajectoryRequest::client_id() const {
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.FinishTrajectoryRequest.client_id)
  return _internal_client_id();
}
inline void FinishTrajectoryRequest::set_client_id(const std::string& value) {
  _internal_set_client_id(value);
  // @@protoc_insertion_point(field_set:cartographer.cloud.proto.FinishTrajectoryRequest.client_id)
}
inline std::string* FinishTrajectoryRequest::mutable_client_id() {
  // @@protoc_insertion_point(field_mutable:cartographer.cloud.proto.FinishTrajectoryRequest.client_id)
  return _internal_mutable_client_id();
}
inline const std::string& FinishTrajectoryRequest::_internal_client_id() const {
  return client_id_.GetNoArena();
}
inline void FinishTrajectoryRequest::_internal_set_client_id(const std::string& value) {
  
  client_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void FinishTrajectoryRequest::set_client_id(std::string&& value) {
  
  client_id_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cartographer.cloud.proto.FinishTrajectoryRequest.client_id)
}
inline void FinishTrajectoryRequest::set_client_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  client_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cartographer.cloud.proto.FinishTrajectoryRequest.client_id)
}
inline void FinishTrajectoryRequest::set_client_id(const char* value, size_t size) {
  
  client_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cartographer.cloud.proto.FinishTrajectoryRequest.client_id)
}
inline std::string* FinishTrajectoryRequest::_internal_mutable_client_id() {
  
  return client_id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* FinishTrajectoryRequest::release_client_id() {
  // @@protoc_insertion_point(field_release:cartographer.cloud.proto.FinishTrajectoryRequest.client_id)
  
  return client_id_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void FinishTrajectoryRequest::set_allocated_client_id(std::string* client_id) {
  if (client_id != nullptr) {
    
  } else {
    
  }
  client_id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), client_id);
  // @@protoc_insertion_point(field_set_allocated:cartographer.cloud.proto.FinishTrajectoryRequest.client_id)
}

// -------------------------------------------------------------------

// DeleteTrajectoryRequest

// int32 trajectory_id = 1;
inline void DeleteTrajectoryRequest::clear_trajectory_id() {
  trajectory_id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DeleteTrajectoryRequest::_internal_trajectory_id() const {
  return trajectory_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DeleteTrajectoryRequest::trajectory_id() const {
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.DeleteTrajectoryRequest.trajectory_id)
  return _internal_trajectory_id();
}
inline void DeleteTrajectoryRequest::_internal_set_trajectory_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  trajectory_id_ = value;
}
inline void DeleteTrajectoryRequest::set_trajectory_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_trajectory_id(value);
  // @@protoc_insertion_point(field_set:cartographer.cloud.proto.DeleteTrajectoryRequest.trajectory_id)
}

// string client_id = 2;
inline void DeleteTrajectoryRequest::clear_client_id() {
  client_id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& DeleteTrajectoryRequest::client_id() const {
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.DeleteTrajectoryRequest.client_id)
  return _internal_client_id();
}
inline void DeleteTrajectoryRequest::set_client_id(const std::string& value) {
  _internal_set_client_id(value);
  // @@protoc_insertion_point(field_set:cartographer.cloud.proto.DeleteTrajectoryRequest.client_id)
}
inline std::string* DeleteTrajectoryRequest::mutable_client_id() {
  // @@protoc_insertion_point(field_mutable:cartographer.cloud.proto.DeleteTrajectoryRequest.client_id)
  return _internal_mutable_client_id();
}
inline const std::string& DeleteTrajectoryRequest::_internal_client_id() const {
  return client_id_.GetNoArena();
}
inline void DeleteTrajectoryRequest::_internal_set_client_id(const std::string& value) {
  
  client_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void DeleteTrajectoryRequest::set_client_id(std::string&& value) {
  
  client_id_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cartographer.cloud.proto.DeleteTrajectoryRequest.client_id)
}
inline void DeleteTrajectoryRequest::set_client_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  client_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cartographer.cloud.proto.DeleteTrajectoryRequest.client_id)
}
inline void DeleteTrajectoryRequest::set_client_id(const char* value, size_t size) {
  
  client_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cartographer.cloud.proto.DeleteTrajectoryRequest.client_id)
}
inline std::string* DeleteTrajectoryRequest::_internal_mutable_client_id() {
  
  return client_id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* DeleteTrajectoryRequest::release_client_id() {
  // @@protoc_insertion_point(field_release:cartographer.cloud.proto.DeleteTrajectoryRequest.client_id)
  
  return client_id_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void DeleteTrajectoryRequest::set_allocated_client_id(std::string* client_id) {
  if (client_id != nullptr) {
    
  } else {
    
  }
  client_id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), client_id);
  // @@protoc_insertion_point(field_set_allocated:cartographer.cloud.proto.DeleteTrajectoryRequest.client_id)
}

// -------------------------------------------------------------------

// ReceiveLocalSlamResultsRequest

// int32 trajectory_id = 1;
inline void ReceiveLocalSlamResultsRequest::clear_trajectory_id() {
  trajectory_id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ReceiveLocalSlamResultsRequest::_internal_trajectory_id() const {
  return trajectory_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ReceiveLocalSlamResultsRequest::trajectory_id() const {
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.ReceiveLocalSlamResultsRequest.trajectory_id)
  return _internal_trajectory_id();
}
inline void ReceiveLocalSlamResultsRequest::_internal_set_trajectory_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  trajectory_id_ = value;
}
inline void ReceiveLocalSlamResultsRequest::set_trajectory_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_trajectory_id(value);
  // @@protoc_insertion_point(field_set:cartographer.cloud.proto.ReceiveLocalSlamResultsRequest.trajectory_id)
}

// -------------------------------------------------------------------

// LocalSlamInsertionResult

// .cartographer.mapping.proto.NodeId node_id = 1;
inline bool LocalSlamInsertionResult::_internal_has_node_id() const {
  return this != internal_default_instance() && node_id_ != nullptr;
}
inline bool LocalSlamInsertionResult::has_node_id() const {
  return _internal_has_node_id();
}
inline const ::cartographer::mapping::proto::NodeId& LocalSlamInsertionResult::_internal_node_id() const {
  const ::cartographer::mapping::proto::NodeId* p = node_id_;
  return p != nullptr ? *p : *reinterpret_cast<const ::cartographer::mapping::proto::NodeId*>(
      &::cartographer::mapping::proto::_NodeId_default_instance_);
}
inline const ::cartographer::mapping::proto::NodeId& LocalSlamInsertionResult::node_id() const {
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.LocalSlamInsertionResult.node_id)
  return _internal_node_id();
}
inline ::cartographer::mapping::proto::NodeId* LocalSlamInsertionResult::release_node_id() {
  // @@protoc_insertion_point(field_release:cartographer.cloud.proto.LocalSlamInsertionResult.node_id)
  
  ::cartographer::mapping::proto::NodeId* temp = node_id_;
  node_id_ = nullptr;
  return temp;
}
inline ::cartographer::mapping::proto::NodeId* LocalSlamInsertionResult::_internal_mutable_node_id() {
  
  if (node_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::cartographer::mapping::proto::NodeId>(GetArenaNoVirtual());
    node_id_ = p;
  }
  return node_id_;
}
inline ::cartographer::mapping::proto::NodeId* LocalSlamInsertionResult::mutable_node_id() {
  // @@protoc_insertion_point(field_mutable:cartographer.cloud.proto.LocalSlamInsertionResult.node_id)
  return _internal_mutable_node_id();
}
inline void LocalSlamInsertionResult::set_allocated_node_id(::cartographer::mapping::proto::NodeId* node_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(node_id_);
  }
  if (node_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      node_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, node_id, submessage_arena);
    }
    
  } else {
    
  }
  node_id_ = node_id;
  // @@protoc_insertion_point(field_set_allocated:cartographer.cloud.proto.LocalSlamInsertionResult.node_id)
}

// -------------------------------------------------------------------

// ReceiveLocalSlamResultsResponse

// int32 trajectory_id = 1;
inline void ReceiveLocalSlamResultsResponse::clear_trajectory_id() {
  trajectory_id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ReceiveLocalSlamResultsResponse::_internal_trajectory_id() const {
  return trajectory_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ReceiveLocalSlamResultsResponse::trajectory_id() const {
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.ReceiveLocalSlamResultsResponse.trajectory_id)
  return _internal_trajectory_id();
}
inline void ReceiveLocalSlamResultsResponse::_internal_set_trajectory_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  trajectory_id_ = value;
}
inline void ReceiveLocalSlamResultsResponse::set_trajectory_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_trajectory_id(value);
  // @@protoc_insertion_point(field_set:cartographer.cloud.proto.ReceiveLocalSlamResultsResponse.trajectory_id)
}

// int64 timestamp = 2;
inline void ReceiveLocalSlamResultsResponse::clear_timestamp() {
  timestamp_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ReceiveLocalSlamResultsResponse::_internal_timestamp() const {
  return timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ReceiveLocalSlamResultsResponse::timestamp() const {
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.ReceiveLocalSlamResultsResponse.timestamp)
  return _internal_timestamp();
}
inline void ReceiveLocalSlamResultsResponse::_internal_set_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  timestamp_ = value;
}
inline void ReceiveLocalSlamResultsResponse::set_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:cartographer.cloud.proto.ReceiveLocalSlamResultsResponse.timestamp)
}

// .cartographer.transform.proto.Rigid3d local_pose = 3;
inline bool ReceiveLocalSlamResultsResponse::_internal_has_local_pose() const {
  return this != internal_default_instance() && local_pose_ != nullptr;
}
inline bool ReceiveLocalSlamResultsResponse::has_local_pose() const {
  return _internal_has_local_pose();
}
inline const ::cartographer::transform::proto::Rigid3d& ReceiveLocalSlamResultsResponse::_internal_local_pose() const {
  const ::cartographer::transform::proto::Rigid3d* p = local_pose_;
  return p != nullptr ? *p : *reinterpret_cast<const ::cartographer::transform::proto::Rigid3d*>(
      &::cartographer::transform::proto::_Rigid3d_default_instance_);
}
inline const ::cartographer::transform::proto::Rigid3d& ReceiveLocalSlamResultsResponse::local_pose() const {
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.ReceiveLocalSlamResultsResponse.local_pose)
  return _internal_local_pose();
}
inline ::cartographer::transform::proto::Rigid3d* ReceiveLocalSlamResultsResponse::release_local_pose() {
  // @@protoc_insertion_point(field_release:cartographer.cloud.proto.ReceiveLocalSlamResultsResponse.local_pose)
  
  ::cartographer::transform::proto::Rigid3d* temp = local_pose_;
  local_pose_ = nullptr;
  return temp;
}
inline ::cartographer::transform::proto::Rigid3d* ReceiveLocalSlamResultsResponse::_internal_mutable_local_pose() {
  
  if (local_pose_ == nullptr) {
    auto* p = CreateMaybeMessage<::cartographer::transform::proto::Rigid3d>(GetArenaNoVirtual());
    local_pose_ = p;
  }
  return local_pose_;
}
inline ::cartographer::transform::proto::Rigid3d* ReceiveLocalSlamResultsResponse::mutable_local_pose() {
  // @@protoc_insertion_point(field_mutable:cartographer.cloud.proto.ReceiveLocalSlamResultsResponse.local_pose)
  return _internal_mutable_local_pose();
}
inline void ReceiveLocalSlamResultsResponse::set_allocated_local_pose(::cartographer::transform::proto::Rigid3d* local_pose) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(local_pose_);
  }
  if (local_pose) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      local_pose = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, local_pose, submessage_arena);
    }
    
  } else {
    
  }
  local_pose_ = local_pose;
  // @@protoc_insertion_point(field_set_allocated:cartographer.cloud.proto.ReceiveLocalSlamResultsResponse.local_pose)
}

// .cartographer.sensor.proto.RangeData range_data = 4;
inline bool ReceiveLocalSlamResultsResponse::_internal_has_range_data() const {
  return this != internal_default_instance() && range_data_ != nullptr;
}
inline bool ReceiveLocalSlamResultsResponse::has_range_data() const {
  return _internal_has_range_data();
}
inline const ::cartographer::sensor::proto::RangeData& ReceiveLocalSlamResultsResponse::_internal_range_data() const {
  const ::cartographer::sensor::proto::RangeData* p = range_data_;
  return p != nullptr ? *p : *reinterpret_cast<const ::cartographer::sensor::proto::RangeData*>(
      &::cartographer::sensor::proto::_RangeData_default_instance_);
}
inline const ::cartographer::sensor::proto::RangeData& ReceiveLocalSlamResultsResponse::range_data() const {
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.ReceiveLocalSlamResultsResponse.range_data)
  return _internal_range_data();
}
inline ::cartographer::sensor::proto::RangeData* ReceiveLocalSlamResultsResponse::release_range_data() {
  // @@protoc_insertion_point(field_release:cartographer.cloud.proto.ReceiveLocalSlamResultsResponse.range_data)
  
  ::cartographer::sensor::proto::RangeData* temp = range_data_;
  range_data_ = nullptr;
  return temp;
}
inline ::cartographer::sensor::proto::RangeData* ReceiveLocalSlamResultsResponse::_internal_mutable_range_data() {
  
  if (range_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::cartographer::sensor::proto::RangeData>(GetArenaNoVirtual());
    range_data_ = p;
  }
  return range_data_;
}
inline ::cartographer::sensor::proto::RangeData* ReceiveLocalSlamResultsResponse::mutable_range_data() {
  // @@protoc_insertion_point(field_mutable:cartographer.cloud.proto.ReceiveLocalSlamResultsResponse.range_data)
  return _internal_mutable_range_data();
}
inline void ReceiveLocalSlamResultsResponse::set_allocated_range_data(::cartographer::sensor::proto::RangeData* range_data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(range_data_);
  }
  if (range_data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      range_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, range_data, submessage_arena);
    }
    
  } else {
    
  }
  range_data_ = range_data;
  // @@protoc_insertion_point(field_set_allocated:cartographer.cloud.proto.ReceiveLocalSlamResultsResponse.range_data)
}

// .cartographer.cloud.proto.LocalSlamInsertionResult insertion_result = 5;
inline bool ReceiveLocalSlamResultsResponse::_internal_has_insertion_result() const {
  return this != internal_default_instance() && insertion_result_ != nullptr;
}
inline bool ReceiveLocalSlamResultsResponse::has_insertion_result() const {
  return _internal_has_insertion_result();
}
inline void ReceiveLocalSlamResultsResponse::clear_insertion_result() {
  if (GetArenaNoVirtual() == nullptr && insertion_result_ != nullptr) {
    delete insertion_result_;
  }
  insertion_result_ = nullptr;
}
inline const ::cartographer::cloud::proto::LocalSlamInsertionResult& ReceiveLocalSlamResultsResponse::_internal_insertion_result() const {
  const ::cartographer::cloud::proto::LocalSlamInsertionResult* p = insertion_result_;
  return p != nullptr ? *p : *reinterpret_cast<const ::cartographer::cloud::proto::LocalSlamInsertionResult*>(
      &::cartographer::cloud::proto::_LocalSlamInsertionResult_default_instance_);
}
inline const ::cartographer::cloud::proto::LocalSlamInsertionResult& ReceiveLocalSlamResultsResponse::insertion_result() const {
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.ReceiveLocalSlamResultsResponse.insertion_result)
  return _internal_insertion_result();
}
inline ::cartographer::cloud::proto::LocalSlamInsertionResult* ReceiveLocalSlamResultsResponse::release_insertion_result() {
  // @@protoc_insertion_point(field_release:cartographer.cloud.proto.ReceiveLocalSlamResultsResponse.insertion_result)
  
  ::cartographer::cloud::proto::LocalSlamInsertionResult* temp = insertion_result_;
  insertion_result_ = nullptr;
  return temp;
}
inline ::cartographer::cloud::proto::LocalSlamInsertionResult* ReceiveLocalSlamResultsResponse::_internal_mutable_insertion_result() {
  
  if (insertion_result_ == nullptr) {
    auto* p = CreateMaybeMessage<::cartographer::cloud::proto::LocalSlamInsertionResult>(GetArenaNoVirtual());
    insertion_result_ = p;
  }
  return insertion_result_;
}
inline ::cartographer::cloud::proto::LocalSlamInsertionResult* ReceiveLocalSlamResultsResponse::mutable_insertion_result() {
  // @@protoc_insertion_point(field_mutable:cartographer.cloud.proto.ReceiveLocalSlamResultsResponse.insertion_result)
  return _internal_mutable_insertion_result();
}
inline void ReceiveLocalSlamResultsResponse::set_allocated_insertion_result(::cartographer::cloud::proto::LocalSlamInsertionResult* insertion_result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete insertion_result_;
  }
  if (insertion_result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      insertion_result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, insertion_result, submessage_arena);
    }
    
  } else {
    
  }
  insertion_result_ = insertion_result;
  // @@protoc_insertion_point(field_set_allocated:cartographer.cloud.proto.ReceiveLocalSlamResultsResponse.insertion_result)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ReceiveGlobalSlamOptimizationsResponse

// map<int32, .cartographer.mapping.proto.NodeId> last_optimized_node_ids = 1;
inline int ReceiveGlobalSlamOptimizationsResponse::_internal_last_optimized_node_ids_size() const {
  return last_optimized_node_ids_.size();
}
inline int ReceiveGlobalSlamOptimizationsResponse::last_optimized_node_ids_size() const {
  return _internal_last_optimized_node_ids_size();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::int32, ::cartographer::mapping::proto::NodeId >&
ReceiveGlobalSlamOptimizationsResponse::_internal_last_optimized_node_ids() const {
  return last_optimized_node_ids_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::int32, ::cartographer::mapping::proto::NodeId >&
ReceiveGlobalSlamOptimizationsResponse::last_optimized_node_ids() const {
  // @@protoc_insertion_point(field_map:cartographer.cloud.proto.ReceiveGlobalSlamOptimizationsResponse.last_optimized_node_ids)
  return _internal_last_optimized_node_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::int32, ::cartographer::mapping::proto::NodeId >*
ReceiveGlobalSlamOptimizationsResponse::_internal_mutable_last_optimized_node_ids() {
  return last_optimized_node_ids_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::int32, ::cartographer::mapping::proto::NodeId >*
ReceiveGlobalSlamOptimizationsResponse::mutable_last_optimized_node_ids() {
  // @@protoc_insertion_point(field_mutable_map:cartographer.cloud.proto.ReceiveGlobalSlamOptimizationsResponse.last_optimized_node_ids)
  return _internal_mutable_last_optimized_node_ids();
}

// map<int32, .cartographer.mapping.proto.SubmapId> last_optimized_submap_ids = 2;
inline int ReceiveGlobalSlamOptimizationsResponse::_internal_last_optimized_submap_ids_size() const {
  return last_optimized_submap_ids_.size();
}
inline int ReceiveGlobalSlamOptimizationsResponse::last_optimized_submap_ids_size() const {
  return _internal_last_optimized_submap_ids_size();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::int32, ::cartographer::mapping::proto::SubmapId >&
ReceiveGlobalSlamOptimizationsResponse::_internal_last_optimized_submap_ids() const {
  return last_optimized_submap_ids_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::int32, ::cartographer::mapping::proto::SubmapId >&
ReceiveGlobalSlamOptimizationsResponse::last_optimized_submap_ids() const {
  // @@protoc_insertion_point(field_map:cartographer.cloud.proto.ReceiveGlobalSlamOptimizationsResponse.last_optimized_submap_ids)
  return _internal_last_optimized_submap_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::int32, ::cartographer::mapping::proto::SubmapId >*
ReceiveGlobalSlamOptimizationsResponse::_internal_mutable_last_optimized_submap_ids() {
  return last_optimized_submap_ids_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::int32, ::cartographer::mapping::proto::SubmapId >*
ReceiveGlobalSlamOptimizationsResponse::mutable_last_optimized_submap_ids() {
  // @@protoc_insertion_point(field_mutable_map:cartographer.cloud.proto.ReceiveGlobalSlamOptimizationsResponse.last_optimized_submap_ids)
  return _internal_mutable_last_optimized_submap_ids();
}

// -------------------------------------------------------------------

// GetSubmapRequest

// .cartographer.mapping.proto.SubmapId submap_id = 1;
inline bool GetSubmapRequest::_internal_has_submap_id() const {
  return this != internal_default_instance() && submap_id_ != nullptr;
}
inline bool GetSubmapRequest::has_submap_id() const {
  return _internal_has_submap_id();
}
inline const ::cartographer::mapping::proto::SubmapId& GetSubmapRequest::_internal_submap_id() const {
  const ::cartographer::mapping::proto::SubmapId* p = submap_id_;
  return p != nullptr ? *p : *reinterpret_cast<const ::cartographer::mapping::proto::SubmapId*>(
      &::cartographer::mapping::proto::_SubmapId_default_instance_);
}
inline const ::cartographer::mapping::proto::SubmapId& GetSubmapRequest::submap_id() const {
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.GetSubmapRequest.submap_id)
  return _internal_submap_id();
}
inline ::cartographer::mapping::proto::SubmapId* GetSubmapRequest::release_submap_id() {
  // @@protoc_insertion_point(field_release:cartographer.cloud.proto.GetSubmapRequest.submap_id)
  
  ::cartographer::mapping::proto::SubmapId* temp = submap_id_;
  submap_id_ = nullptr;
  return temp;
}
inline ::cartographer::mapping::proto::SubmapId* GetSubmapRequest::_internal_mutable_submap_id() {
  
  if (submap_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::cartographer::mapping::proto::SubmapId>(GetArenaNoVirtual());
    submap_id_ = p;
  }
  return submap_id_;
}
inline ::cartographer::mapping::proto::SubmapId* GetSubmapRequest::mutable_submap_id() {
  // @@protoc_insertion_point(field_mutable:cartographer.cloud.proto.GetSubmapRequest.submap_id)
  return _internal_mutable_submap_id();
}
inline void GetSubmapRequest::set_allocated_submap_id(::cartographer::mapping::proto::SubmapId* submap_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(submap_id_);
  }
  if (submap_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      submap_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, submap_id, submessage_arena);
    }
    
  } else {
    
  }
  submap_id_ = submap_id;
  // @@protoc_insertion_point(field_set_allocated:cartographer.cloud.proto.GetSubmapRequest.submap_id)
}

// -------------------------------------------------------------------

// LoadStateRequest

// .cartographer.mapping.proto.SerializedData serialized_data = 1;
inline bool LoadStateRequest::_internal_has_serialized_data() const {
  return state_chunk_case() == kSerializedData;
}
inline bool LoadStateRequest::has_serialized_data() const {
  return _internal_has_serialized_data();
}
inline void LoadStateRequest::set_has_serialized_data() {
  _oneof_case_[0] = kSerializedData;
}
inline ::cartographer::mapping::proto::SerializedData* LoadStateRequest::release_serialized_data() {
  // @@protoc_insertion_point(field_release:cartographer.cloud.proto.LoadStateRequest.serialized_data)
  if (_internal_has_serialized_data()) {
    clear_has_state_chunk();
      ::cartographer::mapping::proto::SerializedData* temp = state_chunk_.serialized_data_;
    state_chunk_.serialized_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cartographer::mapping::proto::SerializedData& LoadStateRequest::_internal_serialized_data() const {
  return _internal_has_serialized_data()
      ? *state_chunk_.serialized_data_
      : *reinterpret_cast< ::cartographer::mapping::proto::SerializedData*>(&::cartographer::mapping::proto::_SerializedData_default_instance_);
}
inline const ::cartographer::mapping::proto::SerializedData& LoadStateRequest::serialized_data() const {
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.LoadStateRequest.serialized_data)
  return _internal_serialized_data();
}
inline ::cartographer::mapping::proto::SerializedData* LoadStateRequest::_internal_mutable_serialized_data() {
  if (!_internal_has_serialized_data()) {
    clear_state_chunk();
    set_has_serialized_data();
    state_chunk_.serialized_data_ = CreateMaybeMessage< ::cartographer::mapping::proto::SerializedData >(
        GetArenaNoVirtual());
  }
  return state_chunk_.serialized_data_;
}
inline ::cartographer::mapping::proto::SerializedData* LoadStateRequest::mutable_serialized_data() {
  // @@protoc_insertion_point(field_mutable:cartographer.cloud.proto.LoadStateRequest.serialized_data)
  return _internal_mutable_serialized_data();
}

// .cartographer.mapping.proto.SerializationHeader serialization_header = 2;
inline bool LoadStateRequest::_internal_has_serialization_header() const {
  return state_chunk_case() == kSerializationHeader;
}
inline bool LoadStateRequest::has_serialization_header() const {
  return _internal_has_serialization_header();
}
inline void LoadStateRequest::set_has_serialization_header() {
  _oneof_case_[0] = kSerializationHeader;
}
inline ::cartographer::mapping::proto::SerializationHeader* LoadStateRequest::release_serialization_header() {
  // @@protoc_insertion_point(field_release:cartographer.cloud.proto.LoadStateRequest.serialization_header)
  if (_internal_has_serialization_header()) {
    clear_has_state_chunk();
      ::cartographer::mapping::proto::SerializationHeader* temp = state_chunk_.serialization_header_;
    state_chunk_.serialization_header_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cartographer::mapping::proto::SerializationHeader& LoadStateRequest::_internal_serialization_header() const {
  return _internal_has_serialization_header()
      ? *state_chunk_.serialization_header_
      : *reinterpret_cast< ::cartographer::mapping::proto::SerializationHeader*>(&::cartographer::mapping::proto::_SerializationHeader_default_instance_);
}
inline const ::cartographer::mapping::proto::SerializationHeader& LoadStateRequest::serialization_header() const {
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.LoadStateRequest.serialization_header)
  return _internal_serialization_header();
}
inline ::cartographer::mapping::proto::SerializationHeader* LoadStateRequest::_internal_mutable_serialization_header() {
  if (!_internal_has_serialization_header()) {
    clear_state_chunk();
    set_has_serialization_header();
    state_chunk_.serialization_header_ = CreateMaybeMessage< ::cartographer::mapping::proto::SerializationHeader >(
        GetArenaNoVirtual());
  }
  return state_chunk_.serialization_header_;
}
inline ::cartographer::mapping::proto::SerializationHeader* LoadStateRequest::mutable_serialization_header() {
  // @@protoc_insertion_point(field_mutable:cartographer.cloud.proto.LoadStateRequest.serialization_header)
  return _internal_mutable_serialization_header();
}

// string client_id = 3;
inline bool LoadStateRequest::_internal_has_client_id() const {
  return state_chunk_case() == kClientId;
}
inline void LoadStateRequest::set_has_client_id() {
  _oneof_case_[0] = kClientId;
}
inline void LoadStateRequest::clear_client_id() {
  if (_internal_has_client_id()) {
    state_chunk_.client_id_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
    clear_has_state_chunk();
  }
}
inline const std::string& LoadStateRequest::client_id() const {
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.LoadStateRequest.client_id)
  return _internal_client_id();
}
inline void LoadStateRequest::set_client_id(const std::string& value) {
  _internal_set_client_id(value);
  // @@protoc_insertion_point(field_set:cartographer.cloud.proto.LoadStateRequest.client_id)
}
inline std::string* LoadStateRequest::mutable_client_id() {
  // @@protoc_insertion_point(field_mutable:cartographer.cloud.proto.LoadStateRequest.client_id)
  return _internal_mutable_client_id();
}
inline const std::string& LoadStateRequest::_internal_client_id() const {
  if (_internal_has_client_id()) {
    return state_chunk_.client_id_.GetNoArena();
  }
  return *&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void LoadStateRequest::_internal_set_client_id(const std::string& value) {
  if (!_internal_has_client_id()) {
    clear_state_chunk();
    set_has_client_id();
    state_chunk_.client_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  state_chunk_.client_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void LoadStateRequest::set_client_id(std::string&& value) {
  // @@protoc_insertion_point(field_set:cartographer.cloud.proto.LoadStateRequest.client_id)
  if (!_internal_has_client_id()) {
    clear_state_chunk();
    set_has_client_id();
    state_chunk_.client_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  state_chunk_.client_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cartographer.cloud.proto.LoadStateRequest.client_id)
}
inline void LoadStateRequest::set_client_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  if (!_internal_has_client_id()) {
    clear_state_chunk();
    set_has_client_id();
    state_chunk_.client_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  state_chunk_.client_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cartographer.cloud.proto.LoadStateRequest.client_id)
}
inline void LoadStateRequest::set_client_id(const char* value, size_t size) {
  if (!_internal_has_client_id()) {
    clear_state_chunk();
    set_has_client_id();
    state_chunk_.client_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  state_chunk_.client_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cartographer.cloud.proto.LoadStateRequest.client_id)
}
inline std::string* LoadStateRequest::_internal_mutable_client_id() {
  if (!_internal_has_client_id()) {
    clear_state_chunk();
    set_has_client_id();
    state_chunk_.client_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return state_chunk_.client_id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* LoadStateRequest::release_client_id() {
  // @@protoc_insertion_point(field_release:cartographer.cloud.proto.LoadStateRequest.client_id)
  if (_internal_has_client_id()) {
    clear_has_state_chunk();
    return state_chunk_.client_id_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  } else {
    return nullptr;
  }
}
inline void LoadStateRequest::set_allocated_client_id(std::string* client_id) {
  if (has_state_chunk()) {
    clear_state_chunk();
  }
  if (client_id != nullptr) {
    set_has_client_id();
    state_chunk_.client_id_.UnsafeSetDefault(client_id);
  }
  // @@protoc_insertion_point(field_set_allocated:cartographer.cloud.proto.LoadStateRequest.client_id)
}

// bool load_frozen_state = 4;
inline void LoadStateRequest::clear_load_frozen_state() {
  load_frozen_state_ = false;
}
inline bool LoadStateRequest::_internal_load_frozen_state() const {
  return load_frozen_state_;
}
inline bool LoadStateRequest::load_frozen_state() const {
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.LoadStateRequest.load_frozen_state)
  return _internal_load_frozen_state();
}
inline void LoadStateRequest::_internal_set_load_frozen_state(bool value) {
  
  load_frozen_state_ = value;
}
inline void LoadStateRequest::set_load_frozen_state(bool value) {
  _internal_set_load_frozen_state(value);
  // @@protoc_insertion_point(field_set:cartographer.cloud.proto.LoadStateRequest.load_frozen_state)
}

inline bool LoadStateRequest::has_state_chunk() const {
  return state_chunk_case() != STATE_CHUNK_NOT_SET;
}
inline void LoadStateRequest::clear_has_state_chunk() {
  _oneof_case_[0] = STATE_CHUNK_NOT_SET;
}
inline LoadStateRequest::StateChunkCase LoadStateRequest::state_chunk_case() const {
  return LoadStateRequest::StateChunkCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// TrajectoryRemapping

// map<int32, int32> serialized_trajectories_to_trajectories = 1;
inline int TrajectoryRemapping::_internal_serialized_trajectories_to_trajectories_size() const {
  return serialized_trajectories_to_trajectories_.size();
}
inline int TrajectoryRemapping::serialized_trajectories_to_trajectories_size() const {
  return _internal_serialized_trajectories_to_trajectories_size();
}
inline void TrajectoryRemapping::clear_serialized_trajectories_to_trajectories() {
  serialized_trajectories_to_trajectories_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::int32 >&
TrajectoryRemapping::_internal_serialized_trajectories_to_trajectories() const {
  return serialized_trajectories_to_trajectories_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::int32 >&
TrajectoryRemapping::serialized_trajectories_to_trajectories() const {
  // @@protoc_insertion_point(field_map:cartographer.cloud.proto.TrajectoryRemapping.serialized_trajectories_to_trajectories)
  return _internal_serialized_trajectories_to_trajectories();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::int32 >*
TrajectoryRemapping::_internal_mutable_serialized_trajectories_to_trajectories() {
  return serialized_trajectories_to_trajectories_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::int32 >*
TrajectoryRemapping::mutable_serialized_trajectories_to_trajectories() {
  // @@protoc_insertion_point(field_mutable_map:cartographer.cloud.proto.TrajectoryRemapping.serialized_trajectories_to_trajectories)
  return _internal_mutable_serialized_trajectories_to_trajectories();
}

// -------------------------------------------------------------------

// LoadStateResponse

// .cartographer.cloud.proto.TrajectoryRemapping trajectory_remapping = 1;
inline bool LoadStateResponse::_internal_has_trajectory_remapping() const {
  return this != internal_default_instance() && trajectory_remapping_ != nullptr;
}
inline bool LoadStateResponse::has_trajectory_remapping() const {
  return _internal_has_trajectory_remapping();
}
inline void LoadStateResponse::clear_trajectory_remapping() {
  if (GetArenaNoVirtual() == nullptr && trajectory_remapping_ != nullptr) {
    delete trajectory_remapping_;
  }
  trajectory_remapping_ = nullptr;
}
inline const ::cartographer::cloud::proto::TrajectoryRemapping& LoadStateResponse::_internal_trajectory_remapping() const {
  const ::cartographer::cloud::proto::TrajectoryRemapping* p = trajectory_remapping_;
  return p != nullptr ? *p : *reinterpret_cast<const ::cartographer::cloud::proto::TrajectoryRemapping*>(
      &::cartographer::cloud::proto::_TrajectoryRemapping_default_instance_);
}
inline const ::cartographer::cloud::proto::TrajectoryRemapping& LoadStateResponse::trajectory_remapping() const {
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.LoadStateResponse.trajectory_remapping)
  return _internal_trajectory_remapping();
}
inline ::cartographer::cloud::proto::TrajectoryRemapping* LoadStateResponse::release_trajectory_remapping() {
  // @@protoc_insertion_point(field_release:cartographer.cloud.proto.LoadStateResponse.trajectory_remapping)
  
  ::cartographer::cloud::proto::TrajectoryRemapping* temp = trajectory_remapping_;
  trajectory_remapping_ = nullptr;
  return temp;
}
inline ::cartographer::cloud::proto::TrajectoryRemapping* LoadStateResponse::_internal_mutable_trajectory_remapping() {
  
  if (trajectory_remapping_ == nullptr) {
    auto* p = CreateMaybeMessage<::cartographer::cloud::proto::TrajectoryRemapping>(GetArenaNoVirtual());
    trajectory_remapping_ = p;
  }
  return trajectory_remapping_;
}
inline ::cartographer::cloud::proto::TrajectoryRemapping* LoadStateResponse::mutable_trajectory_remapping() {
  // @@protoc_insertion_point(field_mutable:cartographer.cloud.proto.LoadStateResponse.trajectory_remapping)
  return _internal_mutable_trajectory_remapping();
}
inline void LoadStateResponse::set_allocated_trajectory_remapping(::cartographer::cloud::proto::TrajectoryRemapping* trajectory_remapping) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete trajectory_remapping_;
  }
  if (trajectory_remapping) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      trajectory_remapping = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, trajectory_remapping, submessage_arena);
    }
    
  } else {
    
  }
  trajectory_remapping_ = trajectory_remapping;
  // @@protoc_insertion_point(field_set_allocated:cartographer.cloud.proto.LoadStateResponse.trajectory_remapping)
}

// -------------------------------------------------------------------

// LoadStateFromFileRequest

// string file_path = 1;
inline void LoadStateFromFileRequest::clear_file_path() {
  file_path_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& LoadStateFromFileRequest::file_path() const {
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.LoadStateFromFileRequest.file_path)
  return _internal_file_path();
}
inline void LoadStateFromFileRequest::set_file_path(const std::string& value) {
  _internal_set_file_path(value);
  // @@protoc_insertion_point(field_set:cartographer.cloud.proto.LoadStateFromFileRequest.file_path)
}
inline std::string* LoadStateFromFileRequest::mutable_file_path() {
  // @@protoc_insertion_point(field_mutable:cartographer.cloud.proto.LoadStateFromFileRequest.file_path)
  return _internal_mutable_file_path();
}
inline const std::string& LoadStateFromFileRequest::_internal_file_path() const {
  return file_path_.GetNoArena();
}
inline void LoadStateFromFileRequest::_internal_set_file_path(const std::string& value) {
  
  file_path_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void LoadStateFromFileRequest::set_file_path(std::string&& value) {
  
  file_path_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cartographer.cloud.proto.LoadStateFromFileRequest.file_path)
}
inline void LoadStateFromFileRequest::set_file_path(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  file_path_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cartographer.cloud.proto.LoadStateFromFileRequest.file_path)
}
inline void LoadStateFromFileRequest::set_file_path(const char* value, size_t size) {
  
  file_path_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cartographer.cloud.proto.LoadStateFromFileRequest.file_path)
}
inline std::string* LoadStateFromFileRequest::_internal_mutable_file_path() {
  
  return file_path_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* LoadStateFromFileRequest::release_file_path() {
  // @@protoc_insertion_point(field_release:cartographer.cloud.proto.LoadStateFromFileRequest.file_path)
  
  return file_path_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void LoadStateFromFileRequest::set_allocated_file_path(std::string* file_path) {
  if (file_path != nullptr) {
    
  } else {
    
  }
  file_path_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), file_path);
  // @@protoc_insertion_point(field_set_allocated:cartographer.cloud.proto.LoadStateFromFileRequest.file_path)
}

// string client_id = 2;
inline void LoadStateFromFileRequest::clear_client_id() {
  client_id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& LoadStateFromFileRequest::client_id() const {
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.LoadStateFromFileRequest.client_id)
  return _internal_client_id();
}
inline void LoadStateFromFileRequest::set_client_id(const std::string& value) {
  _internal_set_client_id(value);
  // @@protoc_insertion_point(field_set:cartographer.cloud.proto.LoadStateFromFileRequest.client_id)
}
inline std::string* LoadStateFromFileRequest::mutable_client_id() {
  // @@protoc_insertion_point(field_mutable:cartographer.cloud.proto.LoadStateFromFileRequest.client_id)
  return _internal_mutable_client_id();
}
inline const std::string& LoadStateFromFileRequest::_internal_client_id() const {
  return client_id_.GetNoArena();
}
inline void LoadStateFromFileRequest::_internal_set_client_id(const std::string& value) {
  
  client_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void LoadStateFromFileRequest::set_client_id(std::string&& value) {
  
  client_id_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cartographer.cloud.proto.LoadStateFromFileRequest.client_id)
}
inline void LoadStateFromFileRequest::set_client_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  client_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cartographer.cloud.proto.LoadStateFromFileRequest.client_id)
}
inline void LoadStateFromFileRequest::set_client_id(const char* value, size_t size) {
  
  client_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cartographer.cloud.proto.LoadStateFromFileRequest.client_id)
}
inline std::string* LoadStateFromFileRequest::_internal_mutable_client_id() {
  
  return client_id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* LoadStateFromFileRequest::release_client_id() {
  // @@protoc_insertion_point(field_release:cartographer.cloud.proto.LoadStateFromFileRequest.client_id)
  
  return client_id_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void LoadStateFromFileRequest::set_allocated_client_id(std::string* client_id) {
  if (client_id != nullptr) {
    
  } else {
    
  }
  client_id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), client_id);
  // @@protoc_insertion_point(field_set_allocated:cartographer.cloud.proto.LoadStateFromFileRequest.client_id)
}

// bool load_frozen_state = 3;
inline void LoadStateFromFileRequest::clear_load_frozen_state() {
  load_frozen_state_ = false;
}
inline bool LoadStateFromFileRequest::_internal_load_frozen_state() const {
  return load_frozen_state_;
}
inline bool LoadStateFromFileRequest::load_frozen_state() const {
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.LoadStateFromFileRequest.load_frozen_state)
  return _internal_load_frozen_state();
}
inline void LoadStateFromFileRequest::_internal_set_load_frozen_state(bool value) {
  
  load_frozen_state_ = value;
}
inline void LoadStateFromFileRequest::set_load_frozen_state(bool value) {
  _internal_set_load_frozen_state(value);
  // @@protoc_insertion_point(field_set:cartographer.cloud.proto.LoadStateFromFileRequest.load_frozen_state)
}

// -------------------------------------------------------------------

// LoadStateFromFileResponse

// .cartographer.cloud.proto.TrajectoryRemapping trajectory_remapping = 1;
inline bool LoadStateFromFileResponse::_internal_has_trajectory_remapping() const {
  return this != internal_default_instance() && trajectory_remapping_ != nullptr;
}
inline bool LoadStateFromFileResponse::has_trajectory_remapping() const {
  return _internal_has_trajectory_remapping();
}
inline void LoadStateFromFileResponse::clear_trajectory_remapping() {
  if (GetArenaNoVirtual() == nullptr && trajectory_remapping_ != nullptr) {
    delete trajectory_remapping_;
  }
  trajectory_remapping_ = nullptr;
}
inline const ::cartographer::cloud::proto::TrajectoryRemapping& LoadStateFromFileResponse::_internal_trajectory_remapping() const {
  const ::cartographer::cloud::proto::TrajectoryRemapping* p = trajectory_remapping_;
  return p != nullptr ? *p : *reinterpret_cast<const ::cartographer::cloud::proto::TrajectoryRemapping*>(
      &::cartographer::cloud::proto::_TrajectoryRemapping_default_instance_);
}
inline const ::cartographer::cloud::proto::TrajectoryRemapping& LoadStateFromFileResponse::trajectory_remapping() const {
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.LoadStateFromFileResponse.trajectory_remapping)
  return _internal_trajectory_remapping();
}
inline ::cartographer::cloud::proto::TrajectoryRemapping* LoadStateFromFileResponse::release_trajectory_remapping() {
  // @@protoc_insertion_point(field_release:cartographer.cloud.proto.LoadStateFromFileResponse.trajectory_remapping)
  
  ::cartographer::cloud::proto::TrajectoryRemapping* temp = trajectory_remapping_;
  trajectory_remapping_ = nullptr;
  return temp;
}
inline ::cartographer::cloud::proto::TrajectoryRemapping* LoadStateFromFileResponse::_internal_mutable_trajectory_remapping() {
  
  if (trajectory_remapping_ == nullptr) {
    auto* p = CreateMaybeMessage<::cartographer::cloud::proto::TrajectoryRemapping>(GetArenaNoVirtual());
    trajectory_remapping_ = p;
  }
  return trajectory_remapping_;
}
inline ::cartographer::cloud::proto::TrajectoryRemapping* LoadStateFromFileResponse::mutable_trajectory_remapping() {
  // @@protoc_insertion_point(field_mutable:cartographer.cloud.proto.LoadStateFromFileResponse.trajectory_remapping)
  return _internal_mutable_trajectory_remapping();
}
inline void LoadStateFromFileResponse::set_allocated_trajectory_remapping(::cartographer::cloud::proto::TrajectoryRemapping* trajectory_remapping) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete trajectory_remapping_;
  }
  if (trajectory_remapping) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      trajectory_remapping = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, trajectory_remapping, submessage_arena);
    }
    
  } else {
    
  }
  trajectory_remapping_ = trajectory_remapping;
  // @@protoc_insertion_point(field_set_allocated:cartographer.cloud.proto.LoadStateFromFileResponse.trajectory_remapping)
}

// -------------------------------------------------------------------

// GetSubmapResponse

// .cartographer.mapping.proto.SubmapQuery.Response submap_query_response = 1;
inline bool GetSubmapResponse::_internal_has_submap_query_response() const {
  return this != internal_default_instance() && submap_query_response_ != nullptr;
}
inline bool GetSubmapResponse::has_submap_query_response() const {
  return _internal_has_submap_query_response();
}
inline const ::cartographer::mapping::proto::SubmapQuery_Response& GetSubmapResponse::_internal_submap_query_response() const {
  const ::cartographer::mapping::proto::SubmapQuery_Response* p = submap_query_response_;
  return p != nullptr ? *p : *reinterpret_cast<const ::cartographer::mapping::proto::SubmapQuery_Response*>(
      &::cartographer::mapping::proto::_SubmapQuery_Response_default_instance_);
}
inline const ::cartographer::mapping::proto::SubmapQuery_Response& GetSubmapResponse::submap_query_response() const {
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.GetSubmapResponse.submap_query_response)
  return _internal_submap_query_response();
}
inline ::cartographer::mapping::proto::SubmapQuery_Response* GetSubmapResponse::release_submap_query_response() {
  // @@protoc_insertion_point(field_release:cartographer.cloud.proto.GetSubmapResponse.submap_query_response)
  
  ::cartographer::mapping::proto::SubmapQuery_Response* temp = submap_query_response_;
  submap_query_response_ = nullptr;
  return temp;
}
inline ::cartographer::mapping::proto::SubmapQuery_Response* GetSubmapResponse::_internal_mutable_submap_query_response() {
  
  if (submap_query_response_ == nullptr) {
    auto* p = CreateMaybeMessage<::cartographer::mapping::proto::SubmapQuery_Response>(GetArenaNoVirtual());
    submap_query_response_ = p;
  }
  return submap_query_response_;
}
inline ::cartographer::mapping::proto::SubmapQuery_Response* GetSubmapResponse::mutable_submap_query_response() {
  // @@protoc_insertion_point(field_mutable:cartographer.cloud.proto.GetSubmapResponse.submap_query_response)
  return _internal_mutable_submap_query_response();
}
inline void GetSubmapResponse::set_allocated_submap_query_response(::cartographer::mapping::proto::SubmapQuery_Response* submap_query_response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(submap_query_response_);
  }
  if (submap_query_response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      submap_query_response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, submap_query_response, submessage_arena);
    }
    
  } else {
    
  }
  submap_query_response_ = submap_query_response;
  // @@protoc_insertion_point(field_set_allocated:cartographer.cloud.proto.GetSubmapResponse.submap_query_response)
}

// string error_msg = 2;
inline void GetSubmapResponse::clear_error_msg() {
  error_msg_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& GetSubmapResponse::error_msg() const {
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.GetSubmapResponse.error_msg)
  return _internal_error_msg();
}
inline void GetSubmapResponse::set_error_msg(const std::string& value) {
  _internal_set_error_msg(value);
  // @@protoc_insertion_point(field_set:cartographer.cloud.proto.GetSubmapResponse.error_msg)
}
inline std::string* GetSubmapResponse::mutable_error_msg() {
  // @@protoc_insertion_point(field_mutable:cartographer.cloud.proto.GetSubmapResponse.error_msg)
  return _internal_mutable_error_msg();
}
inline const std::string& GetSubmapResponse::_internal_error_msg() const {
  return error_msg_.GetNoArena();
}
inline void GetSubmapResponse::_internal_set_error_msg(const std::string& value) {
  
  error_msg_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void GetSubmapResponse::set_error_msg(std::string&& value) {
  
  error_msg_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cartographer.cloud.proto.GetSubmapResponse.error_msg)
}
inline void GetSubmapResponse::set_error_msg(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  error_msg_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cartographer.cloud.proto.GetSubmapResponse.error_msg)
}
inline void GetSubmapResponse::set_error_msg(const char* value, size_t size) {
  
  error_msg_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cartographer.cloud.proto.GetSubmapResponse.error_msg)
}
inline std::string* GetSubmapResponse::_internal_mutable_error_msg() {
  
  return error_msg_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* GetSubmapResponse::release_error_msg() {
  // @@protoc_insertion_point(field_release:cartographer.cloud.proto.GetSubmapResponse.error_msg)
  
  return error_msg_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void GetSubmapResponse::set_allocated_error_msg(std::string* error_msg) {
  if (error_msg != nullptr) {
    
  } else {
    
  }
  error_msg_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), error_msg);
  // @@protoc_insertion_point(field_set_allocated:cartographer.cloud.proto.GetSubmapResponse.error_msg)
}

// -------------------------------------------------------------------

// TrajectoryNodePose_ConstantPoseData

// int64 timestamp = 1;
inline void TrajectoryNodePose_ConstantPoseData::clear_timestamp() {
  timestamp_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TrajectoryNodePose_ConstantPoseData::_internal_timestamp() const {
  return timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TrajectoryNodePose_ConstantPoseData::timestamp() const {
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.TrajectoryNodePose.ConstantPoseData.timestamp)
  return _internal_timestamp();
}
inline void TrajectoryNodePose_ConstantPoseData::_internal_set_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  timestamp_ = value;
}
inline void TrajectoryNodePose_ConstantPoseData::set_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:cartographer.cloud.proto.TrajectoryNodePose.ConstantPoseData.timestamp)
}

// .cartographer.transform.proto.Rigid3d local_pose = 2;
inline bool TrajectoryNodePose_ConstantPoseData::_internal_has_local_pose() const {
  return this != internal_default_instance() && local_pose_ != nullptr;
}
inline bool TrajectoryNodePose_ConstantPoseData::has_local_pose() const {
  return _internal_has_local_pose();
}
inline const ::cartographer::transform::proto::Rigid3d& TrajectoryNodePose_ConstantPoseData::_internal_local_pose() const {
  const ::cartographer::transform::proto::Rigid3d* p = local_pose_;
  return p != nullptr ? *p : *reinterpret_cast<const ::cartographer::transform::proto::Rigid3d*>(
      &::cartographer::transform::proto::_Rigid3d_default_instance_);
}
inline const ::cartographer::transform::proto::Rigid3d& TrajectoryNodePose_ConstantPoseData::local_pose() const {
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.TrajectoryNodePose.ConstantPoseData.local_pose)
  return _internal_local_pose();
}
inline ::cartographer::transform::proto::Rigid3d* TrajectoryNodePose_ConstantPoseData::release_local_pose() {
  // @@protoc_insertion_point(field_release:cartographer.cloud.proto.TrajectoryNodePose.ConstantPoseData.local_pose)
  
  ::cartographer::transform::proto::Rigid3d* temp = local_pose_;
  local_pose_ = nullptr;
  return temp;
}
inline ::cartographer::transform::proto::Rigid3d* TrajectoryNodePose_ConstantPoseData::_internal_mutable_local_pose() {
  
  if (local_pose_ == nullptr) {
    auto* p = CreateMaybeMessage<::cartographer::transform::proto::Rigid3d>(GetArenaNoVirtual());
    local_pose_ = p;
  }
  return local_pose_;
}
inline ::cartographer::transform::proto::Rigid3d* TrajectoryNodePose_ConstantPoseData::mutable_local_pose() {
  // @@protoc_insertion_point(field_mutable:cartographer.cloud.proto.TrajectoryNodePose.ConstantPoseData.local_pose)
  return _internal_mutable_local_pose();
}
inline void TrajectoryNodePose_ConstantPoseData::set_allocated_local_pose(::cartographer::transform::proto::Rigid3d* local_pose) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(local_pose_);
  }
  if (local_pose) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      local_pose = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, local_pose, submessage_arena);
    }
    
  } else {
    
  }
  local_pose_ = local_pose;
  // @@protoc_insertion_point(field_set_allocated:cartographer.cloud.proto.TrajectoryNodePose.ConstantPoseData.local_pose)
}

// -------------------------------------------------------------------

// TrajectoryNodePose

// .cartographer.mapping.proto.NodeId node_id = 1;
inline bool TrajectoryNodePose::_internal_has_node_id() const {
  return this != internal_default_instance() && node_id_ != nullptr;
}
inline bool TrajectoryNodePose::has_node_id() const {
  return _internal_has_node_id();
}
inline const ::cartographer::mapping::proto::NodeId& TrajectoryNodePose::_internal_node_id() const {
  const ::cartographer::mapping::proto::NodeId* p = node_id_;
  return p != nullptr ? *p : *reinterpret_cast<const ::cartographer::mapping::proto::NodeId*>(
      &::cartographer::mapping::proto::_NodeId_default_instance_);
}
inline const ::cartographer::mapping::proto::NodeId& TrajectoryNodePose::node_id() const {
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.TrajectoryNodePose.node_id)
  return _internal_node_id();
}
inline ::cartographer::mapping::proto::NodeId* TrajectoryNodePose::release_node_id() {
  // @@protoc_insertion_point(field_release:cartographer.cloud.proto.TrajectoryNodePose.node_id)
  
  ::cartographer::mapping::proto::NodeId* temp = node_id_;
  node_id_ = nullptr;
  return temp;
}
inline ::cartographer::mapping::proto::NodeId* TrajectoryNodePose::_internal_mutable_node_id() {
  
  if (node_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::cartographer::mapping::proto::NodeId>(GetArenaNoVirtual());
    node_id_ = p;
  }
  return node_id_;
}
inline ::cartographer::mapping::proto::NodeId* TrajectoryNodePose::mutable_node_id() {
  // @@protoc_insertion_point(field_mutable:cartographer.cloud.proto.TrajectoryNodePose.node_id)
  return _internal_mutable_node_id();
}
inline void TrajectoryNodePose::set_allocated_node_id(::cartographer::mapping::proto::NodeId* node_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(node_id_);
  }
  if (node_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      node_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, node_id, submessage_arena);
    }
    
  } else {
    
  }
  node_id_ = node_id;
  // @@protoc_insertion_point(field_set_allocated:cartographer.cloud.proto.TrajectoryNodePose.node_id)
}

// .cartographer.transform.proto.Rigid3d global_pose = 2;
inline bool TrajectoryNodePose::_internal_has_global_pose() const {
  return this != internal_default_instance() && global_pose_ != nullptr;
}
inline bool TrajectoryNodePose::has_global_pose() const {
  return _internal_has_global_pose();
}
inline const ::cartographer::transform::proto::Rigid3d& TrajectoryNodePose::_internal_global_pose() const {
  const ::cartographer::transform::proto::Rigid3d* p = global_pose_;
  return p != nullptr ? *p : *reinterpret_cast<const ::cartographer::transform::proto::Rigid3d*>(
      &::cartographer::transform::proto::_Rigid3d_default_instance_);
}
inline const ::cartographer::transform::proto::Rigid3d& TrajectoryNodePose::global_pose() const {
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.TrajectoryNodePose.global_pose)
  return _internal_global_pose();
}
inline ::cartographer::transform::proto::Rigid3d* TrajectoryNodePose::release_global_pose() {
  // @@protoc_insertion_point(field_release:cartographer.cloud.proto.TrajectoryNodePose.global_pose)
  
  ::cartographer::transform::proto::Rigid3d* temp = global_pose_;
  global_pose_ = nullptr;
  return temp;
}
inline ::cartographer::transform::proto::Rigid3d* TrajectoryNodePose::_internal_mutable_global_pose() {
  
  if (global_pose_ == nullptr) {
    auto* p = CreateMaybeMessage<::cartographer::transform::proto::Rigid3d>(GetArenaNoVirtual());
    global_pose_ = p;
  }
  return global_pose_;
}
inline ::cartographer::transform::proto::Rigid3d* TrajectoryNodePose::mutable_global_pose() {
  // @@protoc_insertion_point(field_mutable:cartographer.cloud.proto.TrajectoryNodePose.global_pose)
  return _internal_mutable_global_pose();
}
inline void TrajectoryNodePose::set_allocated_global_pose(::cartographer::transform::proto::Rigid3d* global_pose) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(global_pose_);
  }
  if (global_pose) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      global_pose = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, global_pose, submessage_arena);
    }
    
  } else {
    
  }
  global_pose_ = global_pose;
  // @@protoc_insertion_point(field_set_allocated:cartographer.cloud.proto.TrajectoryNodePose.global_pose)
}

// .cartographer.cloud.proto.TrajectoryNodePose.ConstantPoseData constant_pose_data = 3;
inline bool TrajectoryNodePose::_internal_has_constant_pose_data() const {
  return this != internal_default_instance() && constant_pose_data_ != nullptr;
}
inline bool TrajectoryNodePose::has_constant_pose_data() const {
  return _internal_has_constant_pose_data();
}
inline void TrajectoryNodePose::clear_constant_pose_data() {
  if (GetArenaNoVirtual() == nullptr && constant_pose_data_ != nullptr) {
    delete constant_pose_data_;
  }
  constant_pose_data_ = nullptr;
}
inline const ::cartographer::cloud::proto::TrajectoryNodePose_ConstantPoseData& TrajectoryNodePose::_internal_constant_pose_data() const {
  const ::cartographer::cloud::proto::TrajectoryNodePose_ConstantPoseData* p = constant_pose_data_;
  return p != nullptr ? *p : *reinterpret_cast<const ::cartographer::cloud::proto::TrajectoryNodePose_ConstantPoseData*>(
      &::cartographer::cloud::proto::_TrajectoryNodePose_ConstantPoseData_default_instance_);
}
inline const ::cartographer::cloud::proto::TrajectoryNodePose_ConstantPoseData& TrajectoryNodePose::constant_pose_data() const {
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.TrajectoryNodePose.constant_pose_data)
  return _internal_constant_pose_data();
}
inline ::cartographer::cloud::proto::TrajectoryNodePose_ConstantPoseData* TrajectoryNodePose::release_constant_pose_data() {
  // @@protoc_insertion_point(field_release:cartographer.cloud.proto.TrajectoryNodePose.constant_pose_data)
  
  ::cartographer::cloud::proto::TrajectoryNodePose_ConstantPoseData* temp = constant_pose_data_;
  constant_pose_data_ = nullptr;
  return temp;
}
inline ::cartographer::cloud::proto::TrajectoryNodePose_ConstantPoseData* TrajectoryNodePose::_internal_mutable_constant_pose_data() {
  
  if (constant_pose_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::cartographer::cloud::proto::TrajectoryNodePose_ConstantPoseData>(GetArenaNoVirtual());
    constant_pose_data_ = p;
  }
  return constant_pose_data_;
}
inline ::cartographer::cloud::proto::TrajectoryNodePose_ConstantPoseData* TrajectoryNodePose::mutable_constant_pose_data() {
  // @@protoc_insertion_point(field_mutable:cartographer.cloud.proto.TrajectoryNodePose.constant_pose_data)
  return _internal_mutable_constant_pose_data();
}
inline void TrajectoryNodePose::set_allocated_constant_pose_data(::cartographer::cloud::proto::TrajectoryNodePose_ConstantPoseData* constant_pose_data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete constant_pose_data_;
  }
  if (constant_pose_data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      constant_pose_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, constant_pose_data, submessage_arena);
    }
    
  } else {
    
  }
  constant_pose_data_ = constant_pose_data;
  // @@protoc_insertion_point(field_set_allocated:cartographer.cloud.proto.TrajectoryNodePose.constant_pose_data)
}

// -------------------------------------------------------------------

// GetTrajectoryNodePosesResponse

// repeated .cartographer.cloud.proto.TrajectoryNodePose node_poses = 1;
inline int GetTrajectoryNodePosesResponse::_internal_node_poses_size() const {
  return node_poses_.size();
}
inline int GetTrajectoryNodePosesResponse::node_poses_size() const {
  return _internal_node_poses_size();
}
inline void GetTrajectoryNodePosesResponse::clear_node_poses() {
  node_poses_.Clear();
}
inline ::cartographer::cloud::proto::TrajectoryNodePose* GetTrajectoryNodePosesResponse::mutable_node_poses(int index) {
  // @@protoc_insertion_point(field_mutable:cartographer.cloud.proto.GetTrajectoryNodePosesResponse.node_poses)
  return node_poses_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cartographer::cloud::proto::TrajectoryNodePose >*
GetTrajectoryNodePosesResponse::mutable_node_poses() {
  // @@protoc_insertion_point(field_mutable_list:cartographer.cloud.proto.GetTrajectoryNodePosesResponse.node_poses)
  return &node_poses_;
}
inline const ::cartographer::cloud::proto::TrajectoryNodePose& GetTrajectoryNodePosesResponse::_internal_node_poses(int index) const {
  return node_poses_.Get(index);
}
inline const ::cartographer::cloud::proto::TrajectoryNodePose& GetTrajectoryNodePosesResponse::node_poses(int index) const {
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.GetTrajectoryNodePosesResponse.node_poses)
  return _internal_node_poses(index);
}
inline ::cartographer::cloud::proto::TrajectoryNodePose* GetTrajectoryNodePosesResponse::_internal_add_node_poses() {
  return node_poses_.Add();
}
inline ::cartographer::cloud::proto::TrajectoryNodePose* GetTrajectoryNodePosesResponse::add_node_poses() {
  // @@protoc_insertion_point(field_add:cartographer.cloud.proto.GetTrajectoryNodePosesResponse.node_poses)
  return _internal_add_node_poses();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cartographer::cloud::proto::TrajectoryNodePose >&
GetTrajectoryNodePosesResponse::node_poses() const {
  // @@protoc_insertion_point(field_list:cartographer.cloud.proto.GetTrajectoryNodePosesResponse.node_poses)
  return node_poses_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// GetTrajectoryStatesResponse

// map<int32, .cartographer.cloud.proto.TrajectoryState> trajectories_state = 1;
inline int GetTrajectoryStatesResponse::_internal_trajectories_state_size() const {
  return trajectories_state_.size();
}
inline int GetTrajectoryStatesResponse::trajectories_state_size() const {
  return _internal_trajectories_state_size();
}
inline void GetTrajectoryStatesResponse::clear_trajectories_state() {
  trajectories_state_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::int32, ::cartographer::cloud::proto::TrajectoryState >&
GetTrajectoryStatesResponse::_internal_trajectories_state() const {
  return trajectories_state_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::int32, ::cartographer::cloud::proto::TrajectoryState >&
GetTrajectoryStatesResponse::trajectories_state() const {
  // @@protoc_insertion_point(field_map:cartographer.cloud.proto.GetTrajectoryStatesResponse.trajectories_state)
  return _internal_trajectories_state();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::int32, ::cartographer::cloud::proto::TrajectoryState >*
GetTrajectoryStatesResponse::_internal_mutable_trajectories_state() {
  return trajectories_state_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::int32, ::cartographer::cloud::proto::TrajectoryState >*
GetTrajectoryStatesResponse::mutable_trajectories_state() {
  // @@protoc_insertion_point(field_mutable_map:cartographer.cloud.proto.GetTrajectoryStatesResponse.trajectories_state)
  return _internal_mutable_trajectories_state();
}

// -------------------------------------------------------------------

// GetLandmarkPosesResponse

// repeated .cartographer.mapping.proto.PoseGraph.LandmarkPose landmark_poses = 1;
inline int GetLandmarkPosesResponse::_internal_landmark_poses_size() const {
  return landmark_poses_.size();
}
inline int GetLandmarkPosesResponse::landmark_poses_size() const {
  return _internal_landmark_poses_size();
}
inline ::cartographer::mapping::proto::PoseGraph_LandmarkPose* GetLandmarkPosesResponse::mutable_landmark_poses(int index) {
  // @@protoc_insertion_point(field_mutable:cartographer.cloud.proto.GetLandmarkPosesResponse.landmark_poses)
  return landmark_poses_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cartographer::mapping::proto::PoseGraph_LandmarkPose >*
GetLandmarkPosesResponse::mutable_landmark_poses() {
  // @@protoc_insertion_point(field_mutable_list:cartographer.cloud.proto.GetLandmarkPosesResponse.landmark_poses)
  return &landmark_poses_;
}
inline const ::cartographer::mapping::proto::PoseGraph_LandmarkPose& GetLandmarkPosesResponse::_internal_landmark_poses(int index) const {
  return landmark_poses_.Get(index);
}
inline const ::cartographer::mapping::proto::PoseGraph_LandmarkPose& GetLandmarkPosesResponse::landmark_poses(int index) const {
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.GetLandmarkPosesResponse.landmark_poses)
  return _internal_landmark_poses(index);
}
inline ::cartographer::mapping::proto::PoseGraph_LandmarkPose* GetLandmarkPosesResponse::_internal_add_landmark_poses() {
  return landmark_poses_.Add();
}
inline ::cartographer::mapping::proto::PoseGraph_LandmarkPose* GetLandmarkPosesResponse::add_landmark_poses() {
  // @@protoc_insertion_point(field_add:cartographer.cloud.proto.GetLandmarkPosesResponse.landmark_poses)
  return _internal_add_landmark_poses();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cartographer::mapping::proto::PoseGraph_LandmarkPose >&
GetLandmarkPosesResponse::landmark_poses() const {
  // @@protoc_insertion_point(field_list:cartographer.cloud.proto.GetLandmarkPosesResponse.landmark_poses)
  return landmark_poses_;
}

// -------------------------------------------------------------------

// SetLandmarkPoseRequest

// .cartographer.mapping.proto.PoseGraph.LandmarkPose landmark_pose = 1;
inline bool SetLandmarkPoseRequest::_internal_has_landmark_pose() const {
  return this != internal_default_instance() && landmark_pose_ != nullptr;
}
inline bool SetLandmarkPoseRequest::has_landmark_pose() const {
  return _internal_has_landmark_pose();
}
inline const ::cartographer::mapping::proto::PoseGraph_LandmarkPose& SetLandmarkPoseRequest::_internal_landmark_pose() const {
  const ::cartographer::mapping::proto::PoseGraph_LandmarkPose* p = landmark_pose_;
  return p != nullptr ? *p : *reinterpret_cast<const ::cartographer::mapping::proto::PoseGraph_LandmarkPose*>(
      &::cartographer::mapping::proto::_PoseGraph_LandmarkPose_default_instance_);
}
inline const ::cartographer::mapping::proto::PoseGraph_LandmarkPose& SetLandmarkPoseRequest::landmark_pose() const {
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.SetLandmarkPoseRequest.landmark_pose)
  return _internal_landmark_pose();
}
inline ::cartographer::mapping::proto::PoseGraph_LandmarkPose* SetLandmarkPoseRequest::release_landmark_pose() {
  // @@protoc_insertion_point(field_release:cartographer.cloud.proto.SetLandmarkPoseRequest.landmark_pose)
  
  ::cartographer::mapping::proto::PoseGraph_LandmarkPose* temp = landmark_pose_;
  landmark_pose_ = nullptr;
  return temp;
}
inline ::cartographer::mapping::proto::PoseGraph_LandmarkPose* SetLandmarkPoseRequest::_internal_mutable_landmark_pose() {
  
  if (landmark_pose_ == nullptr) {
    auto* p = CreateMaybeMessage<::cartographer::mapping::proto::PoseGraph_LandmarkPose>(GetArenaNoVirtual());
    landmark_pose_ = p;
  }
  return landmark_pose_;
}
inline ::cartographer::mapping::proto::PoseGraph_LandmarkPose* SetLandmarkPoseRequest::mutable_landmark_pose() {
  // @@protoc_insertion_point(field_mutable:cartographer.cloud.proto.SetLandmarkPoseRequest.landmark_pose)
  return _internal_mutable_landmark_pose();
}
inline void SetLandmarkPoseRequest::set_allocated_landmark_pose(::cartographer::mapping::proto::PoseGraph_LandmarkPose* landmark_pose) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(landmark_pose_);
  }
  if (landmark_pose) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      landmark_pose = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, landmark_pose, submessage_arena);
    }
    
  } else {
    
  }
  landmark_pose_ = landmark_pose;
  // @@protoc_insertion_point(field_set_allocated:cartographer.cloud.proto.SetLandmarkPoseRequest.landmark_pose)
}

// -------------------------------------------------------------------

// SubmapPose

// .cartographer.mapping.proto.SubmapId submap_id = 1;
inline bool SubmapPose::_internal_has_submap_id() const {
  return this != internal_default_instance() && submap_id_ != nullptr;
}
inline bool SubmapPose::has_submap_id() const {
  return _internal_has_submap_id();
}
inline const ::cartographer::mapping::proto::SubmapId& SubmapPose::_internal_submap_id() const {
  const ::cartographer::mapping::proto::SubmapId* p = submap_id_;
  return p != nullptr ? *p : *reinterpret_cast<const ::cartographer::mapping::proto::SubmapId*>(
      &::cartographer::mapping::proto::_SubmapId_default_instance_);
}
inline const ::cartographer::mapping::proto::SubmapId& SubmapPose::submap_id() const {
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.SubmapPose.submap_id)
  return _internal_submap_id();
}
inline ::cartographer::mapping::proto::SubmapId* SubmapPose::release_submap_id() {
  // @@protoc_insertion_point(field_release:cartographer.cloud.proto.SubmapPose.submap_id)
  
  ::cartographer::mapping::proto::SubmapId* temp = submap_id_;
  submap_id_ = nullptr;
  return temp;
}
inline ::cartographer::mapping::proto::SubmapId* SubmapPose::_internal_mutable_submap_id() {
  
  if (submap_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::cartographer::mapping::proto::SubmapId>(GetArenaNoVirtual());
    submap_id_ = p;
  }
  return submap_id_;
}
inline ::cartographer::mapping::proto::SubmapId* SubmapPose::mutable_submap_id() {
  // @@protoc_insertion_point(field_mutable:cartographer.cloud.proto.SubmapPose.submap_id)
  return _internal_mutable_submap_id();
}
inline void SubmapPose::set_allocated_submap_id(::cartographer::mapping::proto::SubmapId* submap_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(submap_id_);
  }
  if (submap_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      submap_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, submap_id, submessage_arena);
    }
    
  } else {
    
  }
  submap_id_ = submap_id;
  // @@protoc_insertion_point(field_set_allocated:cartographer.cloud.proto.SubmapPose.submap_id)
}

// int32 submap_version = 2;
inline void SubmapPose::clear_submap_version() {
  submap_version_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SubmapPose::_internal_submap_version() const {
  return submap_version_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SubmapPose::submap_version() const {
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.SubmapPose.submap_version)
  return _internal_submap_version();
}
inline void SubmapPose::_internal_set_submap_version(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  submap_version_ = value;
}
inline void SubmapPose::set_submap_version(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_submap_version(value);
  // @@protoc_insertion_point(field_set:cartographer.cloud.proto.SubmapPose.submap_version)
}

// .cartographer.transform.proto.Rigid3d global_pose = 3;
inline bool SubmapPose::_internal_has_global_pose() const {
  return this != internal_default_instance() && global_pose_ != nullptr;
}
inline bool SubmapPose::has_global_pose() const {
  return _internal_has_global_pose();
}
inline const ::cartographer::transform::proto::Rigid3d& SubmapPose::_internal_global_pose() const {
  const ::cartographer::transform::proto::Rigid3d* p = global_pose_;
  return p != nullptr ? *p : *reinterpret_cast<const ::cartographer::transform::proto::Rigid3d*>(
      &::cartographer::transform::proto::_Rigid3d_default_instance_);
}
inline const ::cartographer::transform::proto::Rigid3d& SubmapPose::global_pose() const {
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.SubmapPose.global_pose)
  return _internal_global_pose();
}
inline ::cartographer::transform::proto::Rigid3d* SubmapPose::release_global_pose() {
  // @@protoc_insertion_point(field_release:cartographer.cloud.proto.SubmapPose.global_pose)
  
  ::cartographer::transform::proto::Rigid3d* temp = global_pose_;
  global_pose_ = nullptr;
  return temp;
}
inline ::cartographer::transform::proto::Rigid3d* SubmapPose::_internal_mutable_global_pose() {
  
  if (global_pose_ == nullptr) {
    auto* p = CreateMaybeMessage<::cartographer::transform::proto::Rigid3d>(GetArenaNoVirtual());
    global_pose_ = p;
  }
  return global_pose_;
}
inline ::cartographer::transform::proto::Rigid3d* SubmapPose::mutable_global_pose() {
  // @@protoc_insertion_point(field_mutable:cartographer.cloud.proto.SubmapPose.global_pose)
  return _internal_mutable_global_pose();
}
inline void SubmapPose::set_allocated_global_pose(::cartographer::transform::proto::Rigid3d* global_pose) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(global_pose_);
  }
  if (global_pose) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      global_pose = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, global_pose, submessage_arena);
    }
    
  } else {
    
  }
  global_pose_ = global_pose;
  // @@protoc_insertion_point(field_set_allocated:cartographer.cloud.proto.SubmapPose.global_pose)
}

// -------------------------------------------------------------------

// GetAllSubmapPosesResponse

// repeated .cartographer.cloud.proto.SubmapPose submap_poses = 1;
inline int GetAllSubmapPosesResponse::_internal_submap_poses_size() const {
  return submap_poses_.size();
}
inline int GetAllSubmapPosesResponse::submap_poses_size() const {
  return _internal_submap_poses_size();
}
inline void GetAllSubmapPosesResponse::clear_submap_poses() {
  submap_poses_.Clear();
}
inline ::cartographer::cloud::proto::SubmapPose* GetAllSubmapPosesResponse::mutable_submap_poses(int index) {
  // @@protoc_insertion_point(field_mutable:cartographer.cloud.proto.GetAllSubmapPosesResponse.submap_poses)
  return submap_poses_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cartographer::cloud::proto::SubmapPose >*
GetAllSubmapPosesResponse::mutable_submap_poses() {
  // @@protoc_insertion_point(field_mutable_list:cartographer.cloud.proto.GetAllSubmapPosesResponse.submap_poses)
  return &submap_poses_;
}
inline const ::cartographer::cloud::proto::SubmapPose& GetAllSubmapPosesResponse::_internal_submap_poses(int index) const {
  return submap_poses_.Get(index);
}
inline const ::cartographer::cloud::proto::SubmapPose& GetAllSubmapPosesResponse::submap_poses(int index) const {
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.GetAllSubmapPosesResponse.submap_poses)
  return _internal_submap_poses(index);
}
inline ::cartographer::cloud::proto::SubmapPose* GetAllSubmapPosesResponse::_internal_add_submap_poses() {
  return submap_poses_.Add();
}
inline ::cartographer::cloud::proto::SubmapPose* GetAllSubmapPosesResponse::add_submap_poses() {
  // @@protoc_insertion_point(field_add:cartographer.cloud.proto.GetAllSubmapPosesResponse.submap_poses)
  return _internal_add_submap_poses();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cartographer::cloud::proto::SubmapPose >&
GetAllSubmapPosesResponse::submap_poses() const {
  // @@protoc_insertion_point(field_list:cartographer.cloud.proto.GetAllSubmapPosesResponse.submap_poses)
  return submap_poses_;
}

// -------------------------------------------------------------------

// GetLocalToGlobalTransformRequest

// int32 trajectory_id = 1;
inline void GetLocalToGlobalTransformRequest::clear_trajectory_id() {
  trajectory_id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GetLocalToGlobalTransformRequest::_internal_trajectory_id() const {
  return trajectory_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GetLocalToGlobalTransformRequest::trajectory_id() const {
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.GetLocalToGlobalTransformRequest.trajectory_id)
  return _internal_trajectory_id();
}
inline void GetLocalToGlobalTransformRequest::_internal_set_trajectory_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  trajectory_id_ = value;
}
inline void GetLocalToGlobalTransformRequest::set_trajectory_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_trajectory_id(value);
  // @@protoc_insertion_point(field_set:cartographer.cloud.proto.GetLocalToGlobalTransformRequest.trajectory_id)
}

// -------------------------------------------------------------------

// GetLocalToGlobalTransformResponse

// .cartographer.transform.proto.Rigid3d local_to_global = 1;
inline bool GetLocalToGlobalTransformResponse::_internal_has_local_to_global() const {
  return this != internal_default_instance() && local_to_global_ != nullptr;
}
inline bool GetLocalToGlobalTransformResponse::has_local_to_global() const {
  return _internal_has_local_to_global();
}
inline const ::cartographer::transform::proto::Rigid3d& GetLocalToGlobalTransformResponse::_internal_local_to_global() const {
  const ::cartographer::transform::proto::Rigid3d* p = local_to_global_;
  return p != nullptr ? *p : *reinterpret_cast<const ::cartographer::transform::proto::Rigid3d*>(
      &::cartographer::transform::proto::_Rigid3d_default_instance_);
}
inline const ::cartographer::transform::proto::Rigid3d& GetLocalToGlobalTransformResponse::local_to_global() const {
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.GetLocalToGlobalTransformResponse.local_to_global)
  return _internal_local_to_global();
}
inline ::cartographer::transform::proto::Rigid3d* GetLocalToGlobalTransformResponse::release_local_to_global() {
  // @@protoc_insertion_point(field_release:cartographer.cloud.proto.GetLocalToGlobalTransformResponse.local_to_global)
  
  ::cartographer::transform::proto::Rigid3d* temp = local_to_global_;
  local_to_global_ = nullptr;
  return temp;
}
inline ::cartographer::transform::proto::Rigid3d* GetLocalToGlobalTransformResponse::_internal_mutable_local_to_global() {
  
  if (local_to_global_ == nullptr) {
    auto* p = CreateMaybeMessage<::cartographer::transform::proto::Rigid3d>(GetArenaNoVirtual());
    local_to_global_ = p;
  }
  return local_to_global_;
}
inline ::cartographer::transform::proto::Rigid3d* GetLocalToGlobalTransformResponse::mutable_local_to_global() {
  // @@protoc_insertion_point(field_mutable:cartographer.cloud.proto.GetLocalToGlobalTransformResponse.local_to_global)
  return _internal_mutable_local_to_global();
}
inline void GetLocalToGlobalTransformResponse::set_allocated_local_to_global(::cartographer::transform::proto::Rigid3d* local_to_global) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(local_to_global_);
  }
  if (local_to_global) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      local_to_global = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, local_to_global, submessage_arena);
    }
    
  } else {
    
  }
  local_to_global_ = local_to_global;
  // @@protoc_insertion_point(field_set_allocated:cartographer.cloud.proto.GetLocalToGlobalTransformResponse.local_to_global)
}

// -------------------------------------------------------------------

// GetConstraintsResponse

// repeated .cartographer.mapping.proto.PoseGraph.Constraint constraints = 1;
inline int GetConstraintsResponse::_internal_constraints_size() const {
  return constraints_.size();
}
inline int GetConstraintsResponse::constraints_size() const {
  return _internal_constraints_size();
}
inline ::cartographer::mapping::proto::PoseGraph_Constraint* GetConstraintsResponse::mutable_constraints(int index) {
  // @@protoc_insertion_point(field_mutable:cartographer.cloud.proto.GetConstraintsResponse.constraints)
  return constraints_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cartographer::mapping::proto::PoseGraph_Constraint >*
GetConstraintsResponse::mutable_constraints() {
  // @@protoc_insertion_point(field_mutable_list:cartographer.cloud.proto.GetConstraintsResponse.constraints)
  return &constraints_;
}
inline const ::cartographer::mapping::proto::PoseGraph_Constraint& GetConstraintsResponse::_internal_constraints(int index) const {
  return constraints_.Get(index);
}
inline const ::cartographer::mapping::proto::PoseGraph_Constraint& GetConstraintsResponse::constraints(int index) const {
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.GetConstraintsResponse.constraints)
  return _internal_constraints(index);
}
inline ::cartographer::mapping::proto::PoseGraph_Constraint* GetConstraintsResponse::_internal_add_constraints() {
  return constraints_.Add();
}
inline ::cartographer::mapping::proto::PoseGraph_Constraint* GetConstraintsResponse::add_constraints() {
  // @@protoc_insertion_point(field_add:cartographer.cloud.proto.GetConstraintsResponse.constraints)
  return _internal_add_constraints();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cartographer::mapping::proto::PoseGraph_Constraint >&
GetConstraintsResponse::constraints() const {
  // @@protoc_insertion_point(field_list:cartographer.cloud.proto.GetConstraintsResponse.constraints)
  return constraints_;
}

// -------------------------------------------------------------------

// WriteStateResponse

// .cartographer.mapping.proto.SerializationHeader header = 1;
inline bool WriteStateResponse::_internal_has_header() const {
  return state_chunk_case() == kHeader;
}
inline bool WriteStateResponse::has_header() const {
  return _internal_has_header();
}
inline void WriteStateResponse::set_has_header() {
  _oneof_case_[0] = kHeader;
}
inline ::cartographer::mapping::proto::SerializationHeader* WriteStateResponse::release_header() {
  // @@protoc_insertion_point(field_release:cartographer.cloud.proto.WriteStateResponse.header)
  if (_internal_has_header()) {
    clear_has_state_chunk();
      ::cartographer::mapping::proto::SerializationHeader* temp = state_chunk_.header_;
    state_chunk_.header_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cartographer::mapping::proto::SerializationHeader& WriteStateResponse::_internal_header() const {
  return _internal_has_header()
      ? *state_chunk_.header_
      : *reinterpret_cast< ::cartographer::mapping::proto::SerializationHeader*>(&::cartographer::mapping::proto::_SerializationHeader_default_instance_);
}
inline const ::cartographer::mapping::proto::SerializationHeader& WriteStateResponse::header() const {
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.WriteStateResponse.header)
  return _internal_header();
}
inline ::cartographer::mapping::proto::SerializationHeader* WriteStateResponse::_internal_mutable_header() {
  if (!_internal_has_header()) {
    clear_state_chunk();
    set_has_header();
    state_chunk_.header_ = CreateMaybeMessage< ::cartographer::mapping::proto::SerializationHeader >(
        GetArenaNoVirtual());
  }
  return state_chunk_.header_;
}
inline ::cartographer::mapping::proto::SerializationHeader* WriteStateResponse::mutable_header() {
  // @@protoc_insertion_point(field_mutable:cartographer.cloud.proto.WriteStateResponse.header)
  return _internal_mutable_header();
}

// .cartographer.mapping.proto.SerializedData serialized_data = 2;
inline bool WriteStateResponse::_internal_has_serialized_data() const {
  return state_chunk_case() == kSerializedData;
}
inline bool WriteStateResponse::has_serialized_data() const {
  return _internal_has_serialized_data();
}
inline void WriteStateResponse::set_has_serialized_data() {
  _oneof_case_[0] = kSerializedData;
}
inline ::cartographer::mapping::proto::SerializedData* WriteStateResponse::release_serialized_data() {
  // @@protoc_insertion_point(field_release:cartographer.cloud.proto.WriteStateResponse.serialized_data)
  if (_internal_has_serialized_data()) {
    clear_has_state_chunk();
      ::cartographer::mapping::proto::SerializedData* temp = state_chunk_.serialized_data_;
    state_chunk_.serialized_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cartographer::mapping::proto::SerializedData& WriteStateResponse::_internal_serialized_data() const {
  return _internal_has_serialized_data()
      ? *state_chunk_.serialized_data_
      : *reinterpret_cast< ::cartographer::mapping::proto::SerializedData*>(&::cartographer::mapping::proto::_SerializedData_default_instance_);
}
inline const ::cartographer::mapping::proto::SerializedData& WriteStateResponse::serialized_data() const {
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.WriteStateResponse.serialized_data)
  return _internal_serialized_data();
}
inline ::cartographer::mapping::proto::SerializedData* WriteStateResponse::_internal_mutable_serialized_data() {
  if (!_internal_has_serialized_data()) {
    clear_state_chunk();
    set_has_serialized_data();
    state_chunk_.serialized_data_ = CreateMaybeMessage< ::cartographer::mapping::proto::SerializedData >(
        GetArenaNoVirtual());
  }
  return state_chunk_.serialized_data_;
}
inline ::cartographer::mapping::proto::SerializedData* WriteStateResponse::mutable_serialized_data() {
  // @@protoc_insertion_point(field_mutable:cartographer.cloud.proto.WriteStateResponse.serialized_data)
  return _internal_mutable_serialized_data();
}

inline bool WriteStateResponse::has_state_chunk() const {
  return state_chunk_case() != STATE_CHUNK_NOT_SET;
}
inline void WriteStateResponse::clear_has_state_chunk() {
  _oneof_case_[0] = STATE_CHUNK_NOT_SET;
}
inline WriteStateResponse::StateChunkCase WriteStateResponse::state_chunk_case() const {
  return WriteStateResponse::StateChunkCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// WriteStateToFileRequest

// string filename = 1;
inline void WriteStateToFileRequest::clear_filename() {
  filename_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& WriteStateToFileRequest::filename() const {
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.WriteStateToFileRequest.filename)
  return _internal_filename();
}
inline void WriteStateToFileRequest::set_filename(const std::string& value) {
  _internal_set_filename(value);
  // @@protoc_insertion_point(field_set:cartographer.cloud.proto.WriteStateToFileRequest.filename)
}
inline std::string* WriteStateToFileRequest::mutable_filename() {
  // @@protoc_insertion_point(field_mutable:cartographer.cloud.proto.WriteStateToFileRequest.filename)
  return _internal_mutable_filename();
}
inline const std::string& WriteStateToFileRequest::_internal_filename() const {
  return filename_.GetNoArena();
}
inline void WriteStateToFileRequest::_internal_set_filename(const std::string& value) {
  
  filename_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void WriteStateToFileRequest::set_filename(std::string&& value) {
  
  filename_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cartographer.cloud.proto.WriteStateToFileRequest.filename)
}
inline void WriteStateToFileRequest::set_filename(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  filename_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cartographer.cloud.proto.WriteStateToFileRequest.filename)
}
inline void WriteStateToFileRequest::set_filename(const char* value, size_t size) {
  
  filename_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cartographer.cloud.proto.WriteStateToFileRequest.filename)
}
inline std::string* WriteStateToFileRequest::_internal_mutable_filename() {
  
  return filename_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* WriteStateToFileRequest::release_filename() {
  // @@protoc_insertion_point(field_release:cartographer.cloud.proto.WriteStateToFileRequest.filename)
  
  return filename_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void WriteStateToFileRequest::set_allocated_filename(std::string* filename) {
  if (filename != nullptr) {
    
  } else {
    
  }
  filename_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), filename);
  // @@protoc_insertion_point(field_set_allocated:cartographer.cloud.proto.WriteStateToFileRequest.filename)
}

// -------------------------------------------------------------------

// WriteStateToFileResponse

// bool success = 1;
inline void WriteStateToFileResponse::clear_success() {
  success_ = false;
}
inline bool WriteStateToFileResponse::_internal_success() const {
  return success_;
}
inline bool WriteStateToFileResponse::success() const {
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.WriteStateToFileResponse.success)
  return _internal_success();
}
inline void WriteStateToFileResponse::_internal_set_success(bool value) {
  
  success_ = value;
}
inline void WriteStateToFileResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:cartographer.cloud.proto.WriteStateToFileResponse.success)
}

// int32 code = 2;
inline void WriteStateToFileResponse::clear_code() {
  code_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 WriteStateToFileResponse::_internal_code() const {
  return code_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 WriteStateToFileResponse::code() const {
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.WriteStateToFileResponse.code)
  return _internal_code();
}
inline void WriteStateToFileResponse::_internal_set_code(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  code_ = value;
}
inline void WriteStateToFileResponse::set_code(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:cartographer.cloud.proto.WriteStateToFileResponse.code)
}

// string message = 3;
inline void WriteStateToFileResponse::clear_message() {
  message_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& WriteStateToFileResponse::message() const {
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.WriteStateToFileResponse.message)
  return _internal_message();
}
inline void WriteStateToFileResponse::set_message(const std::string& value) {
  _internal_set_message(value);
  // @@protoc_insertion_point(field_set:cartographer.cloud.proto.WriteStateToFileResponse.message)
}
inline std::string* WriteStateToFileResponse::mutable_message() {
  // @@protoc_insertion_point(field_mutable:cartographer.cloud.proto.WriteStateToFileResponse.message)
  return _internal_mutable_message();
}
inline const std::string& WriteStateToFileResponse::_internal_message() const {
  return message_.GetNoArena();
}
inline void WriteStateToFileResponse::_internal_set_message(const std::string& value) {
  
  message_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void WriteStateToFileResponse::set_message(std::string&& value) {
  
  message_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cartographer.cloud.proto.WriteStateToFileResponse.message)
}
inline void WriteStateToFileResponse::set_message(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  message_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cartographer.cloud.proto.WriteStateToFileResponse.message)
}
inline void WriteStateToFileResponse::set_message(const char* value, size_t size) {
  
  message_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cartographer.cloud.proto.WriteStateToFileResponse.message)
}
inline std::string* WriteStateToFileResponse::_internal_mutable_message() {
  
  return message_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* WriteStateToFileResponse::release_message() {
  // @@protoc_insertion_point(field_release:cartographer.cloud.proto.WriteStateToFileResponse.message)
  
  return message_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void WriteStateToFileResponse::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  message_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:cartographer.cloud.proto.WriteStateToFileResponse.message)
}

// -------------------------------------------------------------------

// IsTrajectoryFinishedRequest

// int32 trajectory_id = 1;
inline void IsTrajectoryFinishedRequest::clear_trajectory_id() {
  trajectory_id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 IsTrajectoryFinishedRequest::_internal_trajectory_id() const {
  return trajectory_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 IsTrajectoryFinishedRequest::trajectory_id() const {
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.IsTrajectoryFinishedRequest.trajectory_id)
  return _internal_trajectory_id();
}
inline void IsTrajectoryFinishedRequest::_internal_set_trajectory_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  trajectory_id_ = value;
}
inline void IsTrajectoryFinishedRequest::set_trajectory_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_trajectory_id(value);
  // @@protoc_insertion_point(field_set:cartographer.cloud.proto.IsTrajectoryFinishedRequest.trajectory_id)
}

// -------------------------------------------------------------------

// IsTrajectoryFinishedResponse

// bool is_finished = 1;
inline void IsTrajectoryFinishedResponse::clear_is_finished() {
  is_finished_ = false;
}
inline bool IsTrajectoryFinishedResponse::_internal_is_finished() const {
  return is_finished_;
}
inline bool IsTrajectoryFinishedResponse::is_finished() const {
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.IsTrajectoryFinishedResponse.is_finished)
  return _internal_is_finished();
}
inline void IsTrajectoryFinishedResponse::_internal_set_is_finished(bool value) {
  
  is_finished_ = value;
}
inline void IsTrajectoryFinishedResponse::set_is_finished(bool value) {
  _internal_set_is_finished(value);
  // @@protoc_insertion_point(field_set:cartographer.cloud.proto.IsTrajectoryFinishedResponse.is_finished)
}

// -------------------------------------------------------------------

// IsTrajectoryFrozenRequest

// int32 trajectory_id = 1;
inline void IsTrajectoryFrozenRequest::clear_trajectory_id() {
  trajectory_id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 IsTrajectoryFrozenRequest::_internal_trajectory_id() const {
  return trajectory_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 IsTrajectoryFrozenRequest::trajectory_id() const {
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.IsTrajectoryFrozenRequest.trajectory_id)
  return _internal_trajectory_id();
}
inline void IsTrajectoryFrozenRequest::_internal_set_trajectory_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  trajectory_id_ = value;
}
inline void IsTrajectoryFrozenRequest::set_trajectory_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_trajectory_id(value);
  // @@protoc_insertion_point(field_set:cartographer.cloud.proto.IsTrajectoryFrozenRequest.trajectory_id)
}

// -------------------------------------------------------------------

// IsTrajectoryFrozenResponse

// bool is_frozen = 1;
inline void IsTrajectoryFrozenResponse::clear_is_frozen() {
  is_frozen_ = false;
}
inline bool IsTrajectoryFrozenResponse::_internal_is_frozen() const {
  return is_frozen_;
}
inline bool IsTrajectoryFrozenResponse::is_frozen() const {
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.IsTrajectoryFrozenResponse.is_frozen)
  return _internal_is_frozen();
}
inline void IsTrajectoryFrozenResponse::_internal_set_is_frozen(bool value) {
  
  is_frozen_ = value;
}
inline void IsTrajectoryFrozenResponse::set_is_frozen(bool value) {
  _internal_set_is_frozen(value);
  // @@protoc_insertion_point(field_set:cartographer.cloud.proto.IsTrajectoryFrozenResponse.is_frozen)
}

// -------------------------------------------------------------------

// OKagv_StartTrajectoryResponse

// bool state = 1;
inline void OKagv_StartTrajectoryResponse::clear_state() {
  state_ = false;
}
inline bool OKagv_StartTrajectoryResponse::_internal_state() const {
  return state_;
}
inline bool OKagv_StartTrajectoryResponse::state() const {
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.OKagv_StartTrajectoryResponse.state)
  return _internal_state();
}
inline void OKagv_StartTrajectoryResponse::_internal_set_state(bool value) {
  
  state_ = value;
}
inline void OKagv_StartTrajectoryResponse::set_state(bool value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:cartographer.cloud.proto.OKagv_StartTrajectoryResponse.state)
}

// int32 code = 2;
inline void OKagv_StartTrajectoryResponse::clear_code() {
  code_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 OKagv_StartTrajectoryResponse::_internal_code() const {
  return code_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 OKagv_StartTrajectoryResponse::code() const {
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.OKagv_StartTrajectoryResponse.code)
  return _internal_code();
}
inline void OKagv_StartTrajectoryResponse::_internal_set_code(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  code_ = value;
}
inline void OKagv_StartTrajectoryResponse::set_code(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:cartographer.cloud.proto.OKagv_StartTrajectoryResponse.code)
}

// string message = 3;
inline void OKagv_StartTrajectoryResponse::clear_message() {
  message_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& OKagv_StartTrajectoryResponse::message() const {
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.OKagv_StartTrajectoryResponse.message)
  return _internal_message();
}
inline void OKagv_StartTrajectoryResponse::set_message(const std::string& value) {
  _internal_set_message(value);
  // @@protoc_insertion_point(field_set:cartographer.cloud.proto.OKagv_StartTrajectoryResponse.message)
}
inline std::string* OKagv_StartTrajectoryResponse::mutable_message() {
  // @@protoc_insertion_point(field_mutable:cartographer.cloud.proto.OKagv_StartTrajectoryResponse.message)
  return _internal_mutable_message();
}
inline const std::string& OKagv_StartTrajectoryResponse::_internal_message() const {
  return message_.GetNoArena();
}
inline void OKagv_StartTrajectoryResponse::_internal_set_message(const std::string& value) {
  
  message_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void OKagv_StartTrajectoryResponse::set_message(std::string&& value) {
  
  message_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cartographer.cloud.proto.OKagv_StartTrajectoryResponse.message)
}
inline void OKagv_StartTrajectoryResponse::set_message(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  message_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cartographer.cloud.proto.OKagv_StartTrajectoryResponse.message)
}
inline void OKagv_StartTrajectoryResponse::set_message(const char* value, size_t size) {
  
  message_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cartographer.cloud.proto.OKagv_StartTrajectoryResponse.message)
}
inline std::string* OKagv_StartTrajectoryResponse::_internal_mutable_message() {
  
  return message_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* OKagv_StartTrajectoryResponse::release_message() {
  // @@protoc_insertion_point(field_release:cartographer.cloud.proto.OKagv_StartTrajectoryResponse.message)
  
  return message_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void OKagv_StartTrajectoryResponse::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  message_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:cartographer.cloud.proto.OKagv_StartTrajectoryResponse.message)
}

// -------------------------------------------------------------------

// OKagv_FinishTrajectoryResponse

// bool state = 1;
inline void OKagv_FinishTrajectoryResponse::clear_state() {
  state_ = false;
}
inline bool OKagv_FinishTrajectoryResponse::_internal_state() const {
  return state_;
}
inline bool OKagv_FinishTrajectoryResponse::state() const {
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.OKagv_FinishTrajectoryResponse.state)
  return _internal_state();
}
inline void OKagv_FinishTrajectoryResponse::_internal_set_state(bool value) {
  
  state_ = value;
}
inline void OKagv_FinishTrajectoryResponse::set_state(bool value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:cartographer.cloud.proto.OKagv_FinishTrajectoryResponse.state)
}

// -------------------------------------------------------------------

// OKagv_WaitTrajectoryResponse

// bool state = 1;
inline void OKagv_WaitTrajectoryResponse::clear_state() {
  state_ = false;
}
inline bool OKagv_WaitTrajectoryResponse::_internal_state() const {
  return state_;
}
inline bool OKagv_WaitTrajectoryResponse::state() const {
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.OKagv_WaitTrajectoryResponse.state)
  return _internal_state();
}
inline void OKagv_WaitTrajectoryResponse::_internal_set_state(bool value) {
  
  state_ = value;
}
inline void OKagv_WaitTrajectoryResponse::set_state(bool value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:cartographer.cloud.proto.OKagv_WaitTrajectoryResponse.state)
}

// -------------------------------------------------------------------

// OKagv_GetOrderResponse

// int32 order_type = 1;
inline void OKagv_GetOrderResponse::clear_order_type() {
  order_type_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 OKagv_GetOrderResponse::_internal_order_type() const {
  return order_type_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 OKagv_GetOrderResponse::order_type() const {
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.OKagv_GetOrderResponse.order_type)
  return _internal_order_type();
}
inline void OKagv_GetOrderResponse::_internal_set_order_type(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  order_type_ = value;
}
inline void OKagv_GetOrderResponse::set_order_type(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_order_type(value);
  // @@protoc_insertion_point(field_set:cartographer.cloud.proto.OKagv_GetOrderResponse.order_type)
}

// -------------------------------------------------------------------

// OKagv_LoadTrajectoryRequest

// string filename = 1;
inline void OKagv_LoadTrajectoryRequest::clear_filename() {
  filename_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& OKagv_LoadTrajectoryRequest::filename() const {
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.OKagv_LoadTrajectoryRequest.filename)
  return _internal_filename();
}
inline void OKagv_LoadTrajectoryRequest::set_filename(const std::string& value) {
  _internal_set_filename(value);
  // @@protoc_insertion_point(field_set:cartographer.cloud.proto.OKagv_LoadTrajectoryRequest.filename)
}
inline std::string* OKagv_LoadTrajectoryRequest::mutable_filename() {
  // @@protoc_insertion_point(field_mutable:cartographer.cloud.proto.OKagv_LoadTrajectoryRequest.filename)
  return _internal_mutable_filename();
}
inline const std::string& OKagv_LoadTrajectoryRequest::_internal_filename() const {
  return filename_.GetNoArena();
}
inline void OKagv_LoadTrajectoryRequest::_internal_set_filename(const std::string& value) {
  
  filename_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void OKagv_LoadTrajectoryRequest::set_filename(std::string&& value) {
  
  filename_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cartographer.cloud.proto.OKagv_LoadTrajectoryRequest.filename)
}
inline void OKagv_LoadTrajectoryRequest::set_filename(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  filename_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cartographer.cloud.proto.OKagv_LoadTrajectoryRequest.filename)
}
inline void OKagv_LoadTrajectoryRequest::set_filename(const char* value, size_t size) {
  
  filename_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cartographer.cloud.proto.OKagv_LoadTrajectoryRequest.filename)
}
inline std::string* OKagv_LoadTrajectoryRequest::_internal_mutable_filename() {
  
  return filename_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* OKagv_LoadTrajectoryRequest::release_filename() {
  // @@protoc_insertion_point(field_release:cartographer.cloud.proto.OKagv_LoadTrajectoryRequest.filename)
  
  return filename_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void OKagv_LoadTrajectoryRequest::set_allocated_filename(std::string* filename) {
  if (filename != nullptr) {
    
  } else {
    
  }
  filename_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), filename);
  // @@protoc_insertion_point(field_set_allocated:cartographer.cloud.proto.OKagv_LoadTrajectoryRequest.filename)
}

// -------------------------------------------------------------------

// OKagv_LoadTrajectoryResponse

// bool state = 1;
inline void OKagv_LoadTrajectoryResponse::clear_state() {
  state_ = false;
}
inline bool OKagv_LoadTrajectoryResponse::_internal_state() const {
  return state_;
}
inline bool OKagv_LoadTrajectoryResponse::state() const {
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.OKagv_LoadTrajectoryResponse.state)
  return _internal_state();
}
inline void OKagv_LoadTrajectoryResponse::_internal_set_state(bool value) {
  
  state_ = value;
}
inline void OKagv_LoadTrajectoryResponse::set_state(bool value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:cartographer.cloud.proto.OKagv_LoadTrajectoryResponse.state)
}

// -------------------------------------------------------------------

// OKagv_LocalizeTrajectoryRequest

// bool use_initial_pose = 1;
inline void OKagv_LocalizeTrajectoryRequest::clear_use_initial_pose() {
  use_initial_pose_ = false;
}
inline bool OKagv_LocalizeTrajectoryRequest::_internal_use_initial_pose() const {
  return use_initial_pose_;
}
inline bool OKagv_LocalizeTrajectoryRequest::use_initial_pose() const {
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.OKagv_LocalizeTrajectoryRequest.use_initial_pose)
  return _internal_use_initial_pose();
}
inline void OKagv_LocalizeTrajectoryRequest::_internal_set_use_initial_pose(bool value) {
  
  use_initial_pose_ = value;
}
inline void OKagv_LocalizeTrajectoryRequest::set_use_initial_pose(bool value) {
  _internal_set_use_initial_pose(value);
  // @@protoc_insertion_point(field_set:cartographer.cloud.proto.OKagv_LocalizeTrajectoryRequest.use_initial_pose)
}

// .cartographer.transform.proto.Rigid3d initial_pose = 2;
inline bool OKagv_LocalizeTrajectoryRequest::_internal_has_initial_pose() const {
  return this != internal_default_instance() && initial_pose_ != nullptr;
}
inline bool OKagv_LocalizeTrajectoryRequest::has_initial_pose() const {
  return _internal_has_initial_pose();
}
inline const ::cartographer::transform::proto::Rigid3d& OKagv_LocalizeTrajectoryRequest::_internal_initial_pose() const {
  const ::cartographer::transform::proto::Rigid3d* p = initial_pose_;
  return p != nullptr ? *p : *reinterpret_cast<const ::cartographer::transform::proto::Rigid3d*>(
      &::cartographer::transform::proto::_Rigid3d_default_instance_);
}
inline const ::cartographer::transform::proto::Rigid3d& OKagv_LocalizeTrajectoryRequest::initial_pose() const {
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.OKagv_LocalizeTrajectoryRequest.initial_pose)
  return _internal_initial_pose();
}
inline ::cartographer::transform::proto::Rigid3d* OKagv_LocalizeTrajectoryRequest::release_initial_pose() {
  // @@protoc_insertion_point(field_release:cartographer.cloud.proto.OKagv_LocalizeTrajectoryRequest.initial_pose)
  
  ::cartographer::transform::proto::Rigid3d* temp = initial_pose_;
  initial_pose_ = nullptr;
  return temp;
}
inline ::cartographer::transform::proto::Rigid3d* OKagv_LocalizeTrajectoryRequest::_internal_mutable_initial_pose() {
  
  if (initial_pose_ == nullptr) {
    auto* p = CreateMaybeMessage<::cartographer::transform::proto::Rigid3d>(GetArenaNoVirtual());
    initial_pose_ = p;
  }
  return initial_pose_;
}
inline ::cartographer::transform::proto::Rigid3d* OKagv_LocalizeTrajectoryRequest::mutable_initial_pose() {
  // @@protoc_insertion_point(field_mutable:cartographer.cloud.proto.OKagv_LocalizeTrajectoryRequest.initial_pose)
  return _internal_mutable_initial_pose();
}
inline void OKagv_LocalizeTrajectoryRequest::set_allocated_initial_pose(::cartographer::transform::proto::Rigid3d* initial_pose) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(initial_pose_);
  }
  if (initial_pose) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      initial_pose = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, initial_pose, submessage_arena);
    }
    
  } else {
    
  }
  initial_pose_ = initial_pose;
  // @@protoc_insertion_point(field_set_allocated:cartographer.cloud.proto.OKagv_LocalizeTrajectoryRequest.initial_pose)
}

// -------------------------------------------------------------------

// OKagv_LocalizeTrajectoryResponse

// bool state = 1;
inline void OKagv_LocalizeTrajectoryResponse::clear_state() {
  state_ = false;
}
inline bool OKagv_LocalizeTrajectoryResponse::_internal_state() const {
  return state_;
}
inline bool OKagv_LocalizeTrajectoryResponse::state() const {
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.OKagv_LocalizeTrajectoryResponse.state)
  return _internal_state();
}
inline void OKagv_LocalizeTrajectoryResponse::_internal_set_state(bool value) {
  
  state_ = value;
}
inline void OKagv_LocalizeTrajectoryResponse::set_state(bool value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:cartographer.cloud.proto.OKagv_LocalizeTrajectoryResponse.state)
}

// int32 confidence_score = 2;
inline void OKagv_LocalizeTrajectoryResponse::clear_confidence_score() {
  confidence_score_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 OKagv_LocalizeTrajectoryResponse::_internal_confidence_score() const {
  return confidence_score_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 OKagv_LocalizeTrajectoryResponse::confidence_score() const {
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.OKagv_LocalizeTrajectoryResponse.confidence_score)
  return _internal_confidence_score();
}
inline void OKagv_LocalizeTrajectoryResponse::_internal_set_confidence_score(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  confidence_score_ = value;
}
inline void OKagv_LocalizeTrajectoryResponse::set_confidence_score(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_confidence_score(value);
  // @@protoc_insertion_point(field_set:cartographer.cloud.proto.OKagv_LocalizeTrajectoryResponse.confidence_score)
}

// -------------------------------------------------------------------

// OKagv_StartTrajectoryRequest

// string trajectory_type = 1;
inline void OKagv_StartTrajectoryRequest::clear_trajectory_type() {
  trajectory_type_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& OKagv_StartTrajectoryRequest::trajectory_type() const {
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.OKagv_StartTrajectoryRequest.trajectory_type)
  return _internal_trajectory_type();
}
inline void OKagv_StartTrajectoryRequest::set_trajectory_type(const std::string& value) {
  _internal_set_trajectory_type(value);
  // @@protoc_insertion_point(field_set:cartographer.cloud.proto.OKagv_StartTrajectoryRequest.trajectory_type)
}
inline std::string* OKagv_StartTrajectoryRequest::mutable_trajectory_type() {
  // @@protoc_insertion_point(field_mutable:cartographer.cloud.proto.OKagv_StartTrajectoryRequest.trajectory_type)
  return _internal_mutable_trajectory_type();
}
inline const std::string& OKagv_StartTrajectoryRequest::_internal_trajectory_type() const {
  return trajectory_type_.GetNoArena();
}
inline void OKagv_StartTrajectoryRequest::_internal_set_trajectory_type(const std::string& value) {
  
  trajectory_type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void OKagv_StartTrajectoryRequest::set_trajectory_type(std::string&& value) {
  
  trajectory_type_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cartographer.cloud.proto.OKagv_StartTrajectoryRequest.trajectory_type)
}
inline void OKagv_StartTrajectoryRequest::set_trajectory_type(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  trajectory_type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cartographer.cloud.proto.OKagv_StartTrajectoryRequest.trajectory_type)
}
inline void OKagv_StartTrajectoryRequest::set_trajectory_type(const char* value, size_t size) {
  
  trajectory_type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cartographer.cloud.proto.OKagv_StartTrajectoryRequest.trajectory_type)
}
inline std::string* OKagv_StartTrajectoryRequest::_internal_mutable_trajectory_type() {
  
  return trajectory_type_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* OKagv_StartTrajectoryRequest::release_trajectory_type() {
  // @@protoc_insertion_point(field_release:cartographer.cloud.proto.OKagv_StartTrajectoryRequest.trajectory_type)
  
  return trajectory_type_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void OKagv_StartTrajectoryRequest::set_allocated_trajectory_type(std::string* trajectory_type) {
  if (trajectory_type != nullptr) {
    
  } else {
    
  }
  trajectory_type_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), trajectory_type);
  // @@protoc_insertion_point(field_set_allocated:cartographer.cloud.proto.OKagv_StartTrajectoryRequest.trajectory_type)
}

// string trajectory_id = 2;
inline void OKagv_StartTrajectoryRequest::clear_trajectory_id() {
  trajectory_id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& OKagv_StartTrajectoryRequest::trajectory_id() const {
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.OKagv_StartTrajectoryRequest.trajectory_id)
  return _internal_trajectory_id();
}
inline void OKagv_StartTrajectoryRequest::set_trajectory_id(const std::string& value) {
  _internal_set_trajectory_id(value);
  // @@protoc_insertion_point(field_set:cartographer.cloud.proto.OKagv_StartTrajectoryRequest.trajectory_id)
}
inline std::string* OKagv_StartTrajectoryRequest::mutable_trajectory_id() {
  // @@protoc_insertion_point(field_mutable:cartographer.cloud.proto.OKagv_StartTrajectoryRequest.trajectory_id)
  return _internal_mutable_trajectory_id();
}
inline const std::string& OKagv_StartTrajectoryRequest::_internal_trajectory_id() const {
  return trajectory_id_.GetNoArena();
}
inline void OKagv_StartTrajectoryRequest::_internal_set_trajectory_id(const std::string& value) {
  
  trajectory_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void OKagv_StartTrajectoryRequest::set_trajectory_id(std::string&& value) {
  
  trajectory_id_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cartographer.cloud.proto.OKagv_StartTrajectoryRequest.trajectory_id)
}
inline void OKagv_StartTrajectoryRequest::set_trajectory_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  trajectory_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cartographer.cloud.proto.OKagv_StartTrajectoryRequest.trajectory_id)
}
inline void OKagv_StartTrajectoryRequest::set_trajectory_id(const char* value, size_t size) {
  
  trajectory_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cartographer.cloud.proto.OKagv_StartTrajectoryRequest.trajectory_id)
}
inline std::string* OKagv_StartTrajectoryRequest::_internal_mutable_trajectory_id() {
  
  return trajectory_id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* OKagv_StartTrajectoryRequest::release_trajectory_id() {
  // @@protoc_insertion_point(field_release:cartographer.cloud.proto.OKagv_StartTrajectoryRequest.trajectory_id)
  
  return trajectory_id_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void OKagv_StartTrajectoryRequest::set_allocated_trajectory_id(std::string* trajectory_id) {
  if (trajectory_id != nullptr) {
    
  } else {
    
  }
  trajectory_id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), trajectory_id);
  // @@protoc_insertion_point(field_set_allocated:cartographer.cloud.proto.OKagv_StartTrajectoryRequest.trajectory_id)
}

// bool use_initial_pose = 3;
inline void OKagv_StartTrajectoryRequest::clear_use_initial_pose() {
  use_initial_pose_ = false;
}
inline bool OKagv_StartTrajectoryRequest::_internal_use_initial_pose() const {
  return use_initial_pose_;
}
inline bool OKagv_StartTrajectoryRequest::use_initial_pose() const {
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.OKagv_StartTrajectoryRequest.use_initial_pose)
  return _internal_use_initial_pose();
}
inline void OKagv_StartTrajectoryRequest::_internal_set_use_initial_pose(bool value) {
  
  use_initial_pose_ = value;
}
inline void OKagv_StartTrajectoryRequest::set_use_initial_pose(bool value) {
  _internal_set_use_initial_pose(value);
  // @@protoc_insertion_point(field_set:cartographer.cloud.proto.OKagv_StartTrajectoryRequest.use_initial_pose)
}

// .cartographer.transform.proto.Rigid3d initial_pose = 4;
inline bool OKagv_StartTrajectoryRequest::_internal_has_initial_pose() const {
  return this != internal_default_instance() && initial_pose_ != nullptr;
}
inline bool OKagv_StartTrajectoryRequest::has_initial_pose() const {
  return _internal_has_initial_pose();
}
inline const ::cartographer::transform::proto::Rigid3d& OKagv_StartTrajectoryRequest::_internal_initial_pose() const {
  const ::cartographer::transform::proto::Rigid3d* p = initial_pose_;
  return p != nullptr ? *p : *reinterpret_cast<const ::cartographer::transform::proto::Rigid3d*>(
      &::cartographer::transform::proto::_Rigid3d_default_instance_);
}
inline const ::cartographer::transform::proto::Rigid3d& OKagv_StartTrajectoryRequest::initial_pose() const {
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.OKagv_StartTrajectoryRequest.initial_pose)
  return _internal_initial_pose();
}
inline ::cartographer::transform::proto::Rigid3d* OKagv_StartTrajectoryRequest::release_initial_pose() {
  // @@protoc_insertion_point(field_release:cartographer.cloud.proto.OKagv_StartTrajectoryRequest.initial_pose)
  
  ::cartographer::transform::proto::Rigid3d* temp = initial_pose_;
  initial_pose_ = nullptr;
  return temp;
}
inline ::cartographer::transform::proto::Rigid3d* OKagv_StartTrajectoryRequest::_internal_mutable_initial_pose() {
  
  if (initial_pose_ == nullptr) {
    auto* p = CreateMaybeMessage<::cartographer::transform::proto::Rigid3d>(GetArenaNoVirtual());
    initial_pose_ = p;
  }
  return initial_pose_;
}
inline ::cartographer::transform::proto::Rigid3d* OKagv_StartTrajectoryRequest::mutable_initial_pose() {
  // @@protoc_insertion_point(field_mutable:cartographer.cloud.proto.OKagv_StartTrajectoryRequest.initial_pose)
  return _internal_mutable_initial_pose();
}
inline void OKagv_StartTrajectoryRequest::set_allocated_initial_pose(::cartographer::transform::proto::Rigid3d* initial_pose) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(initial_pose_);
  }
  if (initial_pose) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      initial_pose = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, initial_pose, submessage_arena);
    }
    
  } else {
    
  }
  initial_pose_ = initial_pose;
  // @@protoc_insertion_point(field_set_allocated:cartographer.cloud.proto.OKagv_StartTrajectoryRequest.initial_pose)
}

// string relative_to_trajectory_id = 5;
inline void OKagv_StartTrajectoryRequest::clear_relative_to_trajectory_id() {
  relative_to_trajectory_id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& OKagv_StartTrajectoryRequest::relative_to_trajectory_id() const {
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.OKagv_StartTrajectoryRequest.relative_to_trajectory_id)
  return _internal_relative_to_trajectory_id();
}
inline void OKagv_StartTrajectoryRequest::set_relative_to_trajectory_id(const std::string& value) {
  _internal_set_relative_to_trajectory_id(value);
  // @@protoc_insertion_point(field_set:cartographer.cloud.proto.OKagv_StartTrajectoryRequest.relative_to_trajectory_id)
}
inline std::string* OKagv_StartTrajectoryRequest::mutable_relative_to_trajectory_id() {
  // @@protoc_insertion_point(field_mutable:cartographer.cloud.proto.OKagv_StartTrajectoryRequest.relative_to_trajectory_id)
  return _internal_mutable_relative_to_trajectory_id();
}
inline const std::string& OKagv_StartTrajectoryRequest::_internal_relative_to_trajectory_id() const {
  return relative_to_trajectory_id_.GetNoArena();
}
inline void OKagv_StartTrajectoryRequest::_internal_set_relative_to_trajectory_id(const std::string& value) {
  
  relative_to_trajectory_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void OKagv_StartTrajectoryRequest::set_relative_to_trajectory_id(std::string&& value) {
  
  relative_to_trajectory_id_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cartographer.cloud.proto.OKagv_StartTrajectoryRequest.relative_to_trajectory_id)
}
inline void OKagv_StartTrajectoryRequest::set_relative_to_trajectory_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  relative_to_trajectory_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cartographer.cloud.proto.OKagv_StartTrajectoryRequest.relative_to_trajectory_id)
}
inline void OKagv_StartTrajectoryRequest::set_relative_to_trajectory_id(const char* value, size_t size) {
  
  relative_to_trajectory_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cartographer.cloud.proto.OKagv_StartTrajectoryRequest.relative_to_trajectory_id)
}
inline std::string* OKagv_StartTrajectoryRequest::_internal_mutable_relative_to_trajectory_id() {
  
  return relative_to_trajectory_id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* OKagv_StartTrajectoryRequest::release_relative_to_trajectory_id() {
  // @@protoc_insertion_point(field_release:cartographer.cloud.proto.OKagv_StartTrajectoryRequest.relative_to_trajectory_id)
  
  return relative_to_trajectory_id_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void OKagv_StartTrajectoryRequest::set_allocated_relative_to_trajectory_id(std::string* relative_to_trajectory_id) {
  if (relative_to_trajectory_id != nullptr) {
    
  } else {
    
  }
  relative_to_trajectory_id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), relative_to_trajectory_id);
  // @@protoc_insertion_point(field_set_allocated:cartographer.cloud.proto.OKagv_StartTrajectoryRequest.relative_to_trajectory_id)
}

// -------------------------------------------------------------------

// OKagv_SaveTrajectoryRequest

// string filename = 1;
inline void OKagv_SaveTrajectoryRequest::clear_filename() {
  filename_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& OKagv_SaveTrajectoryRequest::filename() const {
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.OKagv_SaveTrajectoryRequest.filename)
  return _internal_filename();
}
inline void OKagv_SaveTrajectoryRequest::set_filename(const std::string& value) {
  _internal_set_filename(value);
  // @@protoc_insertion_point(field_set:cartographer.cloud.proto.OKagv_SaveTrajectoryRequest.filename)
}
inline std::string* OKagv_SaveTrajectoryRequest::mutable_filename() {
  // @@protoc_insertion_point(field_mutable:cartographer.cloud.proto.OKagv_SaveTrajectoryRequest.filename)
  return _internal_mutable_filename();
}
inline const std::string& OKagv_SaveTrajectoryRequest::_internal_filename() const {
  return filename_.GetNoArena();
}
inline void OKagv_SaveTrajectoryRequest::_internal_set_filename(const std::string& value) {
  
  filename_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void OKagv_SaveTrajectoryRequest::set_filename(std::string&& value) {
  
  filename_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cartographer.cloud.proto.OKagv_SaveTrajectoryRequest.filename)
}
inline void OKagv_SaveTrajectoryRequest::set_filename(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  filename_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cartographer.cloud.proto.OKagv_SaveTrajectoryRequest.filename)
}
inline void OKagv_SaveTrajectoryRequest::set_filename(const char* value, size_t size) {
  
  filename_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cartographer.cloud.proto.OKagv_SaveTrajectoryRequest.filename)
}
inline std::string* OKagv_SaveTrajectoryRequest::_internal_mutable_filename() {
  
  return filename_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* OKagv_SaveTrajectoryRequest::release_filename() {
  // @@protoc_insertion_point(field_release:cartographer.cloud.proto.OKagv_SaveTrajectoryRequest.filename)
  
  return filename_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void OKagv_SaveTrajectoryRequest::set_allocated_filename(std::string* filename) {
  if (filename != nullptr) {
    
  } else {
    
  }
  filename_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), filename);
  // @@protoc_insertion_point(field_set_allocated:cartographer.cloud.proto.OKagv_SaveTrajectoryRequest.filename)
}

// bool include_unfinished_submaps = 2;
inline void OKagv_SaveTrajectoryRequest::clear_include_unfinished_submaps() {
  include_unfinished_submaps_ = false;
}
inline bool OKagv_SaveTrajectoryRequest::_internal_include_unfinished_submaps() const {
  return include_unfinished_submaps_;
}
inline bool OKagv_SaveTrajectoryRequest::include_unfinished_submaps() const {
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.OKagv_SaveTrajectoryRequest.include_unfinished_submaps)
  return _internal_include_unfinished_submaps();
}
inline void OKagv_SaveTrajectoryRequest::_internal_set_include_unfinished_submaps(bool value) {
  
  include_unfinished_submaps_ = value;
}
inline void OKagv_SaveTrajectoryRequest::set_include_unfinished_submaps(bool value) {
  _internal_set_include_unfinished_submaps(value);
  // @@protoc_insertion_point(field_set:cartographer.cloud.proto.OKagv_SaveTrajectoryRequest.include_unfinished_submaps)
}

// -------------------------------------------------------------------

// OKagv_GetTrajectoryStateResponse

// int32 code = 1;
inline void OKagv_GetTrajectoryStateResponse::clear_code() {
  code_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 OKagv_GetTrajectoryStateResponse::_internal_code() const {
  return code_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 OKagv_GetTrajectoryStateResponse::code() const {
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.OKagv_GetTrajectoryStateResponse.code)
  return _internal_code();
}
inline void OKagv_GetTrajectoryStateResponse::_internal_set_code(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  code_ = value;
}
inline void OKagv_GetTrajectoryStateResponse::set_code(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:cartographer.cloud.proto.OKagv_GetTrajectoryStateResponse.code)
}

// string message = 2;
inline void OKagv_GetTrajectoryStateResponse::clear_message() {
  message_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& OKagv_GetTrajectoryStateResponse::message() const {
  // @@protoc_insertion_point(field_get:cartographer.cloud.proto.OKagv_GetTrajectoryStateResponse.message)
  return _internal_message();
}
inline void OKagv_GetTrajectoryStateResponse::set_message(const std::string& value) {
  _internal_set_message(value);
  // @@protoc_insertion_point(field_set:cartographer.cloud.proto.OKagv_GetTrajectoryStateResponse.message)
}
inline std::string* OKagv_GetTrajectoryStateResponse::mutable_message() {
  // @@protoc_insertion_point(field_mutable:cartographer.cloud.proto.OKagv_GetTrajectoryStateResponse.message)
  return _internal_mutable_message();
}
inline const std::string& OKagv_GetTrajectoryStateResponse::_internal_message() const {
  return message_.GetNoArena();
}
inline void OKagv_GetTrajectoryStateResponse::_internal_set_message(const std::string& value) {
  
  message_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void OKagv_GetTrajectoryStateResponse::set_message(std::string&& value) {
  
  message_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cartographer.cloud.proto.OKagv_GetTrajectoryStateResponse.message)
}
inline void OKagv_GetTrajectoryStateResponse::set_message(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  message_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cartographer.cloud.proto.OKagv_GetTrajectoryStateResponse.message)
}
inline void OKagv_GetTrajectoryStateResponse::set_message(const char* value, size_t size) {
  
  message_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cartographer.cloud.proto.OKagv_GetTrajectoryStateResponse.message)
}
inline std::string* OKagv_GetTrajectoryStateResponse::_internal_mutable_message() {
  
  return message_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* OKagv_GetTrajectoryStateResponse::release_message() {
  // @@protoc_insertion_point(field_release:cartographer.cloud.proto.OKagv_GetTrajectoryStateResponse.message)
  
  return message_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void OKagv_GetTrajectoryStateResponse::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  message_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:cartographer.cloud.proto.OKagv_GetTrajectoryStateResponse.message)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace cloud
}  // namespace cartographer

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::cartographer::cloud::proto::SensorType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::cartographer::cloud::proto::SensorType>() {
  return ::cartographer::cloud::proto::SensorType_descriptor();
}
template <> struct is_proto_enum< ::cartographer::cloud::proto::TrajectoryState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::cartographer::cloud::proto::TrajectoryState>() {
  return ::cartographer::cloud::proto::TrajectoryState_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_cartographer_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto
